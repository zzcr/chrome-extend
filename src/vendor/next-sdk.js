(function (Je, Ha) {
  typeof exports == "object" && typeof module < "u"
    ? Ha(exports)
    : typeof define == "function" && define.amd
    ? define(["exports"], Ha)
    : ((Je = typeof globalThis < "u" ? globalThis : Je || self),
      Ha((Je.WebMCP = {})));
})(this, function (Je) {
  "use strict";
  var Ha =
    typeof globalThis < "u"
      ? globalThis
      : typeof window < "u"
      ? window
      : typeof global < "u"
      ? global
      : typeof self < "u"
      ? self
      : {};
  function df(t) {
    return t &&
      t.__esModule &&
      Object.prototype.hasOwnProperty.call(t, "default")
      ? t.default
      : t;
  }
  var yl = { exports: {} },
    ff = {},
    gr = {},
    aa = {},
    Ba = {},
    Ne = {},
    Ja = {};
  (function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.regexpCode =
        t.getEsmExportName =
        t.getProperty =
        t.safeStringify =
        t.stringify =
        t.strConcat =
        t.addCodeArg =
        t.str =
        t._ =
        t.nil =
        t._Code =
        t.Name =
        t.IDENTIFIER =
        t._CodeOrName =
          void 0);
    class e {}
    (t._CodeOrName = e), (t.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i);
    class r extends e {
      constructor(y) {
        if ((super(), !t.IDENTIFIER.test(y)))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = y;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    t.Name = r;
    class a extends e {
      constructor(y) {
        super(), (this._items = typeof y == "string" ? [y] : y);
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1) return !1;
        const y = this._items[0];
        return y === "" || y === '""';
      }
      get str() {
        var y;
        return (y = this._str) !== null && y !== void 0
          ? y
          : (this._str = this._items.reduce((_, w) => `${_}${w}`, ""));
      }
      get names() {
        var y;
        return (y = this._names) !== null && y !== void 0
          ? y
          : (this._names = this._items.reduce(
              (_, w) => (w instanceof r && (_[w.str] = (_[w.str] || 0) + 1), _),
              {}
            ));
      }
    }
    (t._Code = a), (t.nil = new a(""));
    function n(h, ...y) {
      const _ = [h[0]];
      let w = 0;
      for (; w < y.length; ) i(_, y[w]), _.push(h[++w]);
      return new a(_);
    }
    t._ = n;
    const s = new a("+");
    function o(h, ...y) {
      const _ = [d(h[0])];
      let w = 0;
      for (; w < y.length; ) _.push(s), i(_, y[w]), _.push(s, d(h[++w]));
      return l(_), new a(_);
    }
    t.str = o;
    function i(h, y) {
      y instanceof a
        ? h.push(...y._items)
        : y instanceof r
        ? h.push(y)
        : h.push(f(y));
    }
    t.addCodeArg = i;
    function l(h) {
      let y = 1;
      for (; y < h.length - 1; ) {
        if (h[y] === s) {
          const _ = c(h[y - 1], h[y + 1]);
          if (_ !== void 0) {
            h.splice(y - 1, 3, _);
            continue;
          }
          h[y++] = "+";
        }
        y++;
      }
    }
    function c(h, y) {
      if (y === '""') return h;
      if (h === '""') return y;
      if (typeof h == "string")
        return y instanceof r || h[h.length - 1] !== '"'
          ? void 0
          : typeof y != "string"
          ? `${h.slice(0, -1)}${y}"`
          : y[0] === '"'
          ? h.slice(0, -1) + y.slice(1)
          : void 0;
      if (typeof y == "string" && y[0] === '"' && !(h instanceof r))
        return `"${h}${y.slice(1)}`;
    }
    function u(h, y) {
      return y.emptyStr() ? h : h.emptyStr() ? y : o`${h}${y}`;
    }
    t.strConcat = u;
    function f(h) {
      return typeof h == "number" || typeof h == "boolean" || h === null
        ? h
        : d(Array.isArray(h) ? h.join(",") : h);
    }
    function v(h) {
      return new a(d(h));
    }
    t.stringify = v;
    function d(h) {
      return JSON.stringify(h)
        .replace(/\u2028/g, "\\u2028")
        .replace(/\u2029/g, "\\u2029");
    }
    t.safeStringify = d;
    function p(h) {
      return typeof h == "string" && t.IDENTIFIER.test(h)
        ? new a(`.${h}`)
        : n`[${h}]`;
    }
    t.getProperty = p;
    function g(h) {
      if (typeof h == "string" && t.IDENTIFIER.test(h)) return new a(`${h}`);
      throw new Error(
        `CodeGen: invalid export name: ${h}, use explicit $id name mapping`
      );
    }
    t.getEsmExportName = g;
    function m(h) {
      return new a(h.toString());
    }
    t.regexpCode = m;
  })(Ja);
  var _l = {};
  (function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.ValueScope =
        t.ValueScopeName =
        t.Scope =
        t.varKinds =
        t.UsedValueState =
          void 0);
    const e = Ja;
    class r extends Error {
      constructor(c) {
        super(`CodeGen: "code" for ${c} not defined`), (this.value = c.value);
      }
    }
    var a;
    (function (l) {
      (l[(l.Started = 0)] = "Started"), (l[(l.Completed = 1)] = "Completed");
    })(a || (t.UsedValueState = a = {})),
      (t.varKinds = {
        const: new e.Name("const"),
        let: new e.Name("let"),
        var: new e.Name("var"),
      });
    class n {
      constructor({ prefixes: c, parent: u } = {}) {
        (this._names = {}), (this._prefixes = c), (this._parent = u);
      }
      toName(c) {
        return c instanceof e.Name ? c : this.name(c);
      }
      name(c) {
        return new e.Name(this._newName(c));
      }
      _newName(c) {
        const u = this._names[c] || this._nameGroup(c);
        return `${c}${u.index++}`;
      }
      _nameGroup(c) {
        var u, f;
        if (
          (!(
            (f =
              (u = this._parent) === null || u === void 0
                ? void 0
                : u._prefixes) === null || f === void 0
          ) &&
            f.has(c)) ||
          (this._prefixes && !this._prefixes.has(c))
        )
          throw new Error(
            `CodeGen: prefix "${c}" is not allowed in this scope`
          );
        return (this._names[c] = { prefix: c, index: 0 });
      }
    }
    t.Scope = n;
    class s extends e.Name {
      constructor(c, u) {
        super(u), (this.prefix = c);
      }
      setValue(c, { property: u, itemIndex: f }) {
        (this.value = c), (this.scopePath = (0, e._)`.${new e.Name(u)}[${f}]`);
      }
    }
    t.ValueScopeName = s;
    const o = (0, e._)`\n`;
    class i extends n {
      constructor(c) {
        super(c),
          (this._values = {}),
          (this._scope = c.scope),
          (this.opts = { ...c, _n: c.lines ? o : e.nil });
      }
      get() {
        return this._scope;
      }
      name(c) {
        return new s(c, this._newName(c));
      }
      value(c, u) {
        var f;
        if (u.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const v = this.toName(c),
          { prefix: d } = v,
          p = (f = u.key) !== null && f !== void 0 ? f : u.ref;
        let g = this._values[d];
        if (g) {
          const y = g.get(p);
          if (y) return y;
        } else g = this._values[d] = new Map();
        g.set(p, v);
        const m = this._scope[d] || (this._scope[d] = []),
          h = m.length;
        return (m[h] = u.ref), v.setValue(u, { property: d, itemIndex: h }), v;
      }
      getValue(c, u) {
        const f = this._values[c];
        if (f) return f.get(u);
      }
      scopeRefs(c, u = this._values) {
        return this._reduceValues(u, (f) => {
          if (f.scopePath === void 0)
            throw new Error(`CodeGen: name "${f}" has no value`);
          return (0, e._)`${c}${f.scopePath}`;
        });
      }
      scopeCode(c = this._values, u, f) {
        return this._reduceValues(
          c,
          (v) => {
            if (v.value === void 0)
              throw new Error(`CodeGen: name "${v}" has no value`);
            return v.value.code;
          },
          u,
          f
        );
      }
      _reduceValues(c, u, f = {}, v) {
        let d = e.nil;
        for (const p in c) {
          const g = c[p];
          if (!g) continue;
          const m = (f[p] = f[p] || new Map());
          g.forEach((h) => {
            if (m.has(h)) return;
            m.set(h, a.Started);
            let y = u(h);
            if (y) {
              const _ = this.opts.es5 ? t.varKinds.var : t.varKinds.const;
              d = (0, e._)`${d}${_} ${h} = ${y};${this.opts._n}`;
            } else if ((y = v == null ? void 0 : v(h)))
              d = (0, e._)`${d}${y}${this.opts._n}`;
            else throw new r(h);
            m.set(h, a.Completed);
          });
        }
        return d;
      }
    }
    t.ValueScope = i;
  })(_l),
    (function (t) {
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.or =
          t.and =
          t.not =
          t.CodeGen =
          t.operators =
          t.varKinds =
          t.ValueScopeName =
          t.ValueScope =
          t.Scope =
          t.Name =
          t.regexpCode =
          t.stringify =
          t.getProperty =
          t.nil =
          t.strConcat =
          t.str =
          t._ =
            void 0);
      const e = Ja,
        r = _l;
      var a = Ja;
      Object.defineProperty(t, "_", {
        enumerable: !0,
        get: function () {
          return a._;
        },
      }),
        Object.defineProperty(t, "str", {
          enumerable: !0,
          get: function () {
            return a.str;
          },
        }),
        Object.defineProperty(t, "strConcat", {
          enumerable: !0,
          get: function () {
            return a.strConcat;
          },
        }),
        Object.defineProperty(t, "nil", {
          enumerable: !0,
          get: function () {
            return a.nil;
          },
        }),
        Object.defineProperty(t, "getProperty", {
          enumerable: !0,
          get: function () {
            return a.getProperty;
          },
        }),
        Object.defineProperty(t, "stringify", {
          enumerable: !0,
          get: function () {
            return a.stringify;
          },
        }),
        Object.defineProperty(t, "regexpCode", {
          enumerable: !0,
          get: function () {
            return a.regexpCode;
          },
        }),
        Object.defineProperty(t, "Name", {
          enumerable: !0,
          get: function () {
            return a.Name;
          },
        });
      var n = _l;
      Object.defineProperty(t, "Scope", {
        enumerable: !0,
        get: function () {
          return n.Scope;
        },
      }),
        Object.defineProperty(t, "ValueScope", {
          enumerable: !0,
          get: function () {
            return n.ValueScope;
          },
        }),
        Object.defineProperty(t, "ValueScopeName", {
          enumerable: !0,
          get: function () {
            return n.ValueScopeName;
          },
        }),
        Object.defineProperty(t, "varKinds", {
          enumerable: !0,
          get: function () {
            return n.varKinds;
          },
        }),
        (t.operators = {
          GT: new e._Code(">"),
          GTE: new e._Code(">="),
          LT: new e._Code("<"),
          LTE: new e._Code("<="),
          EQ: new e._Code("==="),
          NEQ: new e._Code("!=="),
          NOT: new e._Code("!"),
          OR: new e._Code("||"),
          AND: new e._Code("&&"),
          ADD: new e._Code("+"),
        });
      class s {
        optimizeNodes() {
          return this;
        }
        optimizeNames(b, T) {
          return this;
        }
      }
      class o extends s {
        constructor(b, T, q) {
          super(), (this.varKind = b), (this.name = T), (this.rhs = q);
        }
        render({ es5: b, _n: T }) {
          const q = b ? r.varKinds.var : this.varKind,
            G = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${q} ${this.name}${G};` + T;
        }
        optimizeNames(b, T) {
          if (b[this.name.str])
            return this.rhs && (this.rhs = Z(this.rhs, b, T)), this;
        }
        get names() {
          return this.rhs instanceof e._CodeOrName ? this.rhs.names : {};
        }
      }
      class i extends s {
        constructor(b, T, q) {
          super(), (this.lhs = b), (this.rhs = T), (this.sideEffects = q);
        }
        render({ _n: b }) {
          return `${this.lhs} = ${this.rhs};` + b;
        }
        optimizeNames(b, T) {
          if (
            !(
              this.lhs instanceof e.Name &&
              !b[this.lhs.str] &&
              !this.sideEffects
            )
          )
            return (this.rhs = Z(this.rhs, b, T)), this;
        }
        get names() {
          const b = this.lhs instanceof e.Name ? {} : { ...this.lhs.names };
          return z(b, this.rhs);
        }
      }
      class l extends i {
        constructor(b, T, q, G) {
          super(b, q, G), (this.op = T);
        }
        render({ _n: b }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + b;
        }
      }
      class c extends s {
        constructor(b) {
          super(), (this.label = b), (this.names = {});
        }
        render({ _n: b }) {
          return `${this.label}:` + b;
        }
      }
      class u extends s {
        constructor(b) {
          super(), (this.label = b), (this.names = {});
        }
        render({ _n: b }) {
          return `break${this.label ? ` ${this.label}` : ""};` + b;
        }
      }
      class f extends s {
        constructor(b) {
          super(), (this.error = b);
        }
        render({ _n: b }) {
          return `throw ${this.error};` + b;
        }
        get names() {
          return this.error.names;
        }
      }
      class v extends s {
        constructor(b) {
          super(), (this.code = b);
        }
        render({ _n: b }) {
          return `${this.code};` + b;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(b, T) {
          return (this.code = Z(this.code, b, T)), this;
        }
        get names() {
          return this.code instanceof e._CodeOrName ? this.code.names : {};
        }
      }
      class d extends s {
        constructor(b = []) {
          super(), (this.nodes = b);
        }
        render(b) {
          return this.nodes.reduce((T, q) => T + q.render(b), "");
        }
        optimizeNodes() {
          const { nodes: b } = this;
          let T = b.length;
          for (; T--; ) {
            const q = b[T].optimizeNodes();
            Array.isArray(q)
              ? b.splice(T, 1, ...q)
              : q
              ? (b[T] = q)
              : b.splice(T, 1);
          }
          return b.length > 0 ? this : void 0;
        }
        optimizeNames(b, T) {
          const { nodes: q } = this;
          let G = q.length;
          for (; G--; ) {
            const ee = q[G];
            ee.optimizeNames(b, T) || (te(b, ee.names), q.splice(G, 1));
          }
          return q.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((b, T) => J(b, T.names), {});
        }
      }
      class p extends d {
        render(b) {
          return "{" + b._n + super.render(b) + "}" + b._n;
        }
      }
      class g extends d {}
      class m extends p {}
      m.kind = "else";
      class h extends p {
        constructor(b, T) {
          super(T), (this.condition = b);
        }
        render(b) {
          let T = `if(${this.condition})` + super.render(b);
          return this.else && (T += "else " + this.else.render(b)), T;
        }
        optimizeNodes() {
          super.optimizeNodes();
          const b = this.condition;
          if (b === !0) return this.nodes;
          let T = this.else;
          if (T) {
            const q = T.optimizeNodes();
            T = this.else = Array.isArray(q) ? new m(q) : q;
          }
          if (T)
            return b === !1
              ? T instanceof h
                ? T
                : T.nodes
              : this.nodes.length
              ? this
              : new h(me(b), T instanceof h ? [T] : T.nodes);
          if (!(b === !1 || !this.nodes.length)) return this;
        }
        optimizeNames(b, T) {
          var q;
          if (
            ((this.else =
              (q = this.else) === null || q === void 0
                ? void 0
                : q.optimizeNames(b, T)),
            !!(super.optimizeNames(b, T) || this.else))
          )
            return (this.condition = Z(this.condition, b, T)), this;
        }
        get names() {
          const b = super.names;
          return z(b, this.condition), this.else && J(b, this.else.names), b;
        }
      }
      h.kind = "if";
      class y extends p {}
      y.kind = "for";
      class _ extends y {
        constructor(b) {
          super(), (this.iteration = b);
        }
        render(b) {
          return `for(${this.iteration})` + super.render(b);
        }
        optimizeNames(b, T) {
          if (super.optimizeNames(b, T))
            return (this.iteration = Z(this.iteration, b, T)), this;
        }
        get names() {
          return J(super.names, this.iteration.names);
        }
      }
      class w extends y {
        constructor(b, T, q, G) {
          super(),
            (this.varKind = b),
            (this.name = T),
            (this.from = q),
            (this.to = G);
        }
        render(b) {
          const T = b.es5 ? r.varKinds.var : this.varKind,
            { name: q, from: G, to: ee } = this;
          return `for(${T} ${q}=${G}; ${q}<${ee}; ${q}++)` + super.render(b);
        }
        get names() {
          const b = z(super.names, this.from);
          return z(b, this.to);
        }
      }
      class E extends y {
        constructor(b, T, q, G) {
          super(),
            (this.loop = b),
            (this.varKind = T),
            (this.name = q),
            (this.iterable = G);
        }
        render(b) {
          return (
            `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
            super.render(b)
          );
        }
        optimizeNames(b, T) {
          if (super.optimizeNames(b, T))
            return (this.iterable = Z(this.iterable, b, T)), this;
        }
        get names() {
          return J(super.names, this.iterable.names);
        }
      }
      class P extends p {
        constructor(b, T, q) {
          super(), (this.name = b), (this.args = T), (this.async = q);
        }
        render(b) {
          return (
            `${this.async ? "async " : ""}function ${this.name}(${this.args})` +
            super.render(b)
          );
        }
      }
      P.kind = "func";
      class x extends d {
        render(b) {
          return "return " + super.render(b);
        }
      }
      x.kind = "return";
      class A extends p {
        render(b) {
          let T = "try" + super.render(b);
          return (
            this.catch && (T += this.catch.render(b)),
            this.finally && (T += this.finally.render(b)),
            T
          );
        }
        optimizeNodes() {
          var b, T;
          return (
            super.optimizeNodes(),
            (b = this.catch) === null || b === void 0 || b.optimizeNodes(),
            (T = this.finally) === null || T === void 0 || T.optimizeNodes(),
            this
          );
        }
        optimizeNames(b, T) {
          var q, G;
          return (
            super.optimizeNames(b, T),
            (q = this.catch) === null || q === void 0 || q.optimizeNames(b, T),
            (G = this.finally) === null ||
              G === void 0 ||
              G.optimizeNames(b, T),
            this
          );
        }
        get names() {
          const b = super.names;
          return (
            this.catch && J(b, this.catch.names),
            this.finally && J(b, this.finally.names),
            b
          );
        }
      }
      class M extends p {
        constructor(b) {
          super(), (this.error = b);
        }
        render(b) {
          return `catch(${this.error})` + super.render(b);
        }
      }
      M.kind = "catch";
      class H extends p {
        render(b) {
          return "finally" + super.render(b);
        }
      }
      H.kind = "finally";
      class V {
        constructor(b, T = {}) {
          (this._values = {}),
            (this._blockStarts = []),
            (this._constants = {}),
            (this.opts = {
              ...T,
              _n: T.lines
                ? `
`
                : "",
            }),
            (this._extScope = b),
            (this._scope = new r.Scope({ parent: b })),
            (this._nodes = [new g()]);
        }
        toString() {
          return this._root.render(this.opts);
        }
        name(b) {
          return this._scope.name(b);
        }
        scopeName(b) {
          return this._extScope.name(b);
        }
        scopeValue(b, T) {
          const q = this._extScope.value(b, T);
          return (
            (
              this._values[q.prefix] || (this._values[q.prefix] = new Set())
            ).add(q),
            q
          );
        }
        getScopeValue(b, T) {
          return this._extScope.getValue(b, T);
        }
        scopeRefs(b) {
          return this._extScope.scopeRefs(b, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(b, T, q, G) {
          const ee = this._scope.toName(T);
          return (
            q !== void 0 && G && (this._constants[ee.str] = q),
            this._leafNode(new o(b, ee, q)),
            ee
          );
        }
        const(b, T, q) {
          return this._def(r.varKinds.const, b, T, q);
        }
        let(b, T, q) {
          return this._def(r.varKinds.let, b, T, q);
        }
        var(b, T, q) {
          return this._def(r.varKinds.var, b, T, q);
        }
        assign(b, T, q) {
          return this._leafNode(new i(b, T, q));
        }
        add(b, T) {
          return this._leafNode(new l(b, t.operators.ADD, T));
        }
        code(b) {
          return (
            typeof b == "function"
              ? b()
              : b !== e.nil && this._leafNode(new v(b)),
            this
          );
        }
        object(...b) {
          const T = ["{"];
          for (const [q, G] of b)
            T.length > 1 && T.push(","),
              T.push(q),
              (q !== G || this.opts.es5) &&
                (T.push(":"), (0, e.addCodeArg)(T, G));
          return T.push("}"), new e._Code(T);
        }
        if(b, T, q) {
          if ((this._blockNode(new h(b)), T && q))
            this.code(T).else().code(q).endIf();
          else if (T) this.code(T).endIf();
          else if (q)
            throw new Error('CodeGen: "else" body without "then" body');
          return this;
        }
        elseIf(b) {
          return this._elseNode(new h(b));
        }
        else() {
          return this._elseNode(new m());
        }
        endIf() {
          return this._endBlockNode(h, m);
        }
        _for(b, T) {
          return this._blockNode(b), T && this.code(T).endFor(), this;
        }
        for(b, T) {
          return this._for(new _(b), T);
        }
        forRange(
          b,
          T,
          q,
          G,
          ee = this.opts.es5 ? r.varKinds.var : r.varKinds.let
        ) {
          const fe = this._scope.toName(b);
          return this._for(new w(ee, fe, T, q), () => G(fe));
        }
        forOf(b, T, q, G = r.varKinds.const) {
          const ee = this._scope.toName(b);
          if (this.opts.es5) {
            const fe = T instanceof e.Name ? T : this.var("_arr", T);
            return this.forRange("_i", 0, (0, e._)`${fe}.length`, (le) => {
              this.var(ee, (0, e._)`${fe}[${le}]`), q(ee);
            });
          }
          return this._for(new E("of", G, ee, T), () => q(ee));
        }
        forIn(b, T, q, G = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
          if (this.opts.ownProperties)
            return this.forOf(b, (0, e._)`Object.keys(${T})`, q);
          const ee = this._scope.toName(b);
          return this._for(new E("in", G, ee, T), () => q(ee));
        }
        endFor() {
          return this._endBlockNode(y);
        }
        label(b) {
          return this._leafNode(new c(b));
        }
        break(b) {
          return this._leafNode(new u(b));
        }
        return(b) {
          const T = new x();
          if ((this._blockNode(T), this.code(b), T.nodes.length !== 1))
            throw new Error('CodeGen: "return" should have one node');
          return this._endBlockNode(x);
        }
        try(b, T, q) {
          if (!T && !q)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
          const G = new A();
          if ((this._blockNode(G), this.code(b), T)) {
            const ee = this.name("e");
            (this._currNode = G.catch = new M(ee)), T(ee);
          }
          return (
            q && ((this._currNode = G.finally = new H()), this.code(q)),
            this._endBlockNode(M, H)
          );
        }
        throw(b) {
          return this._leafNode(new f(b));
        }
        block(b, T) {
          return (
            this._blockStarts.push(this._nodes.length),
            b && this.code(b).endBlock(T),
            this
          );
        }
        endBlock(b) {
          const T = this._blockStarts.pop();
          if (T === void 0)
            throw new Error("CodeGen: not in self-balancing block");
          const q = this._nodes.length - T;
          if (q < 0 || (b !== void 0 && q !== b))
            throw new Error(
              `CodeGen: wrong number of nodes: ${q} vs ${b} expected`
            );
          return (this._nodes.length = T), this;
        }
        func(b, T = e.nil, q, G) {
          return (
            this._blockNode(new P(b, T, q)), G && this.code(G).endFunc(), this
          );
        }
        endFunc() {
          return this._endBlockNode(P);
        }
        optimize(b = 1) {
          for (; b-- > 0; )
            this._root.optimizeNodes(),
              this._root.optimizeNames(this._root.names, this._constants);
        }
        _leafNode(b) {
          return this._currNode.nodes.push(b), this;
        }
        _blockNode(b) {
          this._currNode.nodes.push(b), this._nodes.push(b);
        }
        _endBlockNode(b, T) {
          const q = this._currNode;
          if (q instanceof b || (T && q instanceof T))
            return this._nodes.pop(), this;
          throw new Error(
            `CodeGen: not in block "${T ? `${b.kind}/${T.kind}` : b.kind}"`
          );
        }
        _elseNode(b) {
          const T = this._currNode;
          if (!(T instanceof h))
            throw new Error('CodeGen: "else" without "if"');
          return (this._currNode = T.else = b), this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          const b = this._nodes;
          return b[b.length - 1];
        }
        set _currNode(b) {
          const T = this._nodes;
          T[T.length - 1] = b;
        }
      }
      t.CodeGen = V;
      function J(R, b) {
        for (const T in b) R[T] = (R[T] || 0) + (b[T] || 0);
        return R;
      }
      function z(R, b) {
        return b instanceof e._CodeOrName ? J(R, b.names) : R;
      }
      function Z(R, b, T) {
        if (R instanceof e.Name) return q(R);
        if (!G(R)) return R;
        return new e._Code(
          R._items.reduce(
            (ee, fe) => (
              fe instanceof e.Name && (fe = q(fe)),
              fe instanceof e._Code ? ee.push(...fe._items) : ee.push(fe),
              ee
            ),
            []
          )
        );
        function q(ee) {
          const fe = T[ee.str];
          return fe === void 0 || b[ee.str] !== 1 ? ee : (delete b[ee.str], fe);
        }
        function G(ee) {
          return (
            ee instanceof e._Code &&
            ee._items.some(
              (fe) =>
                fe instanceof e.Name && b[fe.str] === 1 && T[fe.str] !== void 0
            )
          );
        }
      }
      function te(R, b) {
        for (const T in b) R[T] = (R[T] || 0) - (b[T] || 0);
      }
      function me(R) {
        return typeof R == "boolean" || typeof R == "number" || R === null
          ? !R
          : (0, e._)`!${L(R)}`;
      }
      t.not = me;
      const ge = k(t.operators.AND);
      function N(...R) {
        return R.reduce(ge);
      }
      t.and = N;
      const se = k(t.operators.OR);
      function D(...R) {
        return R.reduce(se);
      }
      t.or = D;
      function k(R) {
        return (b, T) =>
          b === e.nil ? T : T === e.nil ? b : (0, e._)`${L(b)} ${R} ${L(T)}`;
      }
      function L(R) {
        return R instanceof e.Name ? R : (0, e._)`(${R})`;
      }
    })(Ne);
  var oe = {};
  Object.defineProperty(oe, "__esModule", { value: !0 }),
    (oe.checkStrictMode =
      oe.getErrorPath =
      oe.Type =
      oe.useFunc =
      oe.setEvaluated =
      oe.evaluatedPropsToName =
      oe.mergeEvaluated =
      oe.eachItem =
      oe.unescapeJsonPointer =
      oe.escapeJsonPointer =
      oe.escapeFragment =
      oe.unescapeFragment =
      oe.schemaRefOrVal =
      oe.schemaHasRulesButRef =
      oe.schemaHasRules =
      oe.checkUnknownRules =
      oe.alwaysValidSchema =
      oe.toHash =
        void 0);
  const Qe = Ne,
    q0 = Ja;
  function U0(t) {
    const e = {};
    for (const r of t) e[r] = !0;
    return e;
  }
  oe.toHash = U0;
  function F0(t, e) {
    return typeof e == "boolean"
      ? e
      : Object.keys(e).length === 0
      ? !0
      : (pf(t, e), !hf(e, t.self.RULES.all));
  }
  oe.alwaysValidSchema = F0;
  function pf(t, e = t.schema) {
    const { opts: r, self: a } = t;
    if (!r.strictSchema || typeof e == "boolean") return;
    const n = a.RULES.keywords;
    for (const s in e) n[s] || _f(t, `unknown keyword: "${s}"`);
  }
  oe.checkUnknownRules = pf;
  function hf(t, e) {
    if (typeof t == "boolean") return !t;
    for (const r in t) if (e[r]) return !0;
    return !1;
  }
  oe.schemaHasRules = hf;
  function V0(t, e) {
    if (typeof t == "boolean") return !t;
    for (const r in t) if (r !== "$ref" && e.all[r]) return !0;
    return !1;
  }
  oe.schemaHasRulesButRef = V0;
  function Z0({ topSchemaRef: t, schemaPath: e }, r, a, n) {
    if (!n) {
      if (typeof r == "number" || typeof r == "boolean") return r;
      if (typeof r == "string") return (0, Qe._)`${r}`;
    }
    return (0, Qe._)`${t}${e}${(0, Qe.getProperty)(a)}`;
  }
  oe.schemaRefOrVal = Z0;
  function H0(t) {
    return mf(decodeURIComponent(t));
  }
  oe.unescapeFragment = H0;
  function B0(t) {
    return encodeURIComponent(wl(t));
  }
  oe.escapeFragment = B0;
  function wl(t) {
    return typeof t == "number"
      ? `${t}`
      : t.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  oe.escapeJsonPointer = wl;
  function mf(t) {
    return t.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  oe.unescapeJsonPointer = mf;
  function J0(t, e) {
    if (Array.isArray(t)) for (const r of t) e(r);
    else e(t);
  }
  oe.eachItem = J0;
  function vf({
    mergeNames: t,
    mergeToName: e,
    mergeValues: r,
    resultToName: a,
  }) {
    return (n, s, o, i) => {
      const l =
        o === void 0
          ? s
          : o instanceof Qe.Name
          ? (s instanceof Qe.Name ? t(n, s, o) : e(n, s, o), o)
          : s instanceof Qe.Name
          ? (e(n, o, s), s)
          : r(s, o);
      return i === Qe.Name && !(l instanceof Qe.Name) ? a(n, l) : l;
    };
  }
  oe.mergeEvaluated = {
    props: vf({
      mergeNames: (t, e, r) =>
        t.if((0, Qe._)`${r} !== true && ${e} !== undefined`, () => {
          t.if(
            (0, Qe._)`${e} === true`,
            () => t.assign(r, !0),
            () =>
              t
                .assign(r, (0, Qe._)`${r} || {}`)
                .code((0, Qe._)`Object.assign(${r}, ${e})`)
          );
        }),
      mergeToName: (t, e, r) =>
        t.if((0, Qe._)`${r} !== true`, () => {
          e === !0
            ? t.assign(r, !0)
            : (t.assign(r, (0, Qe._)`${r} || {}`), bl(t, r, e));
        }),
      mergeValues: (t, e) => (t === !0 ? !0 : { ...t, ...e }),
      resultToName: gf,
    }),
    items: vf({
      mergeNames: (t, e, r) =>
        t.if((0, Qe._)`${r} !== true && ${e} !== undefined`, () =>
          t.assign(
            r,
            (0, Qe._)`${e} === true ? true : ${r} > ${e} ? ${r} : ${e}`
          )
        ),
      mergeToName: (t, e, r) =>
        t.if((0, Qe._)`${r} !== true`, () =>
          t.assign(r, e === !0 ? !0 : (0, Qe._)`${r} > ${e} ? ${r} : ${e}`)
        ),
      mergeValues: (t, e) => (t === !0 ? !0 : Math.max(t, e)),
      resultToName: (t, e) => t.var("items", e),
    }),
  };
  function gf(t, e) {
    if (e === !0) return t.var("props", !0);
    const r = t.var("props", (0, Qe._)`{}`);
    return e !== void 0 && bl(t, r, e), r;
  }
  oe.evaluatedPropsToName = gf;
  function bl(t, e, r) {
    Object.keys(r).forEach((a) =>
      t.assign((0, Qe._)`${e}${(0, Qe.getProperty)(a)}`, !0)
    );
  }
  oe.setEvaluated = bl;
  const yf = {};
  function K0(t, e) {
    return t.scopeValue("func", {
      ref: e,
      code: yf[e.code] || (yf[e.code] = new q0._Code(e.code)),
    });
  }
  oe.useFunc = K0;
  var El;
  (function (t) {
    (t[(t.Num = 0)] = "Num"), (t[(t.Str = 1)] = "Str");
  })(El || (oe.Type = El = {}));
  function G0(t, e, r) {
    if (t instanceof Qe.Name) {
      const a = e === El.Num;
      return r
        ? a
          ? (0, Qe._)`"[" + ${t} + "]"`
          : (0, Qe._)`"['" + ${t} + "']"`
        : a
        ? (0, Qe._)`"/" + ${t}`
        : (0, Qe._)`"/" + ${t}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return r ? (0, Qe.getProperty)(t).toString() : "/" + wl(t);
  }
  oe.getErrorPath = G0;
  function _f(t, e, r = t.opts.strictSchema) {
    if (r) {
      if (((e = `strict mode: ${e}`), r === !0)) throw new Error(e);
      t.self.logger.warn(e);
    }
  }
  oe.checkStrictMode = _f;
  var Rr = {};
  Object.defineProperty(Rr, "__esModule", { value: !0 });
  const Nt = Ne,
    W0 = {
      data: new Nt.Name("data"),
      valCxt: new Nt.Name("valCxt"),
      instancePath: new Nt.Name("instancePath"),
      parentData: new Nt.Name("parentData"),
      parentDataProperty: new Nt.Name("parentDataProperty"),
      rootData: new Nt.Name("rootData"),
      dynamicAnchors: new Nt.Name("dynamicAnchors"),
      vErrors: new Nt.Name("vErrors"),
      errors: new Nt.Name("errors"),
      this: new Nt.Name("this"),
      self: new Nt.Name("self"),
      scope: new Nt.Name("scope"),
      json: new Nt.Name("json"),
      jsonPos: new Nt.Name("jsonPos"),
      jsonLen: new Nt.Name("jsonLen"),
      jsonPart: new Nt.Name("jsonPart"),
    };
  (Rr.default = W0),
    (function (t) {
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.extendErrors =
          t.resetErrorsCount =
          t.reportExtraError =
          t.reportError =
          t.keyword$DataError =
          t.keywordError =
            void 0);
      const e = Ne,
        r = oe,
        a = Rr;
      (t.keywordError = {
        message: ({ keyword: m }) =>
          (0, e.str)`must pass "${m}" keyword validation`,
      }),
        (t.keyword$DataError = {
          message: ({ keyword: m, schemaType: h }) =>
            h
              ? (0, e.str)`"${m}" keyword must be ${h} ($data)`
              : (0, e.str)`"${m}" keyword is invalid ($data)`,
        });
      function n(m, h = t.keywordError, y, _) {
        const { it: w } = m,
          { gen: E, compositeRule: P, allErrors: x } = w,
          A = f(m, h, y);
        _ ?? (P || x) ? l(E, A) : c(w, (0, e._)`[${A}]`);
      }
      t.reportError = n;
      function s(m, h = t.keywordError, y) {
        const { it: _ } = m,
          { gen: w, compositeRule: E, allErrors: P } = _,
          x = f(m, h, y);
        l(w, x), E || P || c(_, a.default.vErrors);
      }
      t.reportExtraError = s;
      function o(m, h) {
        m.assign(a.default.errors, h),
          m.if((0, e._)`${a.default.vErrors} !== null`, () =>
            m.if(
              h,
              () => m.assign((0, e._)`${a.default.vErrors}.length`, h),
              () => m.assign(a.default.vErrors, null)
            )
          );
      }
      t.resetErrorsCount = o;
      function i({
        gen: m,
        keyword: h,
        schemaValue: y,
        data: _,
        errsCount: w,
        it: E,
      }) {
        if (w === void 0) throw new Error("ajv implementation error");
        const P = m.name("err");
        m.forRange("i", w, a.default.errors, (x) => {
          m.const(P, (0, e._)`${a.default.vErrors}[${x}]`),
            m.if((0, e._)`${P}.instancePath === undefined`, () =>
              m.assign(
                (0, e._)`${P}.instancePath`,
                (0, e.strConcat)(a.default.instancePath, E.errorPath)
              )
            ),
            m.assign(
              (0, e._)`${P}.schemaPath`,
              (0, e.str)`${E.errSchemaPath}/${h}`
            ),
            E.opts.verbose &&
              (m.assign((0, e._)`${P}.schema`, y),
              m.assign((0, e._)`${P}.data`, _));
        });
      }
      t.extendErrors = i;
      function l(m, h) {
        const y = m.const("err", h);
        m.if(
          (0, e._)`${a.default.vErrors} === null`,
          () => m.assign(a.default.vErrors, (0, e._)`[${y}]`),
          (0, e._)`${a.default.vErrors}.push(${y})`
        ),
          m.code((0, e._)`${a.default.errors}++`);
      }
      function c(m, h) {
        const { gen: y, validateName: _, schemaEnv: w } = m;
        w.$async
          ? y.throw((0, e._)`new ${m.ValidationError}(${h})`)
          : (y.assign((0, e._)`${_}.errors`, h), y.return(!1));
      }
      const u = {
        keyword: new e.Name("keyword"),
        schemaPath: new e.Name("schemaPath"),
        params: new e.Name("params"),
        propertyName: new e.Name("propertyName"),
        message: new e.Name("message"),
        schema: new e.Name("schema"),
        parentSchema: new e.Name("parentSchema"),
      };
      function f(m, h, y) {
        const { createErrors: _ } = m.it;
        return _ === !1 ? (0, e._)`{}` : v(m, h, y);
      }
      function v(m, h, y = {}) {
        const { gen: _, it: w } = m,
          E = [d(w, y), p(m, y)];
        return g(m, h, E), _.object(...E);
      }
      function d({ errorPath: m }, { instancePath: h }) {
        const y = h ? (0, e.str)`${m}${(0, r.getErrorPath)(h, r.Type.Str)}` : m;
        return [
          a.default.instancePath,
          (0, e.strConcat)(a.default.instancePath, y),
        ];
      }
      function p(
        { keyword: m, it: { errSchemaPath: h } },
        { schemaPath: y, parentSchema: _ }
      ) {
        let w = _ ? h : (0, e.str)`${h}/${m}`;
        return (
          y && (w = (0, e.str)`${w}${(0, r.getErrorPath)(y, r.Type.Str)}`),
          [u.schemaPath, w]
        );
      }
      function g(m, { params: h, message: y }, _) {
        const { keyword: w, data: E, schemaValue: P, it: x } = m,
          { opts: A, propertyName: M, topSchemaRef: H, schemaPath: V } = x;
        _.push(
          [u.keyword, w],
          [u.params, typeof h == "function" ? h(m) : h || (0, e._)`{}`]
        ),
          A.messages && _.push([u.message, typeof y == "function" ? y(m) : y]),
          A.verbose &&
            _.push(
              [u.schema, P],
              [u.parentSchema, (0, e._)`${H}${V}`],
              [a.default.data, E]
            ),
          M && _.push([u.propertyName, M]);
      }
    })(Ba),
    Object.defineProperty(aa, "__esModule", { value: !0 }),
    (aa.boolOrEmptySchema = aa.topBoolOrEmptySchema = void 0);
  const Q0 = Ba,
    Y0 = Ne,
    X0 = Rr,
    ew = { message: "boolean schema is false" };
  function tw(t) {
    const { gen: e, schema: r, validateName: a } = t;
    r === !1
      ? wf(t, !1)
      : typeof r == "object" && r.$async === !0
      ? e.return(X0.default.data)
      : (e.assign((0, Y0._)`${a}.errors`, null), e.return(!0));
  }
  aa.topBoolOrEmptySchema = tw;
  function rw(t, e) {
    const { gen: r, schema: a } = t;
    a === !1 ? (r.var(e, !1), wf(t)) : r.var(e, !0);
  }
  aa.boolOrEmptySchema = rw;
  function wf(t, e) {
    const { gen: r, data: a } = t,
      n = {
        gen: r,
        keyword: "false schema",
        data: a,
        schema: !1,
        schemaCode: !1,
        schemaValue: !1,
        params: {},
        it: t,
      };
    (0, Q0.reportError)(n, ew, void 0, e);
  }
  var Tt = {},
    Cn = {};
  Object.defineProperty(Cn, "__esModule", { value: !0 }),
    (Cn.getRules = Cn.isJSONType = void 0);
  const nw = [
      "string",
      "number",
      "integer",
      "boolean",
      "null",
      "object",
      "array",
    ],
    aw = new Set(nw);
  function sw(t) {
    return typeof t == "string" && aw.has(t);
  }
  Cn.isJSONType = sw;
  function ow() {
    const t = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] },
    };
    return {
      types: { ...t, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, t.number, t.string, t.array, t.object],
      post: { rules: [] },
      all: {},
      keywords: {},
    };
  }
  Cn.getRules = ow;
  var Qr = {};
  Object.defineProperty(Qr, "__esModule", { value: !0 }),
    (Qr.shouldUseRule = Qr.shouldUseGroup = Qr.schemaHasRulesForType = void 0);
  function iw({ schema: t, self: e }, r) {
    const a = e.RULES.types[r];
    return a && a !== !0 && bf(t, a);
  }
  Qr.schemaHasRulesForType = iw;
  function bf(t, e) {
    return e.rules.some((r) => Ef(t, r));
  }
  Qr.shouldUseGroup = bf;
  function Ef(t, e) {
    var r;
    return (
      t[e.keyword] !== void 0 ||
      ((r = e.definition.implements) === null || r === void 0
        ? void 0
        : r.some((a) => t[a] !== void 0))
    );
  }
  (Qr.shouldUseRule = Ef),
    Object.defineProperty(Tt, "__esModule", { value: !0 }),
    (Tt.reportTypeError =
      Tt.checkDataTypes =
      Tt.checkDataType =
      Tt.coerceAndCheckDataType =
      Tt.getJSONTypes =
      Tt.getSchemaTypes =
      Tt.DataType =
        void 0);
  const lw = Cn,
    cw = Qr,
    uw = Ba,
    Re = Ne,
    Sf = oe;
  var sa;
  (function (t) {
    (t[(t.Correct = 0)] = "Correct"), (t[(t.Wrong = 1)] = "Wrong");
  })(sa || (Tt.DataType = sa = {}));
  function dw(t) {
    const e = $f(t.type);
    if (e.includes("null")) {
      if (t.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!e.length && t.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      t.nullable === !0 && e.push("null");
    }
    return e;
  }
  Tt.getSchemaTypes = dw;
  function $f(t) {
    const e = Array.isArray(t) ? t : t ? [t] : [];
    if (e.every(lw.isJSONType)) return e;
    throw new Error("type must be JSONType or JSONType[]: " + e.join(","));
  }
  Tt.getJSONTypes = $f;
  function fw(t, e) {
    const { gen: r, data: a, opts: n } = t,
      s = pw(e, n.coerceTypes),
      o =
        e.length > 0 &&
        !(
          s.length === 0 &&
          e.length === 1 &&
          (0, cw.schemaHasRulesForType)(t, e[0])
        );
    if (o) {
      const i = $l(e, a, n.strictNumbers, sa.Wrong);
      r.if(i, () => {
        s.length ? hw(t, e, s) : Pl(t);
      });
    }
    return o;
  }
  Tt.coerceAndCheckDataType = fw;
  const Pf = new Set(["string", "number", "integer", "boolean", "null"]);
  function pw(t, e) {
    return e
      ? t.filter((r) => Pf.has(r) || (e === "array" && r === "array"))
      : [];
  }
  function hw(t, e, r) {
    const { gen: a, data: n, opts: s } = t,
      o = a.let("dataType", (0, Re._)`typeof ${n}`),
      i = a.let("coerced", (0, Re._)`undefined`);
    s.coerceTypes === "array" &&
      a.if(
        (0, Re._)`${o} == 'object' && Array.isArray(${n}) && ${n}.length == 1`,
        () =>
          a
            .assign(n, (0, Re._)`${n}[0]`)
            .assign(o, (0, Re._)`typeof ${n}`)
            .if($l(e, n, s.strictNumbers), () => a.assign(i, n))
      ),
      a.if((0, Re._)`${i} !== undefined`);
    for (const c of r)
      (Pf.has(c) || (c === "array" && s.coerceTypes === "array")) && l(c);
    a.else(),
      Pl(t),
      a.endIf(),
      a.if((0, Re._)`${i} !== undefined`, () => {
        a.assign(n, i), mw(t, i);
      });
    function l(c) {
      switch (c) {
        case "string":
          a.elseIf((0, Re._)`${o} == "number" || ${o} == "boolean"`)
            .assign(i, (0, Re._)`"" + ${n}`)
            .elseIf((0, Re._)`${n} === null`)
            .assign(i, (0, Re._)`""`);
          return;
        case "number":
          a.elseIf(
            (0, Re._)`${o} == "boolean" || ${n} === null
              || (${o} == "string" && ${n} && ${n} == +${n})`
          ).assign(i, (0, Re._)`+${n}`);
          return;
        case "integer":
          a.elseIf(
            (0, Re._)`${o} === "boolean" || ${n} === null
              || (${o} === "string" && ${n} && ${n} == +${n} && !(${n} % 1))`
          ).assign(i, (0, Re._)`+${n}`);
          return;
        case "boolean":
          a.elseIf((0, Re._)`${n} === "false" || ${n} === 0 || ${n} === null`)
            .assign(i, !1)
            .elseIf((0, Re._)`${n} === "true" || ${n} === 1`)
            .assign(i, !0);
          return;
        case "null":
          a.elseIf((0, Re._)`${n} === "" || ${n} === 0 || ${n} === false`),
            a.assign(i, null);
          return;
        case "array":
          a.elseIf(
            (0, Re._)`${o} === "string" || ${o} === "number"
              || ${o} === "boolean" || ${n} === null`
          ).assign(i, (0, Re._)`[${n}]`);
      }
    }
  }
  function mw({ gen: t, parentData: e, parentDataProperty: r }, a) {
    t.if((0, Re._)`${e} !== undefined`, () =>
      t.assign((0, Re._)`${e}[${r}]`, a)
    );
  }
  function Sl(t, e, r, a = sa.Correct) {
    const n = a === sa.Correct ? Re.operators.EQ : Re.operators.NEQ;
    let s;
    switch (t) {
      case "null":
        return (0, Re._)`${e} ${n} null`;
      case "array":
        s = (0, Re._)`Array.isArray(${e})`;
        break;
      case "object":
        s = (0, Re._)`${e} && typeof ${e} == "object" && !Array.isArray(${e})`;
        break;
      case "integer":
        s = o((0, Re._)`!(${e} % 1) && !isNaN(${e})`);
        break;
      case "number":
        s = o();
        break;
      default:
        return (0, Re._)`typeof ${e} ${n} ${t}`;
    }
    return a === sa.Correct ? s : (0, Re.not)(s);
    function o(i = Re.nil) {
      return (0,
      Re.and)((0, Re._)`typeof ${e} == "number"`, i, r ? (0, Re._)`isFinite(${e})` : Re.nil);
    }
  }
  Tt.checkDataType = Sl;
  function $l(t, e, r, a) {
    if (t.length === 1) return Sl(t[0], e, r, a);
    let n;
    const s = (0, Sf.toHash)(t);
    if (s.array && s.object) {
      const o = (0, Re._)`typeof ${e} != "object"`;
      (n = s.null ? o : (0, Re._)`!${e} || ${o}`),
        delete s.null,
        delete s.array,
        delete s.object;
    } else n = Re.nil;
    s.number && delete s.integer;
    for (const o in s) n = (0, Re.and)(n, Sl(o, e, r, a));
    return n;
  }
  Tt.checkDataTypes = $l;
  const vw = {
    message: ({ schema: t }) => `must be ${t}`,
    params: ({ schema: t, schemaValue: e }) =>
      typeof t == "string" ? (0, Re._)`{type: ${t}}` : (0, Re._)`{type: ${e}}`,
  };
  function Pl(t) {
    const e = gw(t);
    (0, uw.reportError)(e, vw);
  }
  Tt.reportTypeError = Pl;
  function gw(t) {
    const { gen: e, data: r, schema: a } = t,
      n = (0, Sf.schemaRefOrVal)(t, a, "type");
    return {
      gen: e,
      keyword: "type",
      data: r,
      schema: a.type,
      schemaCode: n,
      schemaValue: n,
      parentSchema: a,
      params: {},
      it: t,
    };
  }
  var _o = {};
  Object.defineProperty(_o, "__esModule", { value: !0 }),
    (_o.assignDefaults = void 0);
  const oa = Ne,
    yw = oe;
  function _w(t, e) {
    const { properties: r, items: a } = t.schema;
    if (e === "object" && r) for (const n in r) Tf(t, n, r[n].default);
    else
      e === "array" &&
        Array.isArray(a) &&
        a.forEach((n, s) => Tf(t, s, n.default));
  }
  _o.assignDefaults = _w;
  function Tf(t, e, r) {
    const { gen: a, compositeRule: n, data: s, opts: o } = t;
    if (r === void 0) return;
    const i = (0, oa._)`${s}${(0, oa.getProperty)(e)}`;
    if (n) {
      (0, yw.checkStrictMode)(t, `default is ignored for: ${i}`);
      return;
    }
    let l = (0, oa._)`${i} === undefined`;
    o.useDefaults === "empty" &&
      (l = (0, oa._)`${l} || ${i} === null || ${i} === ""`),
      a.if(l, (0, oa._)`${i} = ${(0, oa.stringify)(r)}`);
  }
  var Or = {},
    Me = {};
  Object.defineProperty(Me, "__esModule", { value: !0 }),
    (Me.validateUnion =
      Me.validateArray =
      Me.usePattern =
      Me.callValidateCode =
      Me.schemaProperties =
      Me.allSchemaProperties =
      Me.noPropertyInData =
      Me.propertyInData =
      Me.isOwnProperty =
      Me.hasPropFunc =
      Me.reportMissingProp =
      Me.checkMissingProp =
      Me.checkReportMissingProp =
        void 0);
  const at = Ne,
    Tl = oe,
    cn = Rr,
    ww = oe;
  function bw(t, e) {
    const { gen: r, data: a, it: n } = t;
    r.if(Il(r, a, e, n.opts.ownProperties), () => {
      t.setParams({ missingProperty: (0, at._)`${e}` }, !0), t.error();
    });
  }
  Me.checkReportMissingProp = bw;
  function Ew({ gen: t, data: e, it: { opts: r } }, a, n) {
    return (0,
    at.or)(...a.map((s) => (0, at.and)(Il(t, e, s, r.ownProperties), (0, at._)`${n} = ${s}`)));
  }
  Me.checkMissingProp = Ew;
  function Sw(t, e) {
    t.setParams({ missingProperty: e }, !0), t.error();
  }
  Me.reportMissingProp = Sw;
  function xf(t) {
    return t.scopeValue("func", {
      ref: Object.prototype.hasOwnProperty,
      code: (0, at._)`Object.prototype.hasOwnProperty`,
    });
  }
  Me.hasPropFunc = xf;
  function xl(t, e, r) {
    return (0, at._)`${xf(t)}.call(${e}, ${r})`;
  }
  Me.isOwnProperty = xl;
  function $w(t, e, r, a) {
    const n = (0, at._)`${e}${(0, at.getProperty)(r)} !== undefined`;
    return a ? (0, at._)`${n} && ${xl(t, e, r)}` : n;
  }
  Me.propertyInData = $w;
  function Il(t, e, r, a) {
    const n = (0, at._)`${e}${(0, at.getProperty)(r)} === undefined`;
    return a ? (0, at.or)(n, (0, at.not)(xl(t, e, r))) : n;
  }
  Me.noPropertyInData = Il;
  function If(t) {
    return t ? Object.keys(t).filter((e) => e !== "__proto__") : [];
  }
  Me.allSchemaProperties = If;
  function Pw(t, e) {
    return If(e).filter((r) => !(0, Tl.alwaysValidSchema)(t, e[r]));
  }
  Me.schemaProperties = Pw;
  function Tw(
    {
      schemaCode: t,
      data: e,
      it: { gen: r, topSchemaRef: a, schemaPath: n, errorPath: s },
      it: o,
    },
    i,
    l,
    c
  ) {
    const u = c ? (0, at._)`${t}, ${e}, ${a}${n}` : e,
      f = [
        [
          cn.default.instancePath,
          (0, at.strConcat)(cn.default.instancePath, s),
        ],
        [cn.default.parentData, o.parentData],
        [cn.default.parentDataProperty, o.parentDataProperty],
        [cn.default.rootData, cn.default.rootData],
      ];
    o.opts.dynamicRef &&
      f.push([cn.default.dynamicAnchors, cn.default.dynamicAnchors]);
    const v = (0, at._)`${u}, ${r.object(...f)}`;
    return l !== at.nil
      ? (0, at._)`${i}.call(${l}, ${v})`
      : (0, at._)`${i}(${v})`;
  }
  Me.callValidateCode = Tw;
  const xw = (0, at._)`new RegExp`;
  function Iw({ gen: t, it: { opts: e } }, r) {
    const a = e.unicodeRegExp ? "u" : "",
      { regExp: n } = e.code,
      s = n(r, a);
    return t.scopeValue("pattern", {
      key: s.toString(),
      ref: s,
      code: (0, at._)`${
        n.code === "new RegExp" ? xw : (0, ww.useFunc)(t, n)
      }(${r}, ${a})`,
    });
  }
  Me.usePattern = Iw;
  function kw(t) {
    const { gen: e, data: r, keyword: a, it: n } = t,
      s = e.name("valid");
    if (n.allErrors) {
      const i = e.let("valid", !0);
      return o(() => e.assign(i, !1)), i;
    }
    return e.var(s, !0), o(() => e.break()), s;
    function o(i) {
      const l = e.const("len", (0, at._)`${r}.length`);
      e.forRange("i", 0, l, (c) => {
        t.subschema({ keyword: a, dataProp: c, dataPropType: Tl.Type.Num }, s),
          e.if((0, at.not)(s), i);
      });
    }
  }
  Me.validateArray = kw;
  function Cw(t) {
    const { gen: e, schema: r, keyword: a, it: n } = t;
    if (!Array.isArray(r)) throw new Error("ajv implementation error");
    if (r.some((l) => (0, Tl.alwaysValidSchema)(n, l)) && !n.opts.unevaluated)
      return;
    const o = e.let("valid", !1),
      i = e.name("_valid");
    e.block(() =>
      r.forEach((l, c) => {
        const u = t.subschema(
          { keyword: a, schemaProp: c, compositeRule: !0 },
          i
        );
        e.assign(o, (0, at._)`${o} || ${i}`),
          t.mergeValidEvaluated(u, i) || e.if((0, at.not)(o));
      })
    ),
      t.result(
        o,
        () => t.reset(),
        () => t.error(!0)
      );
  }
  (Me.validateUnion = Cw),
    Object.defineProperty(Or, "__esModule", { value: !0 }),
    (Or.validateKeywordUsage =
      Or.validSchemaType =
      Or.funcKeywordCode =
      Or.macroKeywordCode =
        void 0);
  const zt = Ne,
    Rn = Rr,
    Rw = Me,
    Ow = Ba;
  function Aw(t, e) {
    const { gen: r, keyword: a, schema: n, parentSchema: s, it: o } = t,
      i = e.macro.call(o.self, n, s, o),
      l = Cf(r, a, i);
    o.opts.validateSchema !== !1 && o.self.validateSchema(i, !0);
    const c = r.name("valid");
    t.subschema(
      {
        schema: i,
        schemaPath: zt.nil,
        errSchemaPath: `${o.errSchemaPath}/${a}`,
        topSchemaRef: l,
        compositeRule: !0,
      },
      c
    ),
      t.pass(c, () => t.error(!0));
  }
  Or.macroKeywordCode = Aw;
  function Nw(t, e) {
    var r;
    const {
      gen: a,
      keyword: n,
      schema: s,
      parentSchema: o,
      $data: i,
      it: l,
    } = t;
    jw(l, e);
    const c = !i && e.compile ? e.compile.call(l.self, s, o, l) : e.validate,
      u = Cf(a, n, c),
      f = a.let("valid");
    t.block$data(f, v), t.ok((r = e.valid) !== null && r !== void 0 ? r : f);
    function v() {
      if (e.errors === !1) g(), e.modifying && kf(t), m(() => t.error());
      else {
        const h = e.async ? d() : p();
        e.modifying && kf(t), m(() => Mw(t, h));
      }
    }
    function d() {
      const h = a.let("ruleErrs", null);
      return (
        a.try(
          () => g((0, zt._)`await `),
          (y) =>
            a.assign(f, !1).if(
              (0, zt._)`${y} instanceof ${l.ValidationError}`,
              () => a.assign(h, (0, zt._)`${y}.errors`),
              () => a.throw(y)
            )
        ),
        h
      );
    }
    function p() {
      const h = (0, zt._)`${u}.errors`;
      return a.assign(h, null), g(zt.nil), h;
    }
    function g(h = e.async ? (0, zt._)`await ` : zt.nil) {
      const y = l.opts.passContext ? Rn.default.this : Rn.default.self,
        _ = !(("compile" in e && !i) || e.schema === !1);
      a.assign(
        f,
        (0, zt._)`${h}${(0, Rw.callValidateCode)(t, u, y, _)}`,
        e.modifying
      );
    }
    function m(h) {
      var y;
      a.if((0, zt.not)((y = e.valid) !== null && y !== void 0 ? y : f), h);
    }
  }
  Or.funcKeywordCode = Nw;
  function kf(t) {
    const { gen: e, data: r, it: a } = t;
    e.if(a.parentData, () =>
      e.assign(r, (0, zt._)`${a.parentData}[${a.parentDataProperty}]`)
    );
  }
  function Mw(t, e) {
    const { gen: r } = t;
    r.if(
      (0, zt._)`Array.isArray(${e})`,
      () => {
        r
          .assign(
            Rn.default.vErrors,
            (0,
            zt._)`${Rn.default.vErrors} === null ? ${e} : ${Rn.default.vErrors}.concat(${e})`
          )
          .assign(Rn.default.errors, (0, zt._)`${Rn.default.vErrors}.length`),
          (0, Ow.extendErrors)(t);
      },
      () => t.error()
    );
  }
  function jw({ schemaEnv: t }, e) {
    if (e.async && !t.$async) throw new Error("async keyword in sync schema");
  }
  function Cf(t, e, r) {
    if (r === void 0) throw new Error(`keyword "${e}" failed to compile`);
    return t.scopeValue(
      "keyword",
      typeof r == "function"
        ? { ref: r }
        : { ref: r, code: (0, zt.stringify)(r) }
    );
  }
  function Dw(t, e, r = !1) {
    return (
      !e.length ||
      e.some((a) =>
        a === "array"
          ? Array.isArray(t)
          : a === "object"
          ? t && typeof t == "object" && !Array.isArray(t)
          : typeof t == a || (r && typeof t > "u")
      )
    );
  }
  Or.validSchemaType = Dw;
  function Lw({ schema: t, opts: e, self: r, errSchemaPath: a }, n, s) {
    if (Array.isArray(n.keyword) ? !n.keyword.includes(s) : n.keyword !== s)
      throw new Error("ajv implementation error");
    const o = n.dependencies;
    if (o != null && o.some((i) => !Object.prototype.hasOwnProperty.call(t, i)))
      throw new Error(
        `parent schema must have dependencies of ${s}: ${o.join(",")}`
      );
    if (n.validateSchema && !n.validateSchema(t[s])) {
      const l =
        `keyword "${s}" value is invalid at path "${a}": ` +
        r.errorsText(n.validateSchema.errors);
      if (e.validateSchema === "log") r.logger.error(l);
      else throw new Error(l);
    }
  }
  Or.validateKeywordUsage = Lw;
  var un = {};
  Object.defineProperty(un, "__esModule", { value: !0 }),
    (un.extendSubschemaMode =
      un.extendSubschemaData =
      un.getSubschema =
        void 0);
  const Ar = Ne,
    Rf = oe;
  function zw(
    t,
    {
      keyword: e,
      schemaProp: r,
      schema: a,
      schemaPath: n,
      errSchemaPath: s,
      topSchemaRef: o,
    }
  ) {
    if (e !== void 0 && a !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (e !== void 0) {
      const i = t.schema[e];
      return r === void 0
        ? {
            schema: i,
            schemaPath: (0, Ar._)`${t.schemaPath}${(0, Ar.getProperty)(e)}`,
            errSchemaPath: `${t.errSchemaPath}/${e}`,
          }
        : {
            schema: i[r],
            schemaPath: (0, Ar._)`${t.schemaPath}${(0, Ar.getProperty)(e)}${(0,
            Ar.getProperty)(r)}`,
            errSchemaPath: `${t.errSchemaPath}/${e}/${(0, Rf.escapeFragment)(
              r
            )}`,
          };
    }
    if (a !== void 0) {
      if (n === void 0 || s === void 0 || o === void 0)
        throw new Error(
          '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"'
        );
      return { schema: a, schemaPath: n, topSchemaRef: o, errSchemaPath: s };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  un.getSubschema = zw;
  function qw(
    t,
    e,
    { dataProp: r, dataPropType: a, data: n, dataTypes: s, propertyName: o }
  ) {
    if (n !== void 0 && r !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: i } = e;
    if (r !== void 0) {
      const { errorPath: c, dataPathArr: u, opts: f } = e,
        v = i.let("data", (0, Ar._)`${e.data}${(0, Ar.getProperty)(r)}`, !0);
      l(v),
        (t.errorPath = (0, Ar.str)`${c}${(0, Rf.getErrorPath)(
          r,
          a,
          f.jsPropertySyntax
        )}`),
        (t.parentDataProperty = (0, Ar._)`${r}`),
        (t.dataPathArr = [...u, t.parentDataProperty]);
    }
    if (n !== void 0) {
      const c = n instanceof Ar.Name ? n : i.let("data", n, !0);
      l(c), o !== void 0 && (t.propertyName = o);
    }
    s && (t.dataTypes = s);
    function l(c) {
      (t.data = c),
        (t.dataLevel = e.dataLevel + 1),
        (t.dataTypes = []),
        (e.definedProperties = new Set()),
        (t.parentData = e.data),
        (t.dataNames = [...e.dataNames, c]);
    }
  }
  un.extendSubschemaData = qw;
  function Uw(
    t,
    {
      jtdDiscriminator: e,
      jtdMetadata: r,
      compositeRule: a,
      createErrors: n,
      allErrors: s,
    }
  ) {
    a !== void 0 && (t.compositeRule = a),
      n !== void 0 && (t.createErrors = n),
      s !== void 0 && (t.allErrors = s),
      (t.jtdDiscriminator = e),
      (t.jtdMetadata = r);
  }
  un.extendSubschemaMode = Uw;
  var Rt = {},
    Ka = function t(e, r) {
      if (e === r) return !0;
      if (e && r && typeof e == "object" && typeof r == "object") {
        if (e.constructor !== r.constructor) return !1;
        var a, n, s;
        if (Array.isArray(e)) {
          if (((a = e.length), a != r.length)) return !1;
          for (n = a; n-- !== 0; ) if (!t(e[n], r[n])) return !1;
          return !0;
        }
        if (e.constructor === RegExp)
          return e.source === r.source && e.flags === r.flags;
        if (e.valueOf !== Object.prototype.valueOf)
          return e.valueOf() === r.valueOf();
        if (e.toString !== Object.prototype.toString)
          return e.toString() === r.toString();
        if (((s = Object.keys(e)), (a = s.length), a !== Object.keys(r).length))
          return !1;
        for (n = a; n-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(r, s[n])) return !1;
        for (n = a; n-- !== 0; ) {
          var o = s[n];
          if (!t(e[o], r[o])) return !1;
        }
        return !0;
      }
      return e !== e && r !== r;
    },
    Of = { exports: {} },
    dn = (Of.exports = function (t, e, r) {
      typeof e == "function" && ((r = e), (e = {})), (r = e.cb || r);
      var a = typeof r == "function" ? r : r.pre || function () {},
        n = r.post || function () {};
      wo(e, a, n, t, "", t);
    });
  (dn.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0,
  }),
    (dn.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 }),
    (dn.propsKeywords = {
      $defs: !0,
      definitions: !0,
      properties: !0,
      patternProperties: !0,
      dependencies: !0,
    }),
    (dn.skipKeywords = {
      default: !0,
      enum: !0,
      const: !0,
      required: !0,
      maximum: !0,
      minimum: !0,
      exclusiveMaximum: !0,
      exclusiveMinimum: !0,
      multipleOf: !0,
      maxLength: !0,
      minLength: !0,
      pattern: !0,
      format: !0,
      maxItems: !0,
      minItems: !0,
      uniqueItems: !0,
      maxProperties: !0,
      minProperties: !0,
    });
  function wo(t, e, r, a, n, s, o, i, l, c) {
    if (a && typeof a == "object" && !Array.isArray(a)) {
      e(a, n, s, o, i, l, c);
      for (var u in a) {
        var f = a[u];
        if (Array.isArray(f)) {
          if (u in dn.arrayKeywords)
            for (var v = 0; v < f.length; v++)
              wo(t, e, r, f[v], n + "/" + u + "/" + v, s, n, u, a, v);
        } else if (u in dn.propsKeywords) {
          if (f && typeof f == "object")
            for (var d in f)
              wo(t, e, r, f[d], n + "/" + u + "/" + Fw(d), s, n, u, a, d);
        } else
          (u in dn.keywords || (t.allKeys && !(u in dn.skipKeywords))) &&
            wo(t, e, r, f, n + "/" + u, s, n, u, a);
      }
      r(a, n, s, o, i, l, c);
    }
  }
  function Fw(t) {
    return t.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  var Vw = Of.exports;
  Object.defineProperty(Rt, "__esModule", { value: !0 }),
    (Rt.getSchemaRefs =
      Rt.resolveUrl =
      Rt.normalizeId =
      Rt._getFullPath =
      Rt.getFullPath =
      Rt.inlineRef =
        void 0);
  const Zw = oe,
    Hw = Ka,
    Bw = Vw,
    Jw = new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const",
    ]);
  function Kw(t, e = !0) {
    return typeof t == "boolean" ? !0 : e === !0 ? !kl(t) : e ? Af(t) <= e : !1;
  }
  Rt.inlineRef = Kw;
  const Gw = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor",
  ]);
  function kl(t) {
    for (const e in t) {
      if (Gw.has(e)) return !0;
      const r = t[e];
      if ((Array.isArray(r) && r.some(kl)) || (typeof r == "object" && kl(r)))
        return !0;
    }
    return !1;
  }
  function Af(t) {
    let e = 0;
    for (const r in t) {
      if (r === "$ref") return 1 / 0;
      if (
        (e++,
        !Jw.has(r) &&
          (typeof t[r] == "object" &&
            (0, Zw.eachItem)(t[r], (a) => (e += Af(a))),
          e === 1 / 0))
      )
        return 1 / 0;
    }
    return e;
  }
  function Nf(t, e = "", r) {
    r !== !1 && (e = ia(e));
    const a = t.parse(e);
    return Mf(t, a);
  }
  Rt.getFullPath = Nf;
  function Mf(t, e) {
    return t.serialize(e).split("#")[0] + "#";
  }
  Rt._getFullPath = Mf;
  const Ww = /#\/?$/;
  function ia(t) {
    return t ? t.replace(Ww, "") : "";
  }
  Rt.normalizeId = ia;
  function Qw(t, e, r) {
    return (r = ia(r)), t.resolve(e, r);
  }
  Rt.resolveUrl = Qw;
  const Yw = /^[a-z_][-a-z0-9._]*$/i;
  function Xw(t, e) {
    if (typeof t == "boolean") return {};
    const { schemaId: r, uriResolver: a } = this.opts,
      n = ia(t[r] || e),
      s = { "": n },
      o = Nf(a, n, !1),
      i = {},
      l = new Set();
    return (
      Bw(t, { allKeys: !0 }, (f, v, d, p) => {
        if (p === void 0) return;
        const g = o + v;
        let m = s[p];
        typeof f[r] == "string" && (m = h.call(this, f[r])),
          y.call(this, f.$anchor),
          y.call(this, f.$dynamicAnchor),
          (s[v] = m);
        function h(_) {
          const w = this.opts.uriResolver.resolve;
          if (((_ = ia(m ? w(m, _) : _)), l.has(_))) throw u(_);
          l.add(_);
          let E = this.refs[_];
          return (
            typeof E == "string" && (E = this.refs[E]),
            typeof E == "object"
              ? c(f, E.schema, _)
              : _ !== ia(g) &&
                (_[0] === "#"
                  ? (c(f, i[_], _), (i[_] = f))
                  : (this.refs[_] = g)),
            _
          );
        }
        function y(_) {
          if (typeof _ == "string") {
            if (!Yw.test(_)) throw new Error(`invalid anchor "${_}"`);
            h.call(this, `#${_}`);
          }
        }
      }),
      i
    );
    function c(f, v, d) {
      if (v !== void 0 && !Hw(f, v)) throw u(d);
    }
    function u(f) {
      return new Error(`reference "${f}" resolves to more than one schema`);
    }
  }
  (Rt.getSchemaRefs = Xw),
    Object.defineProperty(gr, "__esModule", { value: !0 }),
    (gr.getData = gr.KeywordCxt = gr.validateFunctionCode = void 0);
  const jf = aa,
    Df = Tt,
    Cl = Qr,
    bo = Tt,
    eb = _o,
    Ga = Or,
    Rl = un,
    he = Ne,
    $e = Rr,
    tb = Rt,
    Yr = oe,
    Wa = Ba;
  function rb(t) {
    if (Uf(t) && (Ff(t), qf(t))) {
      sb(t);
      return;
    }
    Lf(t, () => (0, jf.topBoolOrEmptySchema)(t));
  }
  gr.validateFunctionCode = rb;
  function Lf(
    { gen: t, validateName: e, schema: r, schemaEnv: a, opts: n },
    s
  ) {
    n.code.es5
      ? t.func(
          e,
          (0, he._)`${$e.default.data}, ${$e.default.valCxt}`,
          a.$async,
          () => {
            t.code((0, he._)`"use strict"; ${zf(r, n)}`), ab(t, n), t.code(s);
          }
        )
      : t.func(e, (0, he._)`${$e.default.data}, ${nb(n)}`, a.$async, () =>
          t.code(zf(r, n)).code(s)
        );
  }
  function nb(t) {
    return (0,
    he._)`{${$e.default.instancePath}="", ${$e.default.parentData}, ${$e.default.parentDataProperty}, ${$e.default.rootData}=${$e.default.data}${t.dynamicRef ? (0, he._)`, ${$e.default.dynamicAnchors}={}` : he.nil}}={}`;
  }
  function ab(t, e) {
    t.if(
      $e.default.valCxt,
      () => {
        t.var(
          $e.default.instancePath,
          (0, he._)`${$e.default.valCxt}.${$e.default.instancePath}`
        ),
          t.var(
            $e.default.parentData,
            (0, he._)`${$e.default.valCxt}.${$e.default.parentData}`
          ),
          t.var(
            $e.default.parentDataProperty,
            (0, he._)`${$e.default.valCxt}.${$e.default.parentDataProperty}`
          ),
          t.var(
            $e.default.rootData,
            (0, he._)`${$e.default.valCxt}.${$e.default.rootData}`
          ),
          e.dynamicRef &&
            t.var(
              $e.default.dynamicAnchors,
              (0, he._)`${$e.default.valCxt}.${$e.default.dynamicAnchors}`
            );
      },
      () => {
        t.var($e.default.instancePath, (0, he._)`""`),
          t.var($e.default.parentData, (0, he._)`undefined`),
          t.var($e.default.parentDataProperty, (0, he._)`undefined`),
          t.var($e.default.rootData, $e.default.data),
          e.dynamicRef && t.var($e.default.dynamicAnchors, (0, he._)`{}`);
      }
    );
  }
  function sb(t) {
    const { schema: e, opts: r, gen: a } = t;
    Lf(t, () => {
      r.$comment && e.$comment && Zf(t),
        ub(t),
        a.let($e.default.vErrors, null),
        a.let($e.default.errors, 0),
        r.unevaluated && ob(t),
        Vf(t),
        pb(t);
    });
  }
  function ob(t) {
    const { gen: e, validateName: r } = t;
    (t.evaluated = e.const("evaluated", (0, he._)`${r}.evaluated`)),
      e.if((0, he._)`${t.evaluated}.dynamicProps`, () =>
        e.assign((0, he._)`${t.evaluated}.props`, (0, he._)`undefined`)
      ),
      e.if((0, he._)`${t.evaluated}.dynamicItems`, () =>
        e.assign((0, he._)`${t.evaluated}.items`, (0, he._)`undefined`)
      );
  }
  function zf(t, e) {
    const r = typeof t == "object" && t[e.schemaId];
    return r && (e.code.source || e.code.process)
      ? (0, he._)`/*# sourceURL=${r} */`
      : he.nil;
  }
  function ib(t, e) {
    if (Uf(t) && (Ff(t), qf(t))) {
      lb(t, e);
      return;
    }
    (0, jf.boolOrEmptySchema)(t, e);
  }
  function qf({ schema: t, self: e }) {
    if (typeof t == "boolean") return !t;
    for (const r in t) if (e.RULES.all[r]) return !0;
    return !1;
  }
  function Uf(t) {
    return typeof t.schema != "boolean";
  }
  function lb(t, e) {
    const { schema: r, gen: a, opts: n } = t;
    n.$comment && r.$comment && Zf(t), db(t), fb(t);
    const s = a.const("_errs", $e.default.errors);
    Vf(t, s), a.var(e, (0, he._)`${s} === ${$e.default.errors}`);
  }
  function Ff(t) {
    (0, Yr.checkUnknownRules)(t), cb(t);
  }
  function Vf(t, e) {
    if (t.opts.jtd) return Hf(t, [], !1, e);
    const r = (0, Df.getSchemaTypes)(t.schema),
      a = (0, Df.coerceAndCheckDataType)(t, r);
    Hf(t, r, !a, e);
  }
  function cb(t) {
    const { schema: e, errSchemaPath: r, opts: a, self: n } = t;
    e.$ref &&
      a.ignoreKeywordsWithRef &&
      (0, Yr.schemaHasRulesButRef)(e, n.RULES) &&
      n.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
  }
  function ub(t) {
    const { schema: e, opts: r } = t;
    e.default !== void 0 &&
      r.useDefaults &&
      r.strictSchema &&
      (0, Yr.checkStrictMode)(t, "default is ignored in the schema root");
  }
  function db(t) {
    const e = t.schema[t.opts.schemaId];
    e && (t.baseId = (0, tb.resolveUrl)(t.opts.uriResolver, t.baseId, e));
  }
  function fb(t) {
    if (t.schema.$async && !t.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function Zf({ gen: t, schemaEnv: e, schema: r, errSchemaPath: a, opts: n }) {
    const s = r.$comment;
    if (n.$comment === !0)
      t.code((0, he._)`${$e.default.self}.logger.log(${s})`);
    else if (typeof n.$comment == "function") {
      const o = (0, he.str)`${a}/$comment`,
        i = t.scopeValue("root", { ref: e.root });
      t.code(
        (0, he._)`${$e.default.self}.opts.$comment(${s}, ${o}, ${i}.schema)`
      );
    }
  }
  function pb(t) {
    const {
      gen: e,
      schemaEnv: r,
      validateName: a,
      ValidationError: n,
      opts: s,
    } = t;
    r.$async
      ? e.if(
          (0, he._)`${$e.default.errors} === 0`,
          () => e.return($e.default.data),
          () => e.throw((0, he._)`new ${n}(${$e.default.vErrors})`)
        )
      : (e.assign((0, he._)`${a}.errors`, $e.default.vErrors),
        s.unevaluated && hb(t),
        e.return((0, he._)`${$e.default.errors} === 0`));
  }
  function hb({ gen: t, evaluated: e, props: r, items: a }) {
    r instanceof he.Name && t.assign((0, he._)`${e}.props`, r),
      a instanceof he.Name && t.assign((0, he._)`${e}.items`, a);
  }
  function Hf(t, e, r, a) {
    const { gen: n, schema: s, data: o, allErrors: i, opts: l, self: c } = t,
      { RULES: u } = c;
    if (
      s.$ref &&
      (l.ignoreKeywordsWithRef || !(0, Yr.schemaHasRulesButRef)(s, u))
    ) {
      n.block(() => Gf(t, "$ref", u.all.$ref.definition));
      return;
    }
    l.jtd || mb(t, e),
      n.block(() => {
        for (const v of u.rules) f(v);
        f(u.post);
      });
    function f(v) {
      (0, Cl.shouldUseGroup)(s, v) &&
        (v.type
          ? (n.if((0, bo.checkDataType)(v.type, o, l.strictNumbers)),
            Bf(t, v),
            e.length === 1 &&
              e[0] === v.type &&
              r &&
              (n.else(), (0, bo.reportTypeError)(t)),
            n.endIf())
          : Bf(t, v),
        i || n.if((0, he._)`${$e.default.errors} === ${a || 0}`));
    }
  }
  function Bf(t, e) {
    const {
      gen: r,
      schema: a,
      opts: { useDefaults: n },
    } = t;
    n && (0, eb.assignDefaults)(t, e.type),
      r.block(() => {
        for (const s of e.rules)
          (0, Cl.shouldUseRule)(a, s) && Gf(t, s.keyword, s.definition, e.type);
      });
  }
  function mb(t, e) {
    t.schemaEnv.meta ||
      !t.opts.strictTypes ||
      (vb(t, e), t.opts.allowUnionTypes || gb(t, e), yb(t, t.dataTypes));
  }
  function vb(t, e) {
    if (e.length) {
      if (!t.dataTypes.length) {
        t.dataTypes = e;
        return;
      }
      e.forEach((r) => {
        Jf(t.dataTypes, r) ||
          Ol(
            t,
            `type "${r}" not allowed by context "${t.dataTypes.join(",")}"`
          );
      }),
        wb(t, e);
    }
  }
  function gb(t, e) {
    e.length > 1 &&
      !(e.length === 2 && e.includes("null")) &&
      Ol(t, "use allowUnionTypes to allow union type keyword");
  }
  function yb(t, e) {
    const r = t.self.RULES.all;
    for (const a in r) {
      const n = r[a];
      if (typeof n == "object" && (0, Cl.shouldUseRule)(t.schema, n)) {
        const { type: s } = n.definition;
        s.length &&
          !s.some((o) => _b(e, o)) &&
          Ol(t, `missing type "${s.join(",")}" for keyword "${a}"`);
      }
    }
  }
  function _b(t, e) {
    return t.includes(e) || (e === "number" && t.includes("integer"));
  }
  function Jf(t, e) {
    return t.includes(e) || (e === "integer" && t.includes("number"));
  }
  function wb(t, e) {
    const r = [];
    for (const a of t.dataTypes)
      Jf(e, a)
        ? r.push(a)
        : e.includes("integer") && a === "number" && r.push("integer");
    t.dataTypes = r;
  }
  function Ol(t, e) {
    const r = t.schemaEnv.baseId + t.errSchemaPath;
    (e += ` at "${r}" (strictTypes)`),
      (0, Yr.checkStrictMode)(t, e, t.opts.strictTypes);
  }
  class Kf {
    constructor(e, r, a) {
      if (
        ((0, Ga.validateKeywordUsage)(e, r, a),
        (this.gen = e.gen),
        (this.allErrors = e.allErrors),
        (this.keyword = a),
        (this.data = e.data),
        (this.schema = e.schema[a]),
        (this.$data =
          r.$data && e.opts.$data && this.schema && this.schema.$data),
        (this.schemaValue = (0, Yr.schemaRefOrVal)(
          e,
          this.schema,
          a,
          this.$data
        )),
        (this.schemaType = r.schemaType),
        (this.parentSchema = e.schema),
        (this.params = {}),
        (this.it = e),
        (this.def = r),
        this.$data)
      )
        this.schemaCode = e.gen.const("vSchema", Wf(this.$data, e));
      else if (
        ((this.schemaCode = this.schemaValue),
        !(0, Ga.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      )
        throw new Error(`${a} value must be ${JSON.stringify(r.schemaType)}`);
      ("code" in r ? r.trackErrors : r.errors !== !1) &&
        (this.errsCount = e.gen.const("_errs", $e.default.errors));
    }
    result(e, r, a) {
      this.failResult((0, he.not)(e), r, a);
    }
    failResult(e, r, a) {
      this.gen.if(e),
        a ? a() : this.error(),
        r
          ? (this.gen.else(), r(), this.allErrors && this.gen.endIf())
          : this.allErrors
          ? this.gen.endIf()
          : this.gen.else();
    }
    pass(e, r) {
      this.failResult((0, he.not)(e), void 0, r);
    }
    fail(e) {
      if (e === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(e),
        this.error(),
        this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(e) {
      if (!this.$data) return this.fail(e);
      const { schemaCode: r } = this;
      this.fail(
        (0, he._)`${r} !== undefined && (${(0, he.or)(this.invalid$data(), e)})`
      );
    }
    error(e, r, a) {
      if (r) {
        this.setParams(r), this._error(e, a), this.setParams({});
        return;
      }
      this._error(e, a);
    }
    _error(e, r) {
      (e ? Wa.reportExtraError : Wa.reportError)(this, this.def.error, r);
    }
    $dataError() {
      (0, Wa.reportError)(this, this.def.$dataError || Wa.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, Wa.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(e) {
      this.allErrors || this.gen.if(e);
    }
    setParams(e, r) {
      r ? Object.assign(this.params, e) : (this.params = e);
    }
    block$data(e, r, a = he.nil) {
      this.gen.block(() => {
        this.check$data(e, a), r();
      });
    }
    check$data(e = he.nil, r = he.nil) {
      if (!this.$data) return;
      const { gen: a, schemaCode: n, schemaType: s, def: o } = this;
      a.if((0, he.or)((0, he._)`${n} === undefined`, r)),
        e !== he.nil && a.assign(e, !0),
        (s.length || o.validateSchema) &&
          (a.elseIf(this.invalid$data()),
          this.$dataError(),
          e !== he.nil && a.assign(e, !1)),
        a.else();
    }
    invalid$data() {
      const { gen: e, schemaCode: r, schemaType: a, def: n, it: s } = this;
      return (0, he.or)(o(), i());
      function o() {
        if (a.length) {
          if (!(r instanceof he.Name))
            throw new Error("ajv implementation error");
          const l = Array.isArray(a) ? a : [a];
          return (0, he._)`${(0, bo.checkDataTypes)(
            l,
            r,
            s.opts.strictNumbers,
            bo.DataType.Wrong
          )}`;
        }
        return he.nil;
      }
      function i() {
        if (n.validateSchema) {
          const l = e.scopeValue("validate$data", { ref: n.validateSchema });
          return (0, he._)`!${l}(${r})`;
        }
        return he.nil;
      }
    }
    subschema(e, r) {
      const a = (0, Rl.getSubschema)(this.it, e);
      (0, Rl.extendSubschemaData)(a, this.it, e),
        (0, Rl.extendSubschemaMode)(a, e);
      const n = { ...this.it, ...a, items: void 0, props: void 0 };
      return ib(n, r), n;
    }
    mergeEvaluated(e, r) {
      const { it: a, gen: n } = this;
      a.opts.unevaluated &&
        (a.props !== !0 &&
          e.props !== void 0 &&
          (a.props = Yr.mergeEvaluated.props(n, e.props, a.props, r)),
        a.items !== !0 &&
          e.items !== void 0 &&
          (a.items = Yr.mergeEvaluated.items(n, e.items, a.items, r)));
    }
    mergeValidEvaluated(e, r) {
      const { it: a, gen: n } = this;
      if (a.opts.unevaluated && (a.props !== !0 || a.items !== !0))
        return n.if(r, () => this.mergeEvaluated(e, he.Name)), !0;
    }
  }
  gr.KeywordCxt = Kf;
  function Gf(t, e, r, a) {
    const n = new Kf(t, r, e);
    "code" in r
      ? r.code(n, a)
      : n.$data && r.validate
      ? (0, Ga.funcKeywordCode)(n, r)
      : "macro" in r
      ? (0, Ga.macroKeywordCode)(n, r)
      : (r.compile || r.validate) && (0, Ga.funcKeywordCode)(n, r);
  }
  const bb = /^\/(?:[^~]|~0|~1)*$/,
    Eb = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function Wf(t, { dataLevel: e, dataNames: r, dataPathArr: a }) {
    let n, s;
    if (t === "") return $e.default.rootData;
    if (t[0] === "/") {
      if (!bb.test(t)) throw new Error(`Invalid JSON-pointer: ${t}`);
      (n = t), (s = $e.default.rootData);
    } else {
      const c = Eb.exec(t);
      if (!c) throw new Error(`Invalid JSON-pointer: ${t}`);
      const u = +c[1];
      if (((n = c[2]), n === "#")) {
        if (u >= e) throw new Error(l("property/index", u));
        return a[e - u];
      }
      if (u > e) throw new Error(l("data", u));
      if (((s = r[e - u]), !n)) return s;
    }
    let o = s;
    const i = n.split("/");
    for (const c of i)
      c &&
        ((s = (0, he._)`${s}${(0, he.getProperty)(
          (0, Yr.unescapeJsonPointer)(c)
        )}`),
        (o = (0, he._)`${o} && ${s}`));
    return o;
    function l(c, u) {
      return `Cannot access ${c} ${u} levels up, current level is ${e}`;
    }
  }
  gr.getData = Wf;
  var Qa = {};
  Object.defineProperty(Qa, "__esModule", { value: !0 });
  let Sb = class extends Error {
    constructor(e) {
      super("validation failed"),
        (this.errors = e),
        (this.ajv = this.validation = !0);
    }
  };
  Qa.default = Sb;
  var la = {};
  Object.defineProperty(la, "__esModule", { value: !0 });
  const Al = Rt;
  let $b = class extends Error {
    constructor(e, r, a, n) {
      super(n || `can't resolve reference ${a} from id ${r}`),
        (this.missingRef = (0, Al.resolveUrl)(e, r, a)),
        (this.missingSchema = (0, Al.normalizeId)(
          (0, Al.getFullPath)(e, this.missingRef)
        ));
    }
  };
  la.default = $b;
  var Jt = {};
  Object.defineProperty(Jt, "__esModule", { value: !0 }),
    (Jt.resolveSchema =
      Jt.getCompilingSchema =
      Jt.resolveRef =
      Jt.compileSchema =
      Jt.SchemaEnv =
        void 0);
  const yr = Ne,
    Pb = Qa,
    On = Rr,
    _r = Rt,
    Qf = oe,
    Tb = gr;
  class Eo {
    constructor(e) {
      var r;
      (this.refs = {}), (this.dynamicAnchors = {});
      let a;
      typeof e.schema == "object" && (a = e.schema),
        (this.schema = e.schema),
        (this.schemaId = e.schemaId),
        (this.root = e.root || this),
        (this.baseId =
          (r = e.baseId) !== null && r !== void 0
            ? r
            : (0, _r.normalizeId)(a == null ? void 0 : a[e.schemaId || "$id"])),
        (this.schemaPath = e.schemaPath),
        (this.localRefs = e.localRefs),
        (this.meta = e.meta),
        (this.$async = a == null ? void 0 : a.$async),
        (this.refs = {});
    }
  }
  Jt.SchemaEnv = Eo;
  function Nl(t) {
    const e = Yf.call(this, t);
    if (e) return e;
    const r = (0, _r.getFullPath)(this.opts.uriResolver, t.root.baseId),
      { es5: a, lines: n } = this.opts.code,
      { ownProperties: s } = this.opts,
      o = new yr.CodeGen(this.scope, { es5: a, lines: n, ownProperties: s });
    let i;
    t.$async &&
      (i = o.scopeValue("Error", {
        ref: Pb.default,
        code: (0, yr._)`require("ajv/dist/runtime/validation_error").default`,
      }));
    const l = o.scopeName("validate");
    t.validateName = l;
    const c = {
      gen: o,
      allErrors: this.opts.allErrors,
      data: On.default.data,
      parentData: On.default.parentData,
      parentDataProperty: On.default.parentDataProperty,
      dataNames: [On.default.data],
      dataPathArr: [yr.nil],
      dataLevel: 0,
      dataTypes: [],
      definedProperties: new Set(),
      topSchemaRef: o.scopeValue(
        "schema",
        this.opts.code.source === !0
          ? { ref: t.schema, code: (0, yr.stringify)(t.schema) }
          : { ref: t.schema }
      ),
      validateName: l,
      ValidationError: i,
      schema: t.schema,
      schemaEnv: t,
      rootId: r,
      baseId: t.baseId || r,
      schemaPath: yr.nil,
      errSchemaPath: t.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, yr._)`""`,
      opts: this.opts,
      self: this,
    };
    let u;
    try {
      this._compilations.add(t),
        (0, Tb.validateFunctionCode)(c),
        o.optimize(this.opts.code.optimize);
      const f = o.toString();
      (u = `${o.scopeRefs(On.default.scope)}return ${f}`),
        this.opts.code.process && (u = this.opts.code.process(u, t));
      const d = new Function(`${On.default.self}`, `${On.default.scope}`, u)(
        this,
        this.scope.get()
      );
      if (
        (this.scope.value(l, { ref: d }),
        (d.errors = null),
        (d.schema = t.schema),
        (d.schemaEnv = t),
        t.$async && (d.$async = !0),
        this.opts.code.source === !0 &&
          (d.source = {
            validateName: l,
            validateCode: f,
            scopeValues: o._values,
          }),
        this.opts.unevaluated)
      ) {
        const { props: p, items: g } = c;
        (d.evaluated = {
          props: p instanceof yr.Name ? void 0 : p,
          items: g instanceof yr.Name ? void 0 : g,
          dynamicProps: p instanceof yr.Name,
          dynamicItems: g instanceof yr.Name,
        }),
          d.source && (d.source.evaluated = (0, yr.stringify)(d.evaluated));
      }
      return (t.validate = d), t;
    } catch (f) {
      throw (
        (delete t.validate,
        delete t.validateName,
        u && this.logger.error("Error compiling schema, function code:", u),
        f)
      );
    } finally {
      this._compilations.delete(t);
    }
  }
  Jt.compileSchema = Nl;
  function xb(t, e, r) {
    var a;
    r = (0, _r.resolveUrl)(this.opts.uriResolver, e, r);
    const n = t.refs[r];
    if (n) return n;
    let s = Cb.call(this, t, r);
    if (s === void 0) {
      const o = (a = t.localRefs) === null || a === void 0 ? void 0 : a[r],
        { schemaId: i } = this.opts;
      o && (s = new Eo({ schema: o, schemaId: i, root: t, baseId: e }));
    }
    if (s !== void 0) return (t.refs[r] = Ib.call(this, s));
  }
  Jt.resolveRef = xb;
  function Ib(t) {
    return (0, _r.inlineRef)(t.schema, this.opts.inlineRefs)
      ? t.schema
      : t.validate
      ? t
      : Nl.call(this, t);
  }
  function Yf(t) {
    for (const e of this._compilations) if (kb(e, t)) return e;
  }
  Jt.getCompilingSchema = Yf;
  function kb(t, e) {
    return t.schema === e.schema && t.root === e.root && t.baseId === e.baseId;
  }
  function Cb(t, e) {
    let r;
    for (; typeof (r = this.refs[e]) == "string"; ) e = r;
    return r || this.schemas[e] || So.call(this, t, e);
  }
  function So(t, e) {
    const r = this.opts.uriResolver.parse(e),
      a = (0, _r._getFullPath)(this.opts.uriResolver, r);
    let n = (0, _r.getFullPath)(this.opts.uriResolver, t.baseId, void 0);
    if (Object.keys(t.schema).length > 0 && a === n) return Ml.call(this, r, t);
    const s = (0, _r.normalizeId)(a),
      o = this.refs[s] || this.schemas[s];
    if (typeof o == "string") {
      const i = So.call(this, t, o);
      return typeof (i == null ? void 0 : i.schema) != "object"
        ? void 0
        : Ml.call(this, r, i);
    }
    if (typeof (o == null ? void 0 : o.schema) == "object") {
      if ((o.validate || Nl.call(this, o), s === (0, _r.normalizeId)(e))) {
        const { schema: i } = o,
          { schemaId: l } = this.opts,
          c = i[l];
        return (
          c && (n = (0, _r.resolveUrl)(this.opts.uriResolver, n, c)),
          new Eo({ schema: i, schemaId: l, root: t, baseId: n })
        );
      }
      return Ml.call(this, r, o);
    }
  }
  Jt.resolveSchema = So;
  const Rb = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions",
  ]);
  function Ml(t, { baseId: e, schema: r, root: a }) {
    var n;
    if (((n = t.fragment) === null || n === void 0 ? void 0 : n[0]) !== "/")
      return;
    for (const i of t.fragment.slice(1).split("/")) {
      if (typeof r == "boolean") return;
      const l = r[(0, Qf.unescapeFragment)(i)];
      if (l === void 0) return;
      r = l;
      const c = typeof r == "object" && r[this.opts.schemaId];
      !Rb.has(i) && c && (e = (0, _r.resolveUrl)(this.opts.uriResolver, e, c));
    }
    let s;
    if (
      typeof r != "boolean" &&
      r.$ref &&
      !(0, Qf.schemaHasRulesButRef)(r, this.RULES)
    ) {
      const i = (0, _r.resolveUrl)(this.opts.uriResolver, e, r.$ref);
      s = So.call(this, a, i);
    }
    const { schemaId: o } = this.opts;
    if (
      ((s = s || new Eo({ schema: r, schemaId: o, root: a, baseId: e })),
      s.schema !== s.root.schema)
    )
      return s;
  }
  const Ob = {
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description:
      "Meta-schema for $data reference (JSON AnySchema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [
          { format: "relative-json-pointer" },
          { format: "json-pointer" },
        ],
      },
    },
    additionalProperties: !1,
  };
  var jl = {},
    $o = { exports: {} },
    Ab = {
      HEX: {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15,
      },
    };
  const { HEX: Nb } = Ab,
    Mb =
      /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
  function Xf(t) {
    if (rp(t, ".") < 3) return { host: t, isIPV4: !1 };
    const e = t.match(Mb) || [],
      [r] = e;
    return r ? { host: Db(r, "."), isIPV4: !0 } : { host: t, isIPV4: !1 };
  }
  function ep(t, e = !1) {
    let r = "",
      a = !0;
    for (const n of t) {
      if (Nb[n] === void 0) return;
      n !== "0" && a === !0 && (a = !1), a || (r += n);
    }
    return e && r.length === 0 && (r = "0"), r;
  }
  function jb(t) {
    let e = 0;
    const r = { error: !1, address: "", zone: "" },
      a = [],
      n = [];
    let s = !1,
      o = !1,
      i = !1;
    function l() {
      if (n.length) {
        if (s === !1) {
          const c = ep(n);
          if (c !== void 0) a.push(c);
          else return (r.error = !0), !1;
        }
        n.length = 0;
      }
      return !0;
    }
    for (let c = 0; c < t.length; c++) {
      const u = t[c];
      if (!(u === "[" || u === "]"))
        if (u === ":") {
          if ((o === !0 && (i = !0), !l())) break;
          if ((e++, a.push(":"), e > 7)) {
            r.error = !0;
            break;
          }
          c - 1 >= 0 && t[c - 1] === ":" && (o = !0);
          continue;
        } else if (u === "%") {
          if (!l()) break;
          s = !0;
        } else {
          n.push(u);
          continue;
        }
    }
    return (
      n.length &&
        (s ? (r.zone = n.join("")) : i ? a.push(n.join("")) : a.push(ep(n))),
      (r.address = a.join("")),
      r
    );
  }
  function tp(t) {
    if (rp(t, ":") < 2) return { host: t, isIPV6: !1 };
    const e = jb(t);
    if (e.error) return { host: t, isIPV6: !1 };
    {
      let r = e.address,
        a = e.address;
      return (
        e.zone && ((r += "%" + e.zone), (a += "%25" + e.zone)),
        { host: r, escapedHost: a, isIPV6: !0 }
      );
    }
  }
  function Db(t, e) {
    let r = "",
      a = !0;
    const n = t.length;
    for (let s = 0; s < n; s++) {
      const o = t[s];
      o === "0" && a
        ? ((s + 1 <= n && t[s + 1] === e) || s + 1 === n) &&
          ((r += o), (a = !1))
        : (o === e ? (a = !0) : (a = !1), (r += o));
    }
    return r;
  }
  function rp(t, e) {
    let r = 0;
    for (let a = 0; a < t.length; a++) t[a] === e && r++;
    return r;
  }
  const np = /^\.\.?\//u,
    ap = /^\/\.(?:\/|$)/u,
    sp = /^\/\.\.(?:\/|$)/u,
    Lb = /^\/?(?:.|\n)*?(?=\/|$)/u;
  function zb(t) {
    const e = [];
    for (; t.length; )
      if (t.match(np)) t = t.replace(np, "");
      else if (t.match(ap)) t = t.replace(ap, "/");
      else if (t.match(sp)) (t = t.replace(sp, "/")), e.pop();
      else if (t === "." || t === "..") t = "";
      else {
        const r = t.match(Lb);
        if (r) {
          const a = r[0];
          (t = t.slice(a.length)), e.push(a);
        } else throw new Error("Unexpected dot segment condition");
      }
    return e.join("");
  }
  function qb(t, e) {
    const r = e !== !0 ? escape : unescape;
    return (
      t.scheme !== void 0 && (t.scheme = r(t.scheme)),
      t.userinfo !== void 0 && (t.userinfo = r(t.userinfo)),
      t.host !== void 0 && (t.host = r(t.host)),
      t.path !== void 0 && (t.path = r(t.path)),
      t.query !== void 0 && (t.query = r(t.query)),
      t.fragment !== void 0 && (t.fragment = r(t.fragment)),
      t
    );
  }
  function Ub(t) {
    const e = [];
    if (
      (t.userinfo !== void 0 && (e.push(t.userinfo), e.push("@")),
      t.host !== void 0)
    ) {
      let r = unescape(t.host);
      const a = Xf(r);
      if (a.isIPV4) r = a.host;
      else {
        const n = tp(a.host);
        n.isIPV6 === !0 ? (r = `[${n.escapedHost}]`) : (r = t.host);
      }
      e.push(r);
    }
    return (
      (typeof t.port == "number" || typeof t.port == "string") &&
        (e.push(":"), e.push(String(t.port))),
      e.length ? e.join("") : void 0
    );
  }
  var Fb = {
    recomposeAuthority: Ub,
    normalizeComponentEncoding: qb,
    removeDotSegments: zb,
    normalizeIPv4: Xf,
    normalizeIPv6: tp,
  };
  const Vb = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu,
    Zb = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  function op(t) {
    return typeof t.secure == "boolean"
      ? t.secure
      : String(t.scheme).toLowerCase() === "wss";
  }
  function ip(t) {
    return t.host || (t.error = t.error || "HTTP URIs must have a host."), t;
  }
  function lp(t) {
    const e = String(t.scheme).toLowerCase() === "https";
    return (
      (t.port === (e ? 443 : 80) || t.port === "") && (t.port = void 0),
      t.path || (t.path = "/"),
      t
    );
  }
  function Hb(t) {
    return (
      (t.secure = op(t)),
      (t.resourceName = (t.path || "/") + (t.query ? "?" + t.query : "")),
      (t.path = void 0),
      (t.query = void 0),
      t
    );
  }
  function Bb(t) {
    if (
      ((t.port === (op(t) ? 443 : 80) || t.port === "") && (t.port = void 0),
      typeof t.secure == "boolean" &&
        ((t.scheme = t.secure ? "wss" : "ws"), (t.secure = void 0)),
      t.resourceName)
    ) {
      const [e, r] = t.resourceName.split("?");
      (t.path = e && e !== "/" ? e : void 0),
        (t.query = r),
        (t.resourceName = void 0);
    }
    return (t.fragment = void 0), t;
  }
  function Jb(t, e) {
    if (!t.path) return (t.error = "URN can not be parsed"), t;
    const r = t.path.match(Zb);
    if (r) {
      const a = e.scheme || t.scheme || "urn";
      (t.nid = r[1].toLowerCase()), (t.nss = r[2]);
      const n = `${a}:${e.nid || t.nid}`,
        s = Dl[n];
      (t.path = void 0), s && (t = s.parse(t, e));
    } else t.error = t.error || "URN can not be parsed.";
    return t;
  }
  function Kb(t, e) {
    const r = e.scheme || t.scheme || "urn",
      a = t.nid.toLowerCase(),
      n = `${r}:${e.nid || a}`,
      s = Dl[n];
    s && (t = s.serialize(t, e));
    const o = t,
      i = t.nss;
    return (o.path = `${a || e.nid}:${i}`), (e.skipEscape = !0), o;
  }
  function Gb(t, e) {
    const r = t;
    return (
      (r.uuid = r.nss),
      (r.nss = void 0),
      !e.tolerant &&
        (!r.uuid || !Vb.test(r.uuid)) &&
        (r.error = r.error || "UUID is not valid."),
      r
    );
  }
  function Wb(t) {
    const e = t;
    return (e.nss = (t.uuid || "").toLowerCase()), e;
  }
  const cp = { scheme: "http", domainHost: !0, parse: ip, serialize: lp },
    Qb = {
      scheme: "https",
      domainHost: cp.domainHost,
      parse: ip,
      serialize: lp,
    },
    Po = { scheme: "ws", domainHost: !0, parse: Hb, serialize: Bb },
    Yb = {
      scheme: "wss",
      domainHost: Po.domainHost,
      parse: Po.parse,
      serialize: Po.serialize,
    },
    Dl = {
      http: cp,
      https: Qb,
      ws: Po,
      wss: Yb,
      urn: { scheme: "urn", parse: Jb, serialize: Kb, skipNormalize: !0 },
      "urn:uuid": {
        scheme: "urn:uuid",
        parse: Gb,
        serialize: Wb,
        skipNormalize: !0,
      },
    };
  var Xb = Dl;
  const {
      normalizeIPv6: e1,
      normalizeIPv4: t1,
      removeDotSegments: Ya,
      recomposeAuthority: r1,
      normalizeComponentEncoding: To,
    } = Fb,
    Ll = Xb;
  function n1(t, e) {
    return (
      typeof t == "string"
        ? (t = Nr(Xr(t, e), e))
        : typeof t == "object" && (t = Xr(Nr(t, e), e)),
      t
    );
  }
  function a1(t, e, r) {
    const a = Object.assign({ scheme: "null" }, r),
      n = up(Xr(t, a), Xr(e, a), a, !0);
    return Nr(n, { ...a, skipEscape: !0 });
  }
  function up(t, e, r, a) {
    const n = {};
    return (
      a || ((t = Xr(Nr(t, r), r)), (e = Xr(Nr(e, r), r))),
      (r = r || {}),
      !r.tolerant && e.scheme
        ? ((n.scheme = e.scheme),
          (n.userinfo = e.userinfo),
          (n.host = e.host),
          (n.port = e.port),
          (n.path = Ya(e.path || "")),
          (n.query = e.query))
        : (e.userinfo !== void 0 || e.host !== void 0 || e.port !== void 0
            ? ((n.userinfo = e.userinfo),
              (n.host = e.host),
              (n.port = e.port),
              (n.path = Ya(e.path || "")),
              (n.query = e.query))
            : (e.path
                ? (e.path.charAt(0) === "/"
                    ? (n.path = Ya(e.path))
                    : ((t.userinfo !== void 0 ||
                        t.host !== void 0 ||
                        t.port !== void 0) &&
                      !t.path
                        ? (n.path = "/" + e.path)
                        : t.path
                        ? (n.path =
                            t.path.slice(0, t.path.lastIndexOf("/") + 1) +
                            e.path)
                        : (n.path = e.path),
                      (n.path = Ya(n.path))),
                  (n.query = e.query))
                : ((n.path = t.path),
                  e.query !== void 0
                    ? (n.query = e.query)
                    : (n.query = t.query)),
              (n.userinfo = t.userinfo),
              (n.host = t.host),
              (n.port = t.port)),
          (n.scheme = t.scheme)),
      (n.fragment = e.fragment),
      n
    );
  }
  function s1(t, e, r) {
    return (
      typeof t == "string"
        ? ((t = unescape(t)),
          (t = Nr(To(Xr(t, r), !0), { ...r, skipEscape: !0 })))
        : typeof t == "object" && (t = Nr(To(t, !0), { ...r, skipEscape: !0 })),
      typeof e == "string"
        ? ((e = unescape(e)),
          (e = Nr(To(Xr(e, r), !0), { ...r, skipEscape: !0 })))
        : typeof e == "object" && (e = Nr(To(e, !0), { ...r, skipEscape: !0 })),
      t.toLowerCase() === e.toLowerCase()
    );
  }
  function Nr(t, e) {
    const r = {
        host: t.host,
        scheme: t.scheme,
        userinfo: t.userinfo,
        port: t.port,
        path: t.path,
        query: t.query,
        nid: t.nid,
        nss: t.nss,
        uuid: t.uuid,
        fragment: t.fragment,
        reference: t.reference,
        resourceName: t.resourceName,
        secure: t.secure,
        error: "",
      },
      a = Object.assign({}, e),
      n = [],
      s = Ll[(a.scheme || r.scheme || "").toLowerCase()];
    s && s.serialize && s.serialize(r, a),
      r.path !== void 0 &&
        (a.skipEscape
          ? (r.path = unescape(r.path))
          : ((r.path = escape(r.path)),
            r.scheme !== void 0 && (r.path = r.path.split("%3A").join(":")))),
      a.reference !== "suffix" && r.scheme && n.push(r.scheme, ":");
    const o = r1(r);
    if (
      (o !== void 0 &&
        (a.reference !== "suffix" && n.push("//"),
        n.push(o),
        r.path && r.path.charAt(0) !== "/" && n.push("/")),
      r.path !== void 0)
    ) {
      let i = r.path;
      !a.absolutePath && (!s || !s.absolutePath) && (i = Ya(i)),
        o === void 0 && (i = i.replace(/^\/\//u, "/%2F")),
        n.push(i);
    }
    return (
      r.query !== void 0 && n.push("?", r.query),
      r.fragment !== void 0 && n.push("#", r.fragment),
      n.join("")
    );
  }
  const o1 = Array.from({ length: 127 }, (t, e) =>
    /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(e))
  );
  function i1(t) {
    let e = 0;
    for (let r = 0, a = t.length; r < a; ++r)
      if (((e = t.charCodeAt(r)), e > 126 || o1[e])) return !0;
    return !1;
  }
  const l1 =
    /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function Xr(t, e) {
    const r = Object.assign({}, e),
      a = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0,
      },
      n = t.indexOf("%") !== -1;
    let s = !1;
    r.reference === "suffix" &&
      (t = (r.scheme ? r.scheme + ":" : "") + "//" + t);
    const o = t.match(l1);
    if (o) {
      if (
        ((a.scheme = o[1]),
        (a.userinfo = o[3]),
        (a.host = o[4]),
        (a.port = parseInt(o[5], 10)),
        (a.path = o[6] || ""),
        (a.query = o[7]),
        (a.fragment = o[8]),
        isNaN(a.port) && (a.port = o[5]),
        a.host)
      ) {
        const l = t1(a.host);
        if (l.isIPV4 === !1) {
          const c = e1(l.host);
          (a.host = c.host.toLowerCase()), (s = c.isIPV6);
        } else (a.host = l.host), (s = !0);
      }
      a.scheme === void 0 &&
      a.userinfo === void 0 &&
      a.host === void 0 &&
      a.port === void 0 &&
      a.query === void 0 &&
      !a.path
        ? (a.reference = "same-document")
        : a.scheme === void 0
        ? (a.reference = "relative")
        : a.fragment === void 0
        ? (a.reference = "absolute")
        : (a.reference = "uri"),
        r.reference &&
          r.reference !== "suffix" &&
          r.reference !== a.reference &&
          (a.error = a.error || "URI is not a " + r.reference + " reference.");
      const i = Ll[(r.scheme || a.scheme || "").toLowerCase()];
      if (
        !r.unicodeSupport &&
        (!i || !i.unicodeSupport) &&
        a.host &&
        (r.domainHost || (i && i.domainHost)) &&
        s === !1 &&
        i1(a.host)
      )
        try {
          a.host = URL.domainToASCII(a.host.toLowerCase());
        } catch (l) {
          a.error =
            a.error || "Host's domain name can not be converted to ASCII: " + l;
        }
      (!i || (i && !i.skipNormalize)) &&
        (n && a.scheme !== void 0 && (a.scheme = unescape(a.scheme)),
        n && a.host !== void 0 && (a.host = unescape(a.host)),
        a.path && (a.path = escape(unescape(a.path))),
        a.fragment && (a.fragment = encodeURI(decodeURIComponent(a.fragment)))),
        i && i.parse && i.parse(a, r);
    } else a.error = a.error || "URI can not be parsed.";
    return a;
  }
  const zl = {
    SCHEMES: Ll,
    normalize: n1,
    resolve: a1,
    resolveComponents: up,
    equal: s1,
    serialize: Nr,
    parse: Xr,
  };
  ($o.exports = zl), ($o.exports.default = zl), ($o.exports.fastUri = zl);
  var c1 = $o.exports;
  Object.defineProperty(jl, "__esModule", { value: !0 });
  const dp = c1;
  (dp.code = 'require("ajv/dist/runtime/uri").default'),
    (jl.default = dp),
    (function (t) {
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.CodeGen =
          t.Name =
          t.nil =
          t.stringify =
          t.str =
          t._ =
          t.KeywordCxt =
            void 0);
      var e = gr;
      Object.defineProperty(t, "KeywordCxt", {
        enumerable: !0,
        get: function () {
          return e.KeywordCxt;
        },
      });
      var r = Ne;
      Object.defineProperty(t, "_", {
        enumerable: !0,
        get: function () {
          return r._;
        },
      }),
        Object.defineProperty(t, "str", {
          enumerable: !0,
          get: function () {
            return r.str;
          },
        }),
        Object.defineProperty(t, "stringify", {
          enumerable: !0,
          get: function () {
            return r.stringify;
          },
        }),
        Object.defineProperty(t, "nil", {
          enumerable: !0,
          get: function () {
            return r.nil;
          },
        }),
        Object.defineProperty(t, "Name", {
          enumerable: !0,
          get: function () {
            return r.Name;
          },
        }),
        Object.defineProperty(t, "CodeGen", {
          enumerable: !0,
          get: function () {
            return r.CodeGen;
          },
        });
      const a = Qa,
        n = la,
        s = Cn,
        o = Jt,
        i = Ne,
        l = Rt,
        c = Tt,
        u = oe,
        f = Ob,
        v = jl,
        d = (D, k) => new RegExp(D, k);
      d.code = "new RegExp";
      const p = ["removeAdditional", "useDefaults", "coerceTypes"],
        g = new Set([
          "validate",
          "serialize",
          "parse",
          "wrapper",
          "root",
          "schema",
          "keyword",
          "pattern",
          "formats",
          "validate$data",
          "func",
          "obj",
          "Error",
        ]),
        m = {
          errorDataPath: "",
          format: "`validateFormats: false` can be used instead.",
          nullable: '"nullable" keyword is supported by default.',
          jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
          extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
          missingRefs:
            "Pass empty schema with $id that should be ignored to ajv.addSchema.",
          processCode:
            "Use option `code: {process: (code, schemaEnv: object) => string}`",
          sourceCode: "Use option `code: {source: true}`",
          strictDefaults: "It is default now, see option `strict`.",
          strictKeywords: "It is default now, see option `strict`.",
          uniqueItems: '"uniqueItems" keyword is always validated.',
          unknownFormats:
            "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
          cache: "Map is used as cache, schema object as key.",
          serialize: "Map is used as cache, schema object as key.",
          ajvErrors: "It is default now.",
        },
        h = {
          ignoreKeywordsWithRef: "",
          jsPropertySyntax: "",
          unicode:
            '"minLength"/"maxLength" account for unicode characters by default.',
        },
        y = 200;
      function _(D) {
        var k,
          L,
          R,
          b,
          T,
          q,
          G,
          ee,
          fe,
          le,
          ve,
          Ae,
          Pe,
          xe,
          Te,
          ze,
          ae,
          qe,
          we,
          ht,
          Zt,
          Ge,
          We,
          tt,
          gt;
        const Ht = D.strict,
          Dt = (k = D.code) === null || k === void 0 ? void 0 : k.optimize,
          Ir = Dt === !0 || Dt === void 0 ? 1 : Dt || 0,
          Ze =
            (R = (L = D.code) === null || L === void 0 ? void 0 : L.regExp) !==
              null && R !== void 0
              ? R
              : d,
          Lt = (b = D.uriResolver) !== null && b !== void 0 ? b : v.default;
        return {
          strictSchema:
            (q = (T = D.strictSchema) !== null && T !== void 0 ? T : Ht) !==
              null && q !== void 0
              ? q
              : !0,
          strictNumbers:
            (ee = (G = D.strictNumbers) !== null && G !== void 0 ? G : Ht) !==
              null && ee !== void 0
              ? ee
              : !0,
          strictTypes:
            (le = (fe = D.strictTypes) !== null && fe !== void 0 ? fe : Ht) !==
              null && le !== void 0
              ? le
              : "log",
          strictTuples:
            (Ae = (ve = D.strictTuples) !== null && ve !== void 0 ? ve : Ht) !==
              null && Ae !== void 0
              ? Ae
              : "log",
          strictRequired:
            (xe =
              (Pe = D.strictRequired) !== null && Pe !== void 0 ? Pe : Ht) !==
              null && xe !== void 0
              ? xe
              : !1,
          code: D.code
            ? { ...D.code, optimize: Ir, regExp: Ze }
            : { optimize: Ir, regExp: Ze },
          loopRequired:
            (Te = D.loopRequired) !== null && Te !== void 0 ? Te : y,
          loopEnum: (ze = D.loopEnum) !== null && ze !== void 0 ? ze : y,
          meta: (ae = D.meta) !== null && ae !== void 0 ? ae : !0,
          messages: (qe = D.messages) !== null && qe !== void 0 ? qe : !0,
          inlineRefs: (we = D.inlineRefs) !== null && we !== void 0 ? we : !0,
          schemaId: (ht = D.schemaId) !== null && ht !== void 0 ? ht : "$id",
          addUsedSchema:
            (Zt = D.addUsedSchema) !== null && Zt !== void 0 ? Zt : !0,
          validateSchema:
            (Ge = D.validateSchema) !== null && Ge !== void 0 ? Ge : !0,
          validateFormats:
            (We = D.validateFormats) !== null && We !== void 0 ? We : !0,
          unicodeRegExp:
            (tt = D.unicodeRegExp) !== null && tt !== void 0 ? tt : !0,
          int32range: (gt = D.int32range) !== null && gt !== void 0 ? gt : !0,
          uriResolver: Lt,
        };
      }
      class w {
        constructor(k = {}) {
          (this.schemas = {}),
            (this.refs = {}),
            (this.formats = {}),
            (this._compilations = new Set()),
            (this._loading = {}),
            (this._cache = new Map()),
            (k = this.opts = { ...k, ..._(k) });
          const { es5: L, lines: R } = this.opts.code;
          (this.scope = new i.ValueScope({
            scope: {},
            prefixes: g,
            es5: L,
            lines: R,
          })),
            (this.logger = J(k.logger));
          const b = k.validateFormats;
          (k.validateFormats = !1),
            (this.RULES = (0, s.getRules)()),
            E.call(this, m, k, "NOT SUPPORTED"),
            E.call(this, h, k, "DEPRECATED", "warn"),
            (this._metaOpts = H.call(this)),
            k.formats && A.call(this),
            this._addVocabularies(),
            this._addDefaultMetaSchema(),
            k.keywords && M.call(this, k.keywords),
            typeof k.meta == "object" && this.addMetaSchema(k.meta),
            x.call(this),
            (k.validateFormats = b);
        }
        _addVocabularies() {
          this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
          const { $data: k, meta: L, schemaId: R } = this.opts;
          let b = f;
          R === "id" && ((b = { ...f }), (b.id = b.$id), delete b.$id),
            L && k && this.addMetaSchema(b, b[R], !1);
        }
        defaultMeta() {
          const { meta: k, schemaId: L } = this.opts;
          return (this.opts.defaultMeta =
            typeof k == "object" ? k[L] || k : void 0);
        }
        validate(k, L) {
          let R;
          if (typeof k == "string") {
            if (((R = this.getSchema(k)), !R))
              throw new Error(`no schema with key or ref "${k}"`);
          } else R = this.compile(k);
          const b = R(L);
          return "$async" in R || (this.errors = R.errors), b;
        }
        compile(k, L) {
          const R = this._addSchema(k, L);
          return R.validate || this._compileSchemaEnv(R);
        }
        compileAsync(k, L) {
          if (typeof this.opts.loadSchema != "function")
            throw new Error("options.loadSchema should be a function");
          const { loadSchema: R } = this.opts;
          return b.call(this, k, L);
          async function b(le, ve) {
            await T.call(this, le.$schema);
            const Ae = this._addSchema(le, ve);
            return Ae.validate || q.call(this, Ae);
          }
          async function T(le) {
            le && !this.getSchema(le) && (await b.call(this, { $ref: le }, !0));
          }
          async function q(le) {
            try {
              return this._compileSchemaEnv(le);
            } catch (ve) {
              if (!(ve instanceof n.default)) throw ve;
              return (
                G.call(this, ve),
                await ee.call(this, ve.missingSchema),
                q.call(this, le)
              );
            }
          }
          function G({ missingSchema: le, missingRef: ve }) {
            if (this.refs[le])
              throw new Error(
                `AnySchema ${le} is loaded but ${ve} cannot be resolved`
              );
          }
          async function ee(le) {
            const ve = await fe.call(this, le);
            this.refs[le] || (await T.call(this, ve.$schema)),
              this.refs[le] || this.addSchema(ve, le, L);
          }
          async function fe(le) {
            const ve = this._loading[le];
            if (ve) return ve;
            try {
              return await (this._loading[le] = R(le));
            } finally {
              delete this._loading[le];
            }
          }
        }
        addSchema(k, L, R, b = this.opts.validateSchema) {
          if (Array.isArray(k)) {
            for (const q of k) this.addSchema(q, void 0, R, b);
            return this;
          }
          let T;
          if (typeof k == "object") {
            const { schemaId: q } = this.opts;
            if (((T = k[q]), T !== void 0 && typeof T != "string"))
              throw new Error(`schema ${q} must be string`);
          }
          return (
            (L = (0, l.normalizeId)(L || T)),
            this._checkUnique(L),
            (this.schemas[L] = this._addSchema(k, R, L, b, !0)),
            this
          );
        }
        addMetaSchema(k, L, R = this.opts.validateSchema) {
          return this.addSchema(k, L, !0, R), this;
        }
        validateSchema(k, L) {
          if (typeof k == "boolean") return !0;
          let R;
          if (((R = k.$schema), R !== void 0 && typeof R != "string"))
            throw new Error("$schema must be a string");
          if (((R = R || this.opts.defaultMeta || this.defaultMeta()), !R))
            return (
              this.logger.warn("meta-schema not available"),
              (this.errors = null),
              !0
            );
          const b = this.validate(R, k);
          if (!b && L) {
            const T = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log") this.logger.error(T);
            else throw new Error(T);
          }
          return b;
        }
        getSchema(k) {
          let L;
          for (; typeof (L = P.call(this, k)) == "string"; ) k = L;
          if (L === void 0) {
            const { schemaId: R } = this.opts,
              b = new o.SchemaEnv({ schema: {}, schemaId: R });
            if (((L = o.resolveSchema.call(this, b, k)), !L)) return;
            this.refs[k] = L;
          }
          return L.validate || this._compileSchemaEnv(L);
        }
        removeSchema(k) {
          if (k instanceof RegExp)
            return (
              this._removeAllSchemas(this.schemas, k),
              this._removeAllSchemas(this.refs, k),
              this
            );
          switch (typeof k) {
            case "undefined":
              return (
                this._removeAllSchemas(this.schemas),
                this._removeAllSchemas(this.refs),
                this._cache.clear(),
                this
              );
            case "string": {
              const L = P.call(this, k);
              return (
                typeof L == "object" && this._cache.delete(L.schema),
                delete this.schemas[k],
                delete this.refs[k],
                this
              );
            }
            case "object": {
              const L = k;
              this._cache.delete(L);
              let R = k[this.opts.schemaId];
              return (
                R &&
                  ((R = (0, l.normalizeId)(R)),
                  delete this.schemas[R],
                  delete this.refs[R]),
                this
              );
            }
            default:
              throw new Error("ajv.removeSchema: invalid parameter");
          }
        }
        addVocabulary(k) {
          for (const L of k) this.addKeyword(L);
          return this;
        }
        addKeyword(k, L) {
          let R;
          if (typeof k == "string")
            (R = k),
              typeof L == "object" &&
                (this.logger.warn(
                  "these parameters are deprecated, see docs for addKeyword"
                ),
                (L.keyword = R));
          else if (typeof k == "object" && L === void 0) {
            if (((L = k), (R = L.keyword), Array.isArray(R) && !R.length))
              throw new Error(
                "addKeywords: keyword must be string or non-empty array"
              );
          } else throw new Error("invalid addKeywords parameters");
          if ((Z.call(this, R, L), !L))
            return (0, u.eachItem)(R, (T) => te.call(this, T)), this;
          ge.call(this, L);
          const b = {
            ...L,
            type: (0, c.getJSONTypes)(L.type),
            schemaType: (0, c.getJSONTypes)(L.schemaType),
          };
          return (
            (0, u.eachItem)(
              R,
              b.type.length === 0
                ? (T) => te.call(this, T, b)
                : (T) => b.type.forEach((q) => te.call(this, T, b, q))
            ),
            this
          );
        }
        getKeyword(k) {
          const L = this.RULES.all[k];
          return typeof L == "object" ? L.definition : !!L;
        }
        removeKeyword(k) {
          const { RULES: L } = this;
          delete L.keywords[k], delete L.all[k];
          for (const R of L.rules) {
            const b = R.rules.findIndex((T) => T.keyword === k);
            b >= 0 && R.rules.splice(b, 1);
          }
          return this;
        }
        addFormat(k, L) {
          return (
            typeof L == "string" && (L = new RegExp(L)),
            (this.formats[k] = L),
            this
          );
        }
        errorsText(
          k = this.errors,
          { separator: L = ", ", dataVar: R = "data" } = {}
        ) {
          return !k || k.length === 0
            ? "No errors"
            : k
                .map((b) => `${R}${b.instancePath} ${b.message}`)
                .reduce((b, T) => b + L + T);
        }
        $dataMetaSchema(k, L) {
          const R = this.RULES.all;
          k = JSON.parse(JSON.stringify(k));
          for (const b of L) {
            const T = b.split("/").slice(1);
            let q = k;
            for (const G of T) q = q[G];
            for (const G in R) {
              const ee = R[G];
              if (typeof ee != "object") continue;
              const { $data: fe } = ee.definition,
                le = q[G];
              fe && le && (q[G] = se(le));
            }
          }
          return k;
        }
        _removeAllSchemas(k, L) {
          for (const R in k) {
            const b = k[R];
            (!L || L.test(R)) &&
              (typeof b == "string"
                ? delete k[R]
                : b && !b.meta && (this._cache.delete(b.schema), delete k[R]));
          }
        }
        _addSchema(
          k,
          L,
          R,
          b = this.opts.validateSchema,
          T = this.opts.addUsedSchema
        ) {
          let q;
          const { schemaId: G } = this.opts;
          if (typeof k == "object") q = k[G];
          else {
            if (this.opts.jtd) throw new Error("schema must be object");
            if (typeof k != "boolean")
              throw new Error("schema must be object or boolean");
          }
          let ee = this._cache.get(k);
          if (ee !== void 0) return ee;
          R = (0, l.normalizeId)(q || R);
          const fe = l.getSchemaRefs.call(this, k, R);
          return (
            (ee = new o.SchemaEnv({
              schema: k,
              schemaId: G,
              meta: L,
              baseId: R,
              localRefs: fe,
            })),
            this._cache.set(ee.schema, ee),
            T &&
              !R.startsWith("#") &&
              (R && this._checkUnique(R), (this.refs[R] = ee)),
            b && this.validateSchema(k, !0),
            ee
          );
        }
        _checkUnique(k) {
          if (this.schemas[k] || this.refs[k])
            throw new Error(`schema with key or id "${k}" already exists`);
        }
        _compileSchemaEnv(k) {
          if (
            (k.meta
              ? this._compileMetaSchema(k)
              : o.compileSchema.call(this, k),
            !k.validate)
          )
            throw new Error("ajv implementation error");
          return k.validate;
        }
        _compileMetaSchema(k) {
          const L = this.opts;
          this.opts = this._metaOpts;
          try {
            o.compileSchema.call(this, k);
          } finally {
            this.opts = L;
          }
        }
      }
      (w.ValidationError = a.default),
        (w.MissingRefError = n.default),
        (t.default = w);
      function E(D, k, L, R = "error") {
        for (const b in D) {
          const T = b;
          T in k && this.logger[R](`${L}: option ${b}. ${D[T]}`);
        }
      }
      function P(D) {
        return (D = (0, l.normalizeId)(D)), this.schemas[D] || this.refs[D];
      }
      function x() {
        const D = this.opts.schemas;
        if (D)
          if (Array.isArray(D)) this.addSchema(D);
          else for (const k in D) this.addSchema(D[k], k);
      }
      function A() {
        for (const D in this.opts.formats) {
          const k = this.opts.formats[D];
          k && this.addFormat(D, k);
        }
      }
      function M(D) {
        if (Array.isArray(D)) {
          this.addVocabulary(D);
          return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (const k in D) {
          const L = D[k];
          L.keyword || (L.keyword = k), this.addKeyword(L);
        }
      }
      function H() {
        const D = { ...this.opts };
        for (const k of p) delete D[k];
        return D;
      }
      const V = { log() {}, warn() {}, error() {} };
      function J(D) {
        if (D === !1) return V;
        if (D === void 0) return console;
        if (D.log && D.warn && D.error) return D;
        throw new Error("logger must implement log, warn and error methods");
      }
      const z = /^[a-z_$][a-z0-9_$:-]*$/i;
      function Z(D, k) {
        const { RULES: L } = this;
        if (
          ((0, u.eachItem)(D, (R) => {
            if (L.keywords[R])
              throw new Error(`Keyword ${R} is already defined`);
            if (!z.test(R)) throw new Error(`Keyword ${R} has invalid name`);
          }),
          !!k && k.$data && !("code" in k || "validate" in k))
        )
          throw new Error(
            '$data keyword must have "code" or "validate" function'
          );
      }
      function te(D, k, L) {
        var R;
        const b = k == null ? void 0 : k.post;
        if (L && b)
          throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES: T } = this;
        let q = b ? T.post : T.rules.find(({ type: ee }) => ee === L);
        if (
          (q || ((q = { type: L, rules: [] }), T.rules.push(q)),
          (T.keywords[D] = !0),
          !k)
        )
          return;
        const G = {
          keyword: D,
          definition: {
            ...k,
            type: (0, c.getJSONTypes)(k.type),
            schemaType: (0, c.getJSONTypes)(k.schemaType),
          },
        };
        k.before ? me.call(this, q, G, k.before) : q.rules.push(G),
          (T.all[D] = G),
          (R = k.implements) === null ||
            R === void 0 ||
            R.forEach((ee) => this.addKeyword(ee));
      }
      function me(D, k, L) {
        const R = D.rules.findIndex((b) => b.keyword === L);
        R >= 0
          ? D.rules.splice(R, 0, k)
          : (D.rules.push(k), this.logger.warn(`rule ${L} is not defined`));
      }
      function ge(D) {
        let { metaSchema: k } = D;
        k !== void 0 &&
          (D.$data && this.opts.$data && (k = se(k)),
          (D.validateSchema = this.compile(k, !0)));
      }
      const N = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      };
      function se(D) {
        return { anyOf: [D, N] };
      }
    })(ff);
  var ql = {},
    Ul = {},
    Fl = {};
  Object.defineProperty(Fl, "__esModule", { value: !0 });
  const u1 = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    },
  };
  Fl.default = u1;
  var An = {};
  Object.defineProperty(An, "__esModule", { value: !0 }),
    (An.callRef = An.getValidate = void 0);
  const d1 = la,
    fp = Me,
    Kt = Ne,
    ca = Rr,
    pp = Jt,
    xo = oe,
    f1 = {
      keyword: "$ref",
      schemaType: "string",
      code(t) {
        const { gen: e, schema: r, it: a } = t,
          { baseId: n, schemaEnv: s, validateName: o, opts: i, self: l } = a,
          { root: c } = s;
        if ((r === "#" || r === "#/") && n === c.baseId) return f();
        const u = pp.resolveRef.call(l, c, n, r);
        if (u === void 0) throw new d1.default(a.opts.uriResolver, n, r);
        if (u instanceof pp.SchemaEnv) return v(u);
        return d(u);
        function f() {
          if (s === c) return Io(t, o, s, s.$async);
          const p = e.scopeValue("root", { ref: c });
          return Io(t, (0, Kt._)`${p}.validate`, c, c.$async);
        }
        function v(p) {
          const g = hp(t, p);
          Io(t, g, p, p.$async);
        }
        function d(p) {
          const g = e.scopeValue(
              "schema",
              i.code.source === !0
                ? { ref: p, code: (0, Kt.stringify)(p) }
                : { ref: p }
            ),
            m = e.name("valid"),
            h = t.subschema(
              {
                schema: p,
                dataTypes: [],
                schemaPath: Kt.nil,
                topSchemaRef: g,
                errSchemaPath: r,
              },
              m
            );
          t.mergeEvaluated(h), t.ok(m);
        }
      },
    };
  function hp(t, e) {
    const { gen: r } = t;
    return e.validate
      ? r.scopeValue("validate", { ref: e.validate })
      : (0, Kt._)`${r.scopeValue("wrapper", { ref: e })}.validate`;
  }
  An.getValidate = hp;
  function Io(t, e, r, a) {
    const { gen: n, it: s } = t,
      { allErrors: o, schemaEnv: i, opts: l } = s,
      c = l.passContext ? ca.default.this : Kt.nil;
    a ? u() : f();
    function u() {
      if (!i.$async) throw new Error("async schema referenced by sync schema");
      const p = n.let("valid");
      n.try(
        () => {
          n.code((0, Kt._)`await ${(0, fp.callValidateCode)(t, e, c)}`),
            d(e),
            o || n.assign(p, !0);
        },
        (g) => {
          n.if((0, Kt._)`!(${g} instanceof ${s.ValidationError})`, () =>
            n.throw(g)
          ),
            v(g),
            o || n.assign(p, !1);
        }
      ),
        t.ok(p);
    }
    function f() {
      t.result(
        (0, fp.callValidateCode)(t, e, c),
        () => d(e),
        () => v(e)
      );
    }
    function v(p) {
      const g = (0, Kt._)`${p}.errors`;
      n.assign(
        ca.default.vErrors,
        (0,
        Kt._)`${ca.default.vErrors} === null ? ${g} : ${ca.default.vErrors}.concat(${g})`
      ),
        n.assign(ca.default.errors, (0, Kt._)`${ca.default.vErrors}.length`);
    }
    function d(p) {
      var g;
      if (!s.opts.unevaluated) return;
      const m =
        (g = r == null ? void 0 : r.validate) === null || g === void 0
          ? void 0
          : g.evaluated;
      if (s.props !== !0)
        if (m && !m.dynamicProps)
          m.props !== void 0 &&
            (s.props = xo.mergeEvaluated.props(n, m.props, s.props));
        else {
          const h = n.var("props", (0, Kt._)`${p}.evaluated.props`);
          s.props = xo.mergeEvaluated.props(n, h, s.props, Kt.Name);
        }
      if (s.items !== !0)
        if (m && !m.dynamicItems)
          m.items !== void 0 &&
            (s.items = xo.mergeEvaluated.items(n, m.items, s.items));
        else {
          const h = n.var("items", (0, Kt._)`${p}.evaluated.items`);
          s.items = xo.mergeEvaluated.items(n, h, s.items, Kt.Name);
        }
    }
  }
  (An.callRef = Io),
    (An.default = f1),
    Object.defineProperty(Ul, "__esModule", { value: !0 });
  const p1 = Fl,
    h1 = An,
    m1 = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      p1.default,
      h1.default,
    ];
  Ul.default = m1;
  var Vl = {},
    Zl = {};
  Object.defineProperty(Zl, "__esModule", { value: !0 });
  const ko = Ne,
    fn = ko.operators,
    Co = {
      maximum: { okStr: "<=", ok: fn.LTE, fail: fn.GT },
      minimum: { okStr: ">=", ok: fn.GTE, fail: fn.LT },
      exclusiveMaximum: { okStr: "<", ok: fn.LT, fail: fn.GTE },
      exclusiveMinimum: { okStr: ">", ok: fn.GT, fail: fn.LTE },
    },
    v1 = {
      message: ({ keyword: t, schemaCode: e }) =>
        (0, ko.str)`must be ${Co[t].okStr} ${e}`,
      params: ({ keyword: t, schemaCode: e }) =>
        (0, ko._)`{comparison: ${Co[t].okStr}, limit: ${e}}`,
    },
    g1 = {
      keyword: Object.keys(Co),
      type: "number",
      schemaType: "number",
      $data: !0,
      error: v1,
      code(t) {
        const { keyword: e, data: r, schemaCode: a } = t;
        t.fail$data((0, ko._)`${r} ${Co[e].fail} ${a} || isNaN(${r})`);
      },
    };
  Zl.default = g1;
  var Hl = {};
  Object.defineProperty(Hl, "__esModule", { value: !0 });
  const Xa = Ne,
    y1 = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: !0,
      error: {
        message: ({ schemaCode: t }) => (0, Xa.str)`must be multiple of ${t}`,
        params: ({ schemaCode: t }) => (0, Xa._)`{multipleOf: ${t}}`,
      },
      code(t) {
        const { gen: e, data: r, schemaCode: a, it: n } = t,
          s = n.opts.multipleOfPrecision,
          o = e.let("res"),
          i = s
            ? (0, Xa._)`Math.abs(Math.round(${o}) - ${o}) > 1e-${s}`
            : (0, Xa._)`${o} !== parseInt(${o})`;
        t.fail$data((0, Xa._)`(${a} === 0 || (${o} = ${r}/${a}, ${i}))`);
      },
    };
  Hl.default = y1;
  var Bl = {},
    Jl = {};
  Object.defineProperty(Jl, "__esModule", { value: !0 });
  function mp(t) {
    const e = t.length;
    let r = 0,
      a = 0,
      n;
    for (; a < e; )
      r++,
        (n = t.charCodeAt(a++)),
        n >= 55296 &&
          n <= 56319 &&
          a < e &&
          ((n = t.charCodeAt(a)), (n & 64512) === 56320 && a++);
    return r;
  }
  (Jl.default = mp),
    (mp.code = 'require("ajv/dist/runtime/ucs2length").default'),
    Object.defineProperty(Bl, "__esModule", { value: !0 });
  const Nn = Ne,
    _1 = oe,
    w1 = Jl,
    b1 = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: t, schemaCode: e }) {
          const r = t === "maxLength" ? "more" : "fewer";
          return (0, Nn.str)`must NOT have ${r} than ${e} characters`;
        },
        params: ({ schemaCode: t }) => (0, Nn._)`{limit: ${t}}`,
      },
      code(t) {
        const { keyword: e, data: r, schemaCode: a, it: n } = t,
          s = e === "maxLength" ? Nn.operators.GT : Nn.operators.LT,
          o =
            n.opts.unicode === !1
              ? (0, Nn._)`${r}.length`
              : (0, Nn._)`${(0, _1.useFunc)(t.gen, w1.default)}(${r})`;
        t.fail$data((0, Nn._)`${o} ${s} ${a}`);
      },
    };
  Bl.default = b1;
  var Kl = {};
  Object.defineProperty(Kl, "__esModule", { value: !0 });
  const E1 = Me,
    Ro = Ne,
    S1 = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: !0,
      error: {
        message: ({ schemaCode: t }) => (0, Ro.str)`must match pattern "${t}"`,
        params: ({ schemaCode: t }) => (0, Ro._)`{pattern: ${t}}`,
      },
      code(t) {
        const { data: e, $data: r, schema: a, schemaCode: n, it: s } = t,
          o = s.opts.unicodeRegExp ? "u" : "",
          i = r
            ? (0, Ro._)`(new RegExp(${n}, ${o}))`
            : (0, E1.usePattern)(t, a);
        t.fail$data((0, Ro._)`!${i}.test(${e})`);
      },
    };
  Kl.default = S1;
  var Gl = {};
  Object.defineProperty(Gl, "__esModule", { value: !0 });
  const es = Ne,
    $1 = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: t, schemaCode: e }) {
          const r = t === "maxProperties" ? "more" : "fewer";
          return (0, es.str)`must NOT have ${r} than ${e} properties`;
        },
        params: ({ schemaCode: t }) => (0, es._)`{limit: ${t}}`,
      },
      code(t) {
        const { keyword: e, data: r, schemaCode: a } = t,
          n = e === "maxProperties" ? es.operators.GT : es.operators.LT;
        t.fail$data((0, es._)`Object.keys(${r}).length ${n} ${a}`);
      },
    };
  Gl.default = $1;
  var Wl = {};
  Object.defineProperty(Wl, "__esModule", { value: !0 });
  const ts = Me,
    rs = Ne,
    P1 = oe,
    T1 = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: !0,
      error: {
        message: ({ params: { missingProperty: t } }) =>
          (0, rs.str)`must have required property '${t}'`,
        params: ({ params: { missingProperty: t } }) =>
          (0, rs._)`{missingProperty: ${t}}`,
      },
      code(t) {
        const {
            gen: e,
            schema: r,
            schemaCode: a,
            data: n,
            $data: s,
            it: o,
          } = t,
          { opts: i } = o;
        if (!s && r.length === 0) return;
        const l = r.length >= i.loopRequired;
        if ((o.allErrors ? c() : u(), i.strictRequired)) {
          const d = t.parentSchema.properties,
            { definedProperties: p } = t.it;
          for (const g of r)
            if ((d == null ? void 0 : d[g]) === void 0 && !p.has(g)) {
              const m = o.schemaEnv.baseId + o.errSchemaPath,
                h = `required property "${g}" is not defined at "${m}" (strictRequired)`;
              (0, P1.checkStrictMode)(o, h, o.opts.strictRequired);
            }
        }
        function c() {
          if (l || s) t.block$data(rs.nil, f);
          else for (const d of r) (0, ts.checkReportMissingProp)(t, d);
        }
        function u() {
          const d = e.let("missing");
          if (l || s) {
            const p = e.let("valid", !0);
            t.block$data(p, () => v(d, p)), t.ok(p);
          } else
            e.if((0, ts.checkMissingProp)(t, r, d)),
              (0, ts.reportMissingProp)(t, d),
              e.else();
        }
        function f() {
          e.forOf("prop", a, (d) => {
            t.setParams({ missingProperty: d }),
              e.if((0, ts.noPropertyInData)(e, n, d, i.ownProperties), () =>
                t.error()
              );
          });
        }
        function v(d, p) {
          t.setParams({ missingProperty: d }),
            e.forOf(
              d,
              a,
              () => {
                e.assign(p, (0, ts.propertyInData)(e, n, d, i.ownProperties)),
                  e.if((0, rs.not)(p), () => {
                    t.error(), e.break();
                  });
              },
              rs.nil
            );
        }
      },
    };
  Wl.default = T1;
  var Ql = {};
  Object.defineProperty(Ql, "__esModule", { value: !0 });
  const ns = Ne,
    x1 = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: t, schemaCode: e }) {
          const r = t === "maxItems" ? "more" : "fewer";
          return (0, ns.str)`must NOT have ${r} than ${e} items`;
        },
        params: ({ schemaCode: t }) => (0, ns._)`{limit: ${t}}`,
      },
      code(t) {
        const { keyword: e, data: r, schemaCode: a } = t,
          n = e === "maxItems" ? ns.operators.GT : ns.operators.LT;
        t.fail$data((0, ns._)`${r}.length ${n} ${a}`);
      },
    };
  Ql.default = x1;
  var Yl = {},
    as = {};
  Object.defineProperty(as, "__esModule", { value: !0 });
  const vp = Ka;
  (vp.code = 'require("ajv/dist/runtime/equal").default'),
    (as.default = vp),
    Object.defineProperty(Yl, "__esModule", { value: !0 });
  const Xl = Tt,
    Ot = Ne,
    I1 = oe,
    k1 = as,
    C1 = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: !0,
      error: {
        message: ({ params: { i: t, j: e } }) =>
          (0,
          Ot.str)`must NOT have duplicate items (items ## ${e} and ${t} are identical)`,
        params: ({ params: { i: t, j: e } }) => (0, Ot._)`{i: ${t}, j: ${e}}`,
      },
      code(t) {
        const {
          gen: e,
          data: r,
          $data: a,
          schema: n,
          parentSchema: s,
          schemaCode: o,
          it: i,
        } = t;
        if (!a && !n) return;
        const l = e.let("valid"),
          c = s.items ? (0, Xl.getSchemaTypes)(s.items) : [];
        t.block$data(l, u, (0, Ot._)`${o} === false`), t.ok(l);
        function u() {
          const p = e.let("i", (0, Ot._)`${r}.length`),
            g = e.let("j");
          t.setParams({ i: p, j: g }),
            e.assign(l, !0),
            e.if((0, Ot._)`${p} > 1`, () => (f() ? v : d)(p, g));
        }
        function f() {
          return (
            c.length > 0 && !c.some((p) => p === "object" || p === "array")
          );
        }
        function v(p, g) {
          const m = e.name("item"),
            h = (0, Xl.checkDataTypes)(
              c,
              m,
              i.opts.strictNumbers,
              Xl.DataType.Wrong
            ),
            y = e.const("indices", (0, Ot._)`{}`);
          e.for((0, Ot._)`;${p}--;`, () => {
            e.let(m, (0, Ot._)`${r}[${p}]`),
              e.if(h, (0, Ot._)`continue`),
              c.length > 1 &&
                e.if(
                  (0, Ot._)`typeof ${m} == "string"`,
                  (0, Ot._)`${m} += "_"`
                ),
              e
                .if((0, Ot._)`typeof ${y}[${m}] == "number"`, () => {
                  e.assign(g, (0, Ot._)`${y}[${m}]`),
                    t.error(),
                    e.assign(l, !1).break();
                })
                .code((0, Ot._)`${y}[${m}] = ${p}`);
          });
        }
        function d(p, g) {
          const m = (0, I1.useFunc)(e, k1.default),
            h = e.name("outer");
          e.label(h).for((0, Ot._)`;${p}--;`, () =>
            e.for((0, Ot._)`${g} = ${p}; ${g}--;`, () =>
              e.if((0, Ot._)`${m}(${r}[${p}], ${r}[${g}])`, () => {
                t.error(), e.assign(l, !1).break(h);
              })
            )
          );
        }
      },
    };
  Yl.default = C1;
  var ec = {};
  Object.defineProperty(ec, "__esModule", { value: !0 });
  const tc = Ne,
    R1 = oe,
    O1 = as,
    A1 = {
      keyword: "const",
      $data: !0,
      error: {
        message: "must be equal to constant",
        params: ({ schemaCode: t }) => (0, tc._)`{allowedValue: ${t}}`,
      },
      code(t) {
        const { gen: e, data: r, $data: a, schemaCode: n, schema: s } = t;
        a || (s && typeof s == "object")
          ? t.fail$data(
              (0, tc._)`!${(0, R1.useFunc)(e, O1.default)}(${r}, ${n})`
            )
          : t.fail((0, tc._)`${s} !== ${r}`);
      },
    };
  ec.default = A1;
  var rc = {};
  Object.defineProperty(rc, "__esModule", { value: !0 });
  const ss = Ne,
    N1 = oe,
    M1 = as,
    j1 = {
      keyword: "enum",
      schemaType: "array",
      $data: !0,
      error: {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode: t }) => (0, ss._)`{allowedValues: ${t}}`,
      },
      code(t) {
        const {
          gen: e,
          data: r,
          $data: a,
          schema: n,
          schemaCode: s,
          it: o,
        } = t;
        if (!a && n.length === 0)
          throw new Error("enum must have non-empty array");
        const i = n.length >= o.opts.loopEnum;
        let l;
        const c = () => l ?? (l = (0, N1.useFunc)(e, M1.default));
        let u;
        if (i || a) (u = e.let("valid")), t.block$data(u, f);
        else {
          if (!Array.isArray(n)) throw new Error("ajv implementation error");
          const d = e.const("vSchema", s);
          u = (0, ss.or)(...n.map((p, g) => v(d, g)));
        }
        t.pass(u);
        function f() {
          e.assign(u, !1),
            e.forOf("v", s, (d) =>
              e.if((0, ss._)`${c()}(${r}, ${d})`, () => e.assign(u, !0).break())
            );
        }
        function v(d, p) {
          const g = n[p];
          return typeof g == "object" && g !== null
            ? (0, ss._)`${c()}(${r}, ${d}[${p}])`
            : (0, ss._)`${r} === ${g}`;
        }
      },
    };
  (rc.default = j1), Object.defineProperty(Vl, "__esModule", { value: !0 });
  const D1 = Zl,
    L1 = Hl,
    z1 = Bl,
    q1 = Kl,
    U1 = Gl,
    F1 = Wl,
    V1 = Ql,
    Z1 = Yl,
    H1 = ec,
    B1 = rc,
    J1 = [
      D1.default,
      L1.default,
      z1.default,
      q1.default,
      U1.default,
      F1.default,
      V1.default,
      Z1.default,
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      H1.default,
      B1.default,
    ];
  Vl.default = J1;
  var nc = {},
    ua = {};
  Object.defineProperty(ua, "__esModule", { value: !0 }),
    (ua.validateAdditionalItems = void 0);
  const Mn = Ne,
    ac = oe,
    K1 = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: {
        message: ({ params: { len: t } }) =>
          (0, Mn.str)`must NOT have more than ${t} items`,
        params: ({ params: { len: t } }) => (0, Mn._)`{limit: ${t}}`,
      },
      code(t) {
        const { parentSchema: e, it: r } = t,
          { items: a } = e;
        if (!Array.isArray(a)) {
          (0, ac.checkStrictMode)(
            r,
            '"additionalItems" is ignored when "items" is not an array of schemas'
          );
          return;
        }
        gp(t, a);
      },
    };
  function gp(t, e) {
    const { gen: r, schema: a, data: n, keyword: s, it: o } = t;
    o.items = !0;
    const i = r.const("len", (0, Mn._)`${n}.length`);
    if (a === !1)
      t.setParams({ len: e.length }), t.pass((0, Mn._)`${i} <= ${e.length}`);
    else if (typeof a == "object" && !(0, ac.alwaysValidSchema)(o, a)) {
      const c = r.var("valid", (0, Mn._)`${i} <= ${e.length}`);
      r.if((0, Mn.not)(c), () => l(c)), t.ok(c);
    }
    function l(c) {
      r.forRange("i", e.length, i, (u) => {
        t.subschema({ keyword: s, dataProp: u, dataPropType: ac.Type.Num }, c),
          o.allErrors || r.if((0, Mn.not)(c), () => r.break());
      });
    }
  }
  (ua.validateAdditionalItems = gp), (ua.default = K1);
  var sc = {},
    da = {};
  Object.defineProperty(da, "__esModule", { value: !0 }),
    (da.validateTuple = void 0);
  const yp = Ne,
    Oo = oe,
    G1 = Me,
    W1 = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(t) {
        const { schema: e, it: r } = t;
        if (Array.isArray(e)) return _p(t, "additionalItems", e);
        (r.items = !0),
          !(0, Oo.alwaysValidSchema)(r, e) && t.ok((0, G1.validateArray)(t));
      },
    };
  function _p(t, e, r = t.schema) {
    const { gen: a, parentSchema: n, data: s, keyword: o, it: i } = t;
    u(n),
      i.opts.unevaluated &&
        r.length &&
        i.items !== !0 &&
        (i.items = Oo.mergeEvaluated.items(a, r.length, i.items));
    const l = a.name("valid"),
      c = a.const("len", (0, yp._)`${s}.length`);
    r.forEach((f, v) => {
      (0, Oo.alwaysValidSchema)(i, f) ||
        (a.if((0, yp._)`${c} > ${v}`, () =>
          t.subschema({ keyword: o, schemaProp: v, dataProp: v }, l)
        ),
        t.ok(l));
    });
    function u(f) {
      const { opts: v, errSchemaPath: d } = i,
        p = r.length,
        g = p === f.minItems && (p === f.maxItems || f[e] === !1);
      if (v.strictTuples && !g) {
        const m = `"${o}" is ${p}-tuple, but minItems or maxItems/${e} are not specified or different at path "${d}"`;
        (0, Oo.checkStrictMode)(i, m, v.strictTuples);
      }
    }
  }
  (da.validateTuple = _p),
    (da.default = W1),
    Object.defineProperty(sc, "__esModule", { value: !0 });
  const Q1 = da,
    Y1 = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (t) => (0, Q1.validateTuple)(t, "items"),
    };
  sc.default = Y1;
  var oc = {};
  Object.defineProperty(oc, "__esModule", { value: !0 });
  const wp = Ne,
    X1 = oe,
    eE = Me,
    tE = ua,
    rE = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: {
        message: ({ params: { len: t } }) =>
          (0, wp.str)`must NOT have more than ${t} items`,
        params: ({ params: { len: t } }) => (0, wp._)`{limit: ${t}}`,
      },
      code(t) {
        const { schema: e, parentSchema: r, it: a } = t,
          { prefixItems: n } = r;
        (a.items = !0),
          !(0, X1.alwaysValidSchema)(a, e) &&
            (n
              ? (0, tE.validateAdditionalItems)(t, n)
              : t.ok((0, eE.validateArray)(t)));
      },
    };
  oc.default = rE;
  var ic = {};
  Object.defineProperty(ic, "__esModule", { value: !0 });
  const ir = Ne,
    Ao = oe,
    nE = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: !0,
      error: {
        message: ({ params: { min: t, max: e } }) =>
          e === void 0
            ? (0, ir.str)`must contain at least ${t} valid item(s)`
            : (0,
              ir.str)`must contain at least ${t} and no more than ${e} valid item(s)`,
        params: ({ params: { min: t, max: e } }) =>
          e === void 0
            ? (0, ir._)`{minContains: ${t}}`
            : (0, ir._)`{minContains: ${t}, maxContains: ${e}}`,
      },
      code(t) {
        const { gen: e, schema: r, parentSchema: a, data: n, it: s } = t;
        let o, i;
        const { minContains: l, maxContains: c } = a;
        s.opts.next ? ((o = l === void 0 ? 1 : l), (i = c)) : (o = 1);
        const u = e.const("len", (0, ir._)`${n}.length`);
        if ((t.setParams({ min: o, max: i }), i === void 0 && o === 0)) {
          (0, Ao.checkStrictMode)(
            s,
            '"minContains" == 0 without "maxContains": "contains" keyword ignored'
          );
          return;
        }
        if (i !== void 0 && o > i) {
          (0, Ao.checkStrictMode)(
            s,
            '"minContains" > "maxContains" is always invalid'
          ),
            t.fail();
          return;
        }
        if ((0, Ao.alwaysValidSchema)(s, r)) {
          let g = (0, ir._)`${u} >= ${o}`;
          i !== void 0 && (g = (0, ir._)`${g} && ${u} <= ${i}`), t.pass(g);
          return;
        }
        s.items = !0;
        const f = e.name("valid");
        i === void 0 && o === 1
          ? d(f, () => e.if(f, () => e.break()))
          : o === 0
          ? (e.let(f, !0), i !== void 0 && e.if((0, ir._)`${n}.length > 0`, v))
          : (e.let(f, !1), v()),
          t.result(f, () => t.reset());
        function v() {
          const g = e.name("_valid"),
            m = e.let("count", 0);
          d(g, () => e.if(g, () => p(m)));
        }
        function d(g, m) {
          e.forRange("i", 0, u, (h) => {
            t.subschema(
              {
                keyword: "contains",
                dataProp: h,
                dataPropType: Ao.Type.Num,
                compositeRule: !0,
              },
              g
            ),
              m();
          });
        }
        function p(g) {
          e.code((0, ir._)`${g}++`),
            i === void 0
              ? e.if((0, ir._)`${g} >= ${o}`, () => e.assign(f, !0).break())
              : (e.if((0, ir._)`${g} > ${i}`, () => e.assign(f, !1).break()),
                o === 1
                  ? e.assign(f, !0)
                  : e.if((0, ir._)`${g} >= ${o}`, () => e.assign(f, !0)));
        }
      },
    };
  ic.default = nE;
  var bp = {};
  (function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.validateSchemaDeps = t.validatePropertyDeps = t.error = void 0);
    const e = Ne,
      r = oe,
      a = Me;
    t.error = {
      message: ({ params: { property: l, depsCount: c, deps: u } }) => {
        const f = c === 1 ? "property" : "properties";
        return (0, e.str)`must have ${f} ${u} when property ${l} is present`;
      },
      params: ({
        params: { property: l, depsCount: c, deps: u, missingProperty: f },
      }) => (0, e._)`{property: ${l},
    missingProperty: ${f},
    depsCount: ${c},
    deps: ${u}}`,
    };
    const n = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: t.error,
      code(l) {
        const [c, u] = s(l);
        o(l, c), i(l, u);
      },
    };
    function s({ schema: l }) {
      const c = {},
        u = {};
      for (const f in l) {
        if (f === "__proto__") continue;
        const v = Array.isArray(l[f]) ? c : u;
        v[f] = l[f];
      }
      return [c, u];
    }
    function o(l, c = l.schema) {
      const { gen: u, data: f, it: v } = l;
      if (Object.keys(c).length === 0) return;
      const d = u.let("missing");
      for (const p in c) {
        const g = c[p];
        if (g.length === 0) continue;
        const m = (0, a.propertyInData)(u, f, p, v.opts.ownProperties);
        l.setParams({ property: p, depsCount: g.length, deps: g.join(", ") }),
          v.allErrors
            ? u.if(m, () => {
                for (const h of g) (0, a.checkReportMissingProp)(l, h);
              })
            : (u.if((0, e._)`${m} && (${(0, a.checkMissingProp)(l, g, d)})`),
              (0, a.reportMissingProp)(l, d),
              u.else());
      }
    }
    t.validatePropertyDeps = o;
    function i(l, c = l.schema) {
      const { gen: u, data: f, keyword: v, it: d } = l,
        p = u.name("valid");
      for (const g in c)
        (0, r.alwaysValidSchema)(d, c[g]) ||
          (u.if(
            (0, a.propertyInData)(u, f, g, d.opts.ownProperties),
            () => {
              const m = l.subschema({ keyword: v, schemaProp: g }, p);
              l.mergeValidEvaluated(m, p);
            },
            () => u.var(p, !0)
          ),
          l.ok(p));
    }
    (t.validateSchemaDeps = i), (t.default = n);
  })(bp);
  var lc = {};
  Object.defineProperty(lc, "__esModule", { value: !0 });
  const Ep = Ne,
    aE = oe,
    sE = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: {
        message: "property name must be valid",
        params: ({ params: t }) => (0, Ep._)`{propertyName: ${t.propertyName}}`,
      },
      code(t) {
        const { gen: e, schema: r, data: a, it: n } = t;
        if ((0, aE.alwaysValidSchema)(n, r)) return;
        const s = e.name("valid");
        e.forIn("key", a, (o) => {
          t.setParams({ propertyName: o }),
            t.subschema(
              {
                keyword: "propertyNames",
                data: o,
                dataTypes: ["string"],
                propertyName: o,
                compositeRule: !0,
              },
              s
            ),
            e.if((0, Ep.not)(s), () => {
              t.error(!0), n.allErrors || e.break();
            });
        }),
          t.ok(s);
      },
    };
  lc.default = sE;
  var No = {};
  Object.defineProperty(No, "__esModule", { value: !0 });
  const Mo = Me,
    wr = Ne,
    oE = Rr,
    jo = oe,
    iE = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: !0,
      trackErrors: !0,
      error: {
        message: "must NOT have additional properties",
        params: ({ params: t }) =>
          (0, wr._)`{additionalProperty: ${t.additionalProperty}}`,
      },
      code(t) {
        const {
          gen: e,
          schema: r,
          parentSchema: a,
          data: n,
          errsCount: s,
          it: o,
        } = t;
        if (!s) throw new Error("ajv implementation error");
        const { allErrors: i, opts: l } = o;
        if (
          ((o.props = !0),
          l.removeAdditional !== "all" && (0, jo.alwaysValidSchema)(o, r))
        )
          return;
        const c = (0, Mo.allSchemaProperties)(a.properties),
          u = (0, Mo.allSchemaProperties)(a.patternProperties);
        f(), t.ok((0, wr._)`${s} === ${oE.default.errors}`);
        function f() {
          e.forIn("key", n, (m) => {
            !c.length && !u.length ? p(m) : e.if(v(m), () => p(m));
          });
        }
        function v(m) {
          let h;
          if (c.length > 8) {
            const y = (0, jo.schemaRefOrVal)(o, a.properties, "properties");
            h = (0, Mo.isOwnProperty)(e, y, m);
          } else
            c.length
              ? (h = (0, wr.or)(...c.map((y) => (0, wr._)`${m} === ${y}`)))
              : (h = wr.nil);
          return (
            u.length &&
              (h = (0, wr.or)(
                h,
                ...u.map(
                  (y) => (0, wr._)`${(0, Mo.usePattern)(t, y)}.test(${m})`
                )
              )),
            (0, wr.not)(h)
          );
        }
        function d(m) {
          e.code((0, wr._)`delete ${n}[${m}]`);
        }
        function p(m) {
          if (
            l.removeAdditional === "all" ||
            (l.removeAdditional && r === !1)
          ) {
            d(m);
            return;
          }
          if (r === !1) {
            t.setParams({ additionalProperty: m }), t.error(), i || e.break();
            return;
          }
          if (typeof r == "object" && !(0, jo.alwaysValidSchema)(o, r)) {
            const h = e.name("valid");
            l.removeAdditional === "failing"
              ? (g(m, h, !1),
                e.if((0, wr.not)(h), () => {
                  t.reset(), d(m);
                }))
              : (g(m, h), i || e.if((0, wr.not)(h), () => e.break()));
          }
        }
        function g(m, h, y) {
          const _ = {
            keyword: "additionalProperties",
            dataProp: m,
            dataPropType: jo.Type.Str,
          };
          y === !1 &&
            Object.assign(_, {
              compositeRule: !0,
              createErrors: !1,
              allErrors: !1,
            }),
            t.subschema(_, h);
        }
      },
    };
  No.default = iE;
  var cc = {};
  Object.defineProperty(cc, "__esModule", { value: !0 });
  const lE = gr,
    Sp = Me,
    uc = oe,
    $p = No,
    cE = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(t) {
        const { gen: e, schema: r, parentSchema: a, data: n, it: s } = t;
        s.opts.removeAdditional === "all" &&
          a.additionalProperties === void 0 &&
          $p.default.code(
            new lE.KeywordCxt(s, $p.default, "additionalProperties")
          );
        const o = (0, Sp.allSchemaProperties)(r);
        for (const f of o) s.definedProperties.add(f);
        s.opts.unevaluated &&
          o.length &&
          s.props !== !0 &&
          (s.props = uc.mergeEvaluated.props(e, (0, uc.toHash)(o), s.props));
        const i = o.filter((f) => !(0, uc.alwaysValidSchema)(s, r[f]));
        if (i.length === 0) return;
        const l = e.name("valid");
        for (const f of i)
          c(f)
            ? u(f)
            : (e.if((0, Sp.propertyInData)(e, n, f, s.opts.ownProperties)),
              u(f),
              s.allErrors || e.else().var(l, !0),
              e.endIf()),
            t.it.definedProperties.add(f),
            t.ok(l);
        function c(f) {
          return (
            s.opts.useDefaults && !s.compositeRule && r[f].default !== void 0
          );
        }
        function u(f) {
          t.subschema({ keyword: "properties", schemaProp: f, dataProp: f }, l);
        }
      },
    };
  cc.default = cE;
  var dc = {};
  Object.defineProperty(dc, "__esModule", { value: !0 });
  const Pp = Me,
    Do = Ne,
    Tp = oe,
    xp = oe,
    uE = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(t) {
        const { gen: e, schema: r, data: a, parentSchema: n, it: s } = t,
          { opts: o } = s,
          i = (0, Pp.allSchemaProperties)(r),
          l = i.filter((g) => (0, Tp.alwaysValidSchema)(s, r[g]));
        if (
          i.length === 0 ||
          (l.length === i.length && (!s.opts.unevaluated || s.props === !0))
        )
          return;
        const c = o.strictSchema && !o.allowMatchingProperties && n.properties,
          u = e.name("valid");
        s.props !== !0 &&
          !(s.props instanceof Do.Name) &&
          (s.props = (0, xp.evaluatedPropsToName)(e, s.props));
        const { props: f } = s;
        v();
        function v() {
          for (const g of i)
            c && d(g), s.allErrors ? p(g) : (e.var(u, !0), p(g), e.if(u));
        }
        function d(g) {
          for (const m in c)
            new RegExp(g).test(m) &&
              (0, Tp.checkStrictMode)(
                s,
                `property ${m} matches pattern ${g} (use allowMatchingProperties)`
              );
        }
        function p(g) {
          e.forIn("key", a, (m) => {
            e.if((0, Do._)`${(0, Pp.usePattern)(t, g)}.test(${m})`, () => {
              const h = l.includes(g);
              h ||
                t.subschema(
                  {
                    keyword: "patternProperties",
                    schemaProp: g,
                    dataProp: m,
                    dataPropType: xp.Type.Str,
                  },
                  u
                ),
                s.opts.unevaluated && f !== !0
                  ? e.assign((0, Do._)`${f}[${m}]`, !0)
                  : !h && !s.allErrors && e.if((0, Do.not)(u), () => e.break());
            });
          });
        }
      },
    };
  dc.default = uE;
  var fc = {};
  Object.defineProperty(fc, "__esModule", { value: !0 });
  const dE = oe,
    fE = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      code(t) {
        const { gen: e, schema: r, it: a } = t;
        if ((0, dE.alwaysValidSchema)(a, r)) {
          t.fail();
          return;
        }
        const n = e.name("valid");
        t.subschema(
          {
            keyword: "not",
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1,
          },
          n
        ),
          t.failResult(
            n,
            () => t.reset(),
            () => t.error()
          );
      },
      error: { message: "must NOT be valid" },
    };
  fc.default = fE;
  var pc = {};
  Object.defineProperty(pc, "__esModule", { value: !0 });
  const pE = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: Me.validateUnion,
    error: { message: "must match a schema in anyOf" },
  };
  pc.default = pE;
  var hc = {};
  Object.defineProperty(hc, "__esModule", { value: !0 });
  const Lo = Ne,
    hE = oe,
    mE = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: !0,
      error: {
        message: "must match exactly one schema in oneOf",
        params: ({ params: t }) => (0, Lo._)`{passingSchemas: ${t.passing}}`,
      },
      code(t) {
        const { gen: e, schema: r, parentSchema: a, it: n } = t;
        if (!Array.isArray(r)) throw new Error("ajv implementation error");
        if (n.opts.discriminator && a.discriminator) return;
        const s = r,
          o = e.let("valid", !1),
          i = e.let("passing", null),
          l = e.name("_valid");
        t.setParams({ passing: i }),
          e.block(c),
          t.result(
            o,
            () => t.reset(),
            () => t.error(!0)
          );
        function c() {
          s.forEach((u, f) => {
            let v;
            (0, hE.alwaysValidSchema)(n, u)
              ? e.var(l, !0)
              : (v = t.subschema(
                  { keyword: "oneOf", schemaProp: f, compositeRule: !0 },
                  l
                )),
              f > 0 &&
                e
                  .if((0, Lo._)`${l} && ${o}`)
                  .assign(o, !1)
                  .assign(i, (0, Lo._)`[${i}, ${f}]`)
                  .else(),
              e.if(l, () => {
                e.assign(o, !0),
                  e.assign(i, f),
                  v && t.mergeEvaluated(v, Lo.Name);
              });
          });
        }
      },
    };
  hc.default = mE;
  var mc = {};
  Object.defineProperty(mc, "__esModule", { value: !0 });
  const vE = oe,
    gE = {
      keyword: "allOf",
      schemaType: "array",
      code(t) {
        const { gen: e, schema: r, it: a } = t;
        if (!Array.isArray(r)) throw new Error("ajv implementation error");
        const n = e.name("valid");
        r.forEach((s, o) => {
          if ((0, vE.alwaysValidSchema)(a, s)) return;
          const i = t.subschema({ keyword: "allOf", schemaProp: o }, n);
          t.ok(n), t.mergeEvaluated(i);
        });
      },
    };
  mc.default = gE;
  var vc = {};
  Object.defineProperty(vc, "__esModule", { value: !0 });
  const zo = Ne,
    Ip = oe,
    yE = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      error: {
        message: ({ params: t }) =>
          (0, zo.str)`must match "${t.ifClause}" schema`,
        params: ({ params: t }) => (0, zo._)`{failingKeyword: ${t.ifClause}}`,
      },
      code(t) {
        const { gen: e, parentSchema: r, it: a } = t;
        r.then === void 0 &&
          r.else === void 0 &&
          (0, Ip.checkStrictMode)(
            a,
            '"if" without "then" and "else" is ignored'
          );
        const n = kp(a, "then"),
          s = kp(a, "else");
        if (!n && !s) return;
        const o = e.let("valid", !0),
          i = e.name("_valid");
        if ((l(), t.reset(), n && s)) {
          const u = e.let("ifClause");
          t.setParams({ ifClause: u }), e.if(i, c("then", u), c("else", u));
        } else n ? e.if(i, c("then")) : e.if((0, zo.not)(i), c("else"));
        t.pass(o, () => t.error(!0));
        function l() {
          const u = t.subschema(
            {
              keyword: "if",
              compositeRule: !0,
              createErrors: !1,
              allErrors: !1,
            },
            i
          );
          t.mergeEvaluated(u);
        }
        function c(u, f) {
          return () => {
            const v = t.subschema({ keyword: u }, i);
            e.assign(o, i),
              t.mergeValidEvaluated(v, o),
              f ? e.assign(f, (0, zo._)`${u}`) : t.setParams({ ifClause: u });
          };
        }
      },
    };
  function kp(t, e) {
    const r = t.schema[e];
    return r !== void 0 && !(0, Ip.alwaysValidSchema)(t, r);
  }
  vc.default = yE;
  var gc = {};
  Object.defineProperty(gc, "__esModule", { value: !0 });
  const _E = oe,
    wE = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: t, parentSchema: e, it: r }) {
        e.if === void 0 &&
          (0, _E.checkStrictMode)(r, `"${t}" without "if" is ignored`);
      },
    };
  (gc.default = wE), Object.defineProperty(nc, "__esModule", { value: !0 });
  const bE = ua,
    EE = sc,
    SE = da,
    $E = oc,
    PE = ic,
    TE = bp,
    xE = lc,
    IE = No,
    kE = cc,
    CE = dc,
    RE = fc,
    OE = pc,
    AE = hc,
    NE = mc,
    ME = vc,
    jE = gc;
  function DE(t = !1) {
    const e = [
      RE.default,
      OE.default,
      AE.default,
      NE.default,
      ME.default,
      jE.default,
      xE.default,
      IE.default,
      TE.default,
      kE.default,
      CE.default,
    ];
    return (
      t ? e.push(EE.default, $E.default) : e.push(bE.default, SE.default),
      e.push(PE.default),
      e
    );
  }
  nc.default = DE;
  var yc = {},
    _c = {};
  Object.defineProperty(_c, "__esModule", { value: !0 });
  const yt = Ne,
    LE = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: !0,
      error: {
        message: ({ schemaCode: t }) => (0, yt.str)`must match format "${t}"`,
        params: ({ schemaCode: t }) => (0, yt._)`{format: ${t}}`,
      },
      code(t, e) {
        const {
            gen: r,
            data: a,
            $data: n,
            schema: s,
            schemaCode: o,
            it: i,
          } = t,
          { opts: l, errSchemaPath: c, schemaEnv: u, self: f } = i;
        if (!l.validateFormats) return;
        n ? v() : d();
        function v() {
          const p = r.scopeValue("formats", {
              ref: f.formats,
              code: l.code.formats,
            }),
            g = r.const("fDef", (0, yt._)`${p}[${o}]`),
            m = r.let("fType"),
            h = r.let("format");
          r.if(
            (0, yt._)`typeof ${g} == "object" && !(${g} instanceof RegExp)`,
            () =>
              r
                .assign(m, (0, yt._)`${g}.type || "string"`)
                .assign(h, (0, yt._)`${g}.validate`),
            () => r.assign(m, (0, yt._)`"string"`).assign(h, g)
          ),
            t.fail$data((0, yt.or)(y(), _()));
          function y() {
            return l.strictSchema === !1 ? yt.nil : (0, yt._)`${o} && !${h}`;
          }
          function _() {
            const w = u.$async
                ? (0, yt._)`(${g}.async ? await ${h}(${a}) : ${h}(${a}))`
                : (0, yt._)`${h}(${a})`,
              E = (0,
              yt._)`(typeof ${h} == "function" ? ${w} : ${h}.test(${a}))`;
            return (0, yt._)`${h} && ${h} !== true && ${m} === ${e} && !${E}`;
          }
        }
        function d() {
          const p = f.formats[s];
          if (!p) {
            y();
            return;
          }
          if (p === !0) return;
          const [g, m, h] = _(p);
          g === e && t.pass(w());
          function y() {
            if (l.strictSchema === !1) {
              f.logger.warn(E());
              return;
            }
            throw new Error(E());
            function E() {
              return `unknown format "${s}" ignored in schema at path "${c}"`;
            }
          }
          function _(E) {
            const P =
                E instanceof RegExp
                  ? (0, yt.regexpCode)(E)
                  : l.code.formats
                  ? (0, yt._)`${l.code.formats}${(0, yt.getProperty)(s)}`
                  : void 0,
              x = r.scopeValue("formats", { key: s, ref: E, code: P });
            return typeof E == "object" && !(E instanceof RegExp)
              ? [E.type || "string", E.validate, (0, yt._)`${x}.validate`]
              : ["string", E, x];
          }
          function w() {
            if (typeof p == "object" && !(p instanceof RegExp) && p.async) {
              if (!u.$async) throw new Error("async format in sync schema");
              return (0, yt._)`await ${h}(${a})`;
            }
            return typeof m == "function"
              ? (0, yt._)`${h}(${a})`
              : (0, yt._)`${h}.test(${a})`;
          }
        }
      },
    };
  (_c.default = LE), Object.defineProperty(yc, "__esModule", { value: !0 });
  const zE = [_c.default];
  yc.default = zE;
  var fa = {};
  Object.defineProperty(fa, "__esModule", { value: !0 }),
    (fa.contentVocabulary = fa.metadataVocabulary = void 0),
    (fa.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples",
    ]),
    (fa.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema",
    ]),
    Object.defineProperty(ql, "__esModule", { value: !0 });
  const qE = Ul,
    UE = Vl,
    FE = nc,
    VE = yc,
    Cp = fa,
    ZE = [
      qE.default,
      UE.default,
      (0, FE.default)(),
      VE.default,
      Cp.metadataVocabulary,
      Cp.contentVocabulary,
    ];
  ql.default = ZE;
  var wc = {},
    qo = {};
  Object.defineProperty(qo, "__esModule", { value: !0 }),
    (qo.DiscrError = void 0);
  var Rp;
  (function (t) {
    (t.Tag = "tag"), (t.Mapping = "mapping");
  })(Rp || (qo.DiscrError = Rp = {})),
    Object.defineProperty(wc, "__esModule", { value: !0 });
  const pa = Ne,
    bc = qo,
    Op = Jt,
    HE = la,
    BE = oe,
    JE = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: {
        message: ({ params: { discrError: t, tagName: e } }) =>
          t === bc.DiscrError.Tag
            ? `tag "${e}" must be string`
            : `value of tag "${e}" must be in oneOf`,
        params: ({ params: { discrError: t, tag: e, tagName: r } }) =>
          (0, pa._)`{error: ${t}, tag: ${r}, tagValue: ${e}}`,
      },
      code(t) {
        const { gen: e, data: r, schema: a, parentSchema: n, it: s } = t,
          { oneOf: o } = n;
        if (!s.opts.discriminator)
          throw new Error("discriminator: requires discriminator option");
        const i = a.propertyName;
        if (typeof i != "string")
          throw new Error("discriminator: requires propertyName");
        if (a.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!o) throw new Error("discriminator: requires oneOf keyword");
        const l = e.let("valid", !1),
          c = e.const("tag", (0, pa._)`${r}${(0, pa.getProperty)(i)}`);
        e.if(
          (0, pa._)`typeof ${c} == "string"`,
          () => u(),
          () =>
            t.error(!1, { discrError: bc.DiscrError.Tag, tag: c, tagName: i })
        ),
          t.ok(l);
        function u() {
          const d = v();
          e.if(!1);
          for (const p in d)
            e.elseIf((0, pa._)`${c} === ${p}`), e.assign(l, f(d[p]));
          e.else(),
            t.error(!1, {
              discrError: bc.DiscrError.Mapping,
              tag: c,
              tagName: i,
            }),
            e.endIf();
        }
        function f(d) {
          const p = e.name("valid"),
            g = t.subschema({ keyword: "oneOf", schemaProp: d }, p);
          return t.mergeEvaluated(g, pa.Name), p;
        }
        function v() {
          var d;
          const p = {},
            g = h(n);
          let m = !0;
          for (let w = 0; w < o.length; w++) {
            let E = o[w];
            if (
              E != null &&
              E.$ref &&
              !(0, BE.schemaHasRulesButRef)(E, s.self.RULES)
            ) {
              const x = E.$ref;
              if (
                ((E = Op.resolveRef.call(
                  s.self,
                  s.schemaEnv.root,
                  s.baseId,
                  x
                )),
                E instanceof Op.SchemaEnv && (E = E.schema),
                E === void 0)
              )
                throw new HE.default(s.opts.uriResolver, s.baseId, x);
            }
            const P =
              (d = E == null ? void 0 : E.properties) === null || d === void 0
                ? void 0
                : d[i];
            if (typeof P != "object")
              throw new Error(
                `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${i}"`
              );
            (m = m && (g || h(E))), y(P, w);
          }
          if (!m) throw new Error(`discriminator: "${i}" must be required`);
          return p;
          function h({ required: w }) {
            return Array.isArray(w) && w.includes(i);
          }
          function y(w, E) {
            if (w.const) _(w.const, E);
            else if (w.enum) for (const P of w.enum) _(P, E);
            else
              throw new Error(
                `discriminator: "properties/${i}" must have "const" or "enum"`
              );
          }
          function _(w, E) {
            if (typeof w != "string" || w in p)
              throw new Error(
                `discriminator: "${i}" values must be unique strings`
              );
            p[w] = E;
          }
        }
      },
    };
  wc.default = JE;
  const KE = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
      nonNegativeInteger: { type: "integer", minimum: 0 },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
      },
      simpleTypes: {
        enum: [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string",
        ],
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: !0,
        default: [],
      },
    },
    type: ["object", "boolean"],
    properties: {
      $id: { type: "string", format: "uri-reference" },
      $schema: { type: "string", format: "uri" },
      $ref: { type: "string", format: "uri-reference" },
      $comment: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      default: !0,
      readOnly: { type: "boolean", default: !1 },
      examples: { type: "array", items: !0 },
      multipleOf: { type: "number", exclusiveMinimum: 0 },
      maximum: { type: "number" },
      exclusiveMaximum: { type: "number" },
      minimum: { type: "number" },
      exclusiveMinimum: { type: "number" },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: { type: "string", format: "regex" },
      additionalItems: { $ref: "#" },
      items: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
        default: !0,
      },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: { type: "boolean", default: !1 },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {},
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {},
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        propertyNames: { format: "regex" },
        default: {},
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
        },
      },
      propertyNames: { $ref: "#" },
      const: !0,
      enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: !0,
          },
        ],
      },
      format: { type: "string" },
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      if: { $ref: "#" },
      then: { $ref: "#" },
      else: { $ref: "#" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" },
    },
    default: !0,
  };
  (function (t, e) {
    Object.defineProperty(e, "__esModule", { value: !0 }),
      (e.MissingRefError =
        e.ValidationError =
        e.CodeGen =
        e.Name =
        e.nil =
        e.stringify =
        e.str =
        e._ =
        e.KeywordCxt =
        e.Ajv =
          void 0);
    const r = ff,
      a = ql,
      n = wc,
      s = KE,
      o = ["/properties"],
      i = "http://json-schema.org/draft-07/schema";
    class l extends r.default {
      _addVocabularies() {
        super._addVocabularies(),
          a.default.forEach((p) => this.addVocabulary(p)),
          this.opts.discriminator && this.addKeyword(n.default);
      }
      _addDefaultMetaSchema() {
        if ((super._addDefaultMetaSchema(), !this.opts.meta)) return;
        const p = this.opts.$data ? this.$dataMetaSchema(s, o) : s;
        this.addMetaSchema(p, i, !1),
          (this.refs["http://json-schema.org/schema"] = i);
      }
      defaultMeta() {
        return (this.opts.defaultMeta =
          super.defaultMeta() || (this.getSchema(i) ? i : void 0));
      }
    }
    (e.Ajv = l),
      (t.exports = e = l),
      (t.exports.Ajv = l),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      (e.default = l);
    var c = gr;
    Object.defineProperty(e, "KeywordCxt", {
      enumerable: !0,
      get: function () {
        return c.KeywordCxt;
      },
    });
    var u = Ne;
    Object.defineProperty(e, "_", {
      enumerable: !0,
      get: function () {
        return u._;
      },
    }),
      Object.defineProperty(e, "str", {
        enumerable: !0,
        get: function () {
          return u.str;
        },
      }),
      Object.defineProperty(e, "stringify", {
        enumerable: !0,
        get: function () {
          return u.stringify;
        },
      }),
      Object.defineProperty(e, "nil", {
        enumerable: !0,
        get: function () {
          return u.nil;
        },
      }),
      Object.defineProperty(e, "Name", {
        enumerable: !0,
        get: function () {
          return u.Name;
        },
      }),
      Object.defineProperty(e, "CodeGen", {
        enumerable: !0,
        get: function () {
          return u.CodeGen;
        },
      });
    var f = Qa;
    Object.defineProperty(e, "ValidationError", {
      enumerable: !0,
      get: function () {
        return f.default;
      },
    });
    var v = la;
    Object.defineProperty(e, "MissingRefError", {
      enumerable: !0,
      get: function () {
        return v.default;
      },
    });
  })(yl, yl.exports);
  var GE = yl.exports;
  const WE = df(GE);
  var Le;
  (function (t) {
    t.assertEqual = (n) => {};
    function e(n) {}
    t.assertIs = e;
    function r(n) {
      throw new Error();
    }
    (t.assertNever = r),
      (t.arrayToEnum = (n) => {
        const s = {};
        for (const o of n) s[o] = o;
        return s;
      }),
      (t.getValidEnumValues = (n) => {
        const s = t.objectKeys(n).filter((i) => typeof n[n[i]] != "number"),
          o = {};
        for (const i of s) o[i] = n[i];
        return t.objectValues(o);
      }),
      (t.objectValues = (n) =>
        t.objectKeys(n).map(function (s) {
          return n[s];
        })),
      (t.objectKeys =
        typeof Object.keys == "function"
          ? (n) => Object.keys(n)
          : (n) => {
              const s = [];
              for (const o in n)
                Object.prototype.hasOwnProperty.call(n, o) && s.push(o);
              return s;
            }),
      (t.find = (n, s) => {
        for (const o of n) if (s(o)) return o;
      }),
      (t.isInteger =
        typeof Number.isInteger == "function"
          ? (n) => Number.isInteger(n)
          : (n) =>
              typeof n == "number" &&
              Number.isFinite(n) &&
              Math.floor(n) === n);
    function a(n, s = " | ") {
      return n.map((o) => (typeof o == "string" ? `'${o}'` : o)).join(s);
    }
    (t.joinValues = a),
      (t.jsonStringifyReplacer = (n, s) =>
        typeof s == "bigint" ? s.toString() : s);
  })(Le || (Le = {}));
  var Ec;
  (function (t) {
    t.mergeShapes = (e, r) => ({ ...e, ...r });
  })(Ec || (Ec = {}));
  const ie = Le.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set",
    ]),
    en = (t) => {
      switch (typeof t) {
        case "undefined":
          return ie.undefined;
        case "string":
          return ie.string;
        case "number":
          return Number.isNaN(t) ? ie.nan : ie.number;
        case "boolean":
          return ie.boolean;
        case "function":
          return ie.function;
        case "bigint":
          return ie.bigint;
        case "symbol":
          return ie.symbol;
        case "object":
          return Array.isArray(t)
            ? ie.array
            : t === null
            ? ie.null
            : t.then &&
              typeof t.then == "function" &&
              t.catch &&
              typeof t.catch == "function"
            ? ie.promise
            : typeof Map < "u" && t instanceof Map
            ? ie.map
            : typeof Set < "u" && t instanceof Set
            ? ie.set
            : typeof Date < "u" && t instanceof Date
            ? ie.date
            : ie.object;
        default:
          return ie.unknown;
      }
    },
    Y = Le.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite",
    ]),
    QE = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
  class er extends Error {
    get errors() {
      return this.issues;
    }
    constructor(e) {
      super(),
        (this.issues = []),
        (this.addIssue = (a) => {
          this.issues = [...this.issues, a];
        }),
        (this.addIssues = (a = []) => {
          this.issues = [...this.issues, ...a];
        });
      const r = new.target.prototype;
      Object.setPrototypeOf
        ? Object.setPrototypeOf(this, r)
        : (this.__proto__ = r),
        (this.name = "ZodError"),
        (this.issues = e);
    }
    format(e) {
      const r =
          e ||
          function (s) {
            return s.message;
          },
        a = { _errors: [] },
        n = (s) => {
          for (const o of s.issues)
            if (o.code === "invalid_union") o.unionErrors.map(n);
            else if (o.code === "invalid_return_type") n(o.returnTypeError);
            else if (o.code === "invalid_arguments") n(o.argumentsError);
            else if (o.path.length === 0) a._errors.push(r(o));
            else {
              let i = a,
                l = 0;
              for (; l < o.path.length; ) {
                const c = o.path[l];
                l === o.path.length - 1
                  ? ((i[c] = i[c] || { _errors: [] }), i[c]._errors.push(r(o)))
                  : (i[c] = i[c] || { _errors: [] }),
                  (i = i[c]),
                  l++;
              }
            }
        };
      return n(this), a;
    }
    static assert(e) {
      if (!(e instanceof er)) throw new Error(`Not a ZodError: ${e}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, Le.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(e = (r) => r.message) {
      const r = {},
        a = [];
      for (const n of this.issues)
        if (n.path.length > 0) {
          const s = n.path[0];
          (r[s] = r[s] || []), r[s].push(e(n));
        } else a.push(e(n));
      return { formErrors: a, fieldErrors: r };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  er.create = (t) => new er(t);
  const ha = (t, e) => {
    let r;
    switch (t.code) {
      case Y.invalid_type:
        t.received === ie.undefined
          ? (r = "Required")
          : (r = `Expected ${t.expected}, received ${t.received}`);
        break;
      case Y.invalid_literal:
        r = `Invalid literal value, expected ${JSON.stringify(
          t.expected,
          Le.jsonStringifyReplacer
        )}`;
        break;
      case Y.unrecognized_keys:
        r = `Unrecognized key(s) in object: ${Le.joinValues(t.keys, ", ")}`;
        break;
      case Y.invalid_union:
        r = "Invalid input";
        break;
      case Y.invalid_union_discriminator:
        r = `Invalid discriminator value. Expected ${Le.joinValues(t.options)}`;
        break;
      case Y.invalid_enum_value:
        r = `Invalid enum value. Expected ${Le.joinValues(
          t.options
        )}, received '${t.received}'`;
        break;
      case Y.invalid_arguments:
        r = "Invalid function arguments";
        break;
      case Y.invalid_return_type:
        r = "Invalid function return type";
        break;
      case Y.invalid_date:
        r = "Invalid date";
        break;
      case Y.invalid_string:
        typeof t.validation == "object"
          ? "includes" in t.validation
            ? ((r = `Invalid input: must include "${t.validation.includes}"`),
              typeof t.validation.position == "number" &&
                (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`))
            : "startsWith" in t.validation
            ? (r = `Invalid input: must start with "${t.validation.startsWith}"`)
            : "endsWith" in t.validation
            ? (r = `Invalid input: must end with "${t.validation.endsWith}"`)
            : Le.assertNever(t.validation)
          : t.validation !== "regex"
          ? (r = `Invalid ${t.validation}`)
          : (r = "Invalid");
        break;
      case Y.too_small:
        t.type === "array"
          ? (r = `Array must contain ${
              t.exact ? "exactly" : t.inclusive ? "at least" : "more than"
            } ${t.minimum} element(s)`)
          : t.type === "string"
          ? (r = `String must contain ${
              t.exact ? "exactly" : t.inclusive ? "at least" : "over"
            } ${t.minimum} character(s)`)
          : t.type === "number"
          ? (r = `Number must be ${
              t.exact
                ? "exactly equal to "
                : t.inclusive
                ? "greater than or equal to "
                : "greater than "
            }${t.minimum}`)
          : t.type === "bigint"
          ? (r = `Number must be ${
              t.exact
                ? "exactly equal to "
                : t.inclusive
                ? "greater than or equal to "
                : "greater than "
            }${t.minimum}`)
          : t.type === "date"
          ? (r = `Date must be ${
              t.exact
                ? "exactly equal to "
                : t.inclusive
                ? "greater than or equal to "
                : "greater than "
            }${new Date(Number(t.minimum))}`)
          : (r = "Invalid input");
        break;
      case Y.too_big:
        t.type === "array"
          ? (r = `Array must contain ${
              t.exact ? "exactly" : t.inclusive ? "at most" : "less than"
            } ${t.maximum} element(s)`)
          : t.type === "string"
          ? (r = `String must contain ${
              t.exact ? "exactly" : t.inclusive ? "at most" : "under"
            } ${t.maximum} character(s)`)
          : t.type === "number"
          ? (r = `Number must be ${
              t.exact
                ? "exactly"
                : t.inclusive
                ? "less than or equal to"
                : "less than"
            } ${t.maximum}`)
          : t.type === "bigint"
          ? (r = `BigInt must be ${
              t.exact
                ? "exactly"
                : t.inclusive
                ? "less than or equal to"
                : "less than"
            } ${t.maximum}`)
          : t.type === "date"
          ? (r = `Date must be ${
              t.exact
                ? "exactly"
                : t.inclusive
                ? "smaller than or equal to"
                : "smaller than"
            } ${new Date(Number(t.maximum))}`)
          : (r = "Invalid input");
        break;
      case Y.custom:
        r = "Invalid input";
        break;
      case Y.invalid_intersection_types:
        r = "Intersection results could not be merged";
        break;
      case Y.not_multiple_of:
        r = `Number must be a multiple of ${t.multipleOf}`;
        break;
      case Y.not_finite:
        r = "Number must be finite";
        break;
      default:
        (r = e.defaultError), Le.assertNever(t);
    }
    return { message: r };
  };
  let Ap = ha;
  function YE(t) {
    Ap = t;
  }
  function Uo() {
    return Ap;
  }
  const Fo = (t) => {
      const { data: e, path: r, errorMaps: a, issueData: n } = t,
        s = [...r, ...(n.path || [])],
        o = { ...n, path: s };
      if (n.message !== void 0) return { ...n, path: s, message: n.message };
      let i = "";
      const l = a
        .filter((c) => !!c)
        .slice()
        .reverse();
      for (const c of l) i = c(o, { data: e, defaultError: i }).message;
      return { ...n, path: s, message: i };
    },
    XE = [];
  function ne(t, e) {
    const r = Uo(),
      a = Fo({
        issueData: e,
        data: t.data,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          r,
          r === ha ? void 0 : ha,
        ].filter((n) => !!n),
      });
    t.common.issues.push(a);
  }
  class Mt {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(e, r) {
      const a = [];
      for (const n of r) {
        if (n.status === "aborted") return Ee;
        n.status === "dirty" && e.dirty(), a.push(n.value);
      }
      return { status: e.value, value: a };
    }
    static async mergeObjectAsync(e, r) {
      const a = [];
      for (const n of r) {
        const s = await n.key,
          o = await n.value;
        a.push({ key: s, value: o });
      }
      return Mt.mergeObjectSync(e, a);
    }
    static mergeObjectSync(e, r) {
      const a = {};
      for (const n of r) {
        const { key: s, value: o } = n;
        if (s.status === "aborted" || o.status === "aborted") return Ee;
        s.status === "dirty" && e.dirty(),
          o.status === "dirty" && e.dirty(),
          s.value !== "__proto__" &&
            (typeof o.value < "u" || n.alwaysSet) &&
            (a[s.value] = o.value);
      }
      return { status: e.value, value: a };
    }
  }
  const Ee = Object.freeze({ status: "aborted" }),
    ma = (t) => ({ status: "dirty", value: t }),
    qt = (t) => ({ status: "valid", value: t }),
    Sc = (t) => t.status === "aborted",
    $c = (t) => t.status === "dirty",
    jn = (t) => t.status === "valid",
    os = (t) => typeof Promise < "u" && t instanceof Promise;
  var pe;
  (function (t) {
    (t.errToObj = (e) => (typeof e == "string" ? { message: e } : e || {})),
      (t.toString = (e) =>
        typeof e == "string" ? e : e == null ? void 0 : e.message);
  })(pe || (pe = {}));
  class Mr {
    constructor(e, r, a, n) {
      (this._cachedPath = []),
        (this.parent = e),
        (this.data = r),
        (this._path = a),
        (this._key = n);
    }
    get path() {
      return (
        this._cachedPath.length ||
          (Array.isArray(this._key)
            ? this._cachedPath.push(...this._path, ...this._key)
            : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
      );
    }
  }
  const Np = (t, e) => {
    if (jn(e)) return { success: !0, data: e.value };
    if (!t.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error) return this._error;
        const r = new er(t.common.issues);
        return (this._error = r), this._error;
      },
    };
  };
  function Ce(t) {
    if (!t) return {};
    const {
      errorMap: e,
      invalid_type_error: r,
      required_error: a,
      description: n,
    } = t;
    if (e && (r || a))
      throw new Error(
        `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
      );
    return e
      ? { errorMap: e, description: n }
      : {
          errorMap: (o, i) => {
            const { message: l } = t;
            return o.code === "invalid_enum_value"
              ? { message: l ?? i.defaultError }
              : typeof i.data > "u"
              ? { message: l ?? a ?? i.defaultError }
              : o.code !== "invalid_type"
              ? { message: i.defaultError }
              : { message: l ?? r ?? i.defaultError };
          },
          description: n,
        };
  }
  let Oe = class {
    get description() {
      return this._def.description;
    }
    _getType(e) {
      return en(e.data);
    }
    _getOrReturnCtx(e, r) {
      return (
        r || {
          common: e.parent.common,
          data: e.data,
          parsedType: en(e.data),
          schemaErrorMap: this._def.errorMap,
          path: e.path,
          parent: e.parent,
        }
      );
    }
    _processInputParams(e) {
      return {
        status: new Mt(),
        ctx: {
          common: e.parent.common,
          data: e.data,
          parsedType: en(e.data),
          schemaErrorMap: this._def.errorMap,
          path: e.path,
          parent: e.parent,
        },
      };
    }
    _parseSync(e) {
      const r = this._parse(e);
      if (os(r)) throw new Error("Synchronous parse encountered promise.");
      return r;
    }
    _parseAsync(e) {
      const r = this._parse(e);
      return Promise.resolve(r);
    }
    parse(e, r) {
      const a = this.safeParse(e, r);
      if (a.success) return a.data;
      throw a.error;
    }
    safeParse(e, r) {
      const a = {
          common: {
            issues: [],
            async: (r == null ? void 0 : r.async) ?? !1,
            contextualErrorMap: r == null ? void 0 : r.errorMap,
          },
          path: (r == null ? void 0 : r.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: e,
          parsedType: en(e),
        },
        n = this._parseSync({ data: e, path: a.path, parent: a });
      return Np(a, n);
    }
    "~validate"(e) {
      var a, n;
      const r = {
        common: { issues: [], async: !!this["~standard"].async },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: en(e),
      };
      if (!this["~standard"].async)
        try {
          const s = this._parseSync({ data: e, path: [], parent: r });
          return jn(s) ? { value: s.value } : { issues: r.common.issues };
        } catch (s) {
          (n =
            (a = s == null ? void 0 : s.message) == null
              ? void 0
              : a.toLowerCase()) != null &&
            n.includes("encountered") &&
            (this["~standard"].async = !0),
            (r.common = { issues: [], async: !0 });
        }
      return this._parseAsync({ data: e, path: [], parent: r }).then((s) =>
        jn(s) ? { value: s.value } : { issues: r.common.issues }
      );
    }
    async parseAsync(e, r) {
      const a = await this.safeParseAsync(e, r);
      if (a.success) return a.data;
      throw a.error;
    }
    async safeParseAsync(e, r) {
      const a = {
          common: {
            issues: [],
            contextualErrorMap: r == null ? void 0 : r.errorMap,
            async: !0,
          },
          path: (r == null ? void 0 : r.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: e,
          parsedType: en(e),
        },
        n = this._parse({ data: e, path: a.path, parent: a }),
        s = await (os(n) ? n : Promise.resolve(n));
      return Np(a, s);
    }
    refine(e, r) {
      const a = (n) =>
        typeof r == "string" || typeof r > "u"
          ? { message: r }
          : typeof r == "function"
          ? r(n)
          : r;
      return this._refinement((n, s) => {
        const o = e(n),
          i = () => s.addIssue({ code: Y.custom, ...a(n) });
        return typeof Promise < "u" && o instanceof Promise
          ? o.then((l) => (l ? !0 : (i(), !1)))
          : o
          ? !0
          : (i(), !1);
      });
    }
    refinement(e, r) {
      return this._refinement((a, n) =>
        e(a) ? !0 : (n.addIssue(typeof r == "function" ? r(a, n) : r), !1)
      );
    }
    _refinement(e) {
      return new br({
        schema: this,
        typeName: X.ZodEffects,
        effect: { type: "refinement", refinement: e },
      });
    }
    superRefine(e) {
      return this._refinement(e);
    }
    constructor(e) {
      (this.spa = this.safeParseAsync),
        (this._def = e),
        (this.parse = this.parse.bind(this)),
        (this.safeParse = this.safeParse.bind(this)),
        (this.parseAsync = this.parseAsync.bind(this)),
        (this.safeParseAsync = this.safeParseAsync.bind(this)),
        (this.spa = this.spa.bind(this)),
        (this.refine = this.refine.bind(this)),
        (this.refinement = this.refinement.bind(this)),
        (this.superRefine = this.superRefine.bind(this)),
        (this.optional = this.optional.bind(this)),
        (this.nullable = this.nullable.bind(this)),
        (this.nullish = this.nullish.bind(this)),
        (this.array = this.array.bind(this)),
        (this.promise = this.promise.bind(this)),
        (this.or = this.or.bind(this)),
        (this.and = this.and.bind(this)),
        (this.transform = this.transform.bind(this)),
        (this.brand = this.brand.bind(this)),
        (this.default = this.default.bind(this)),
        (this.catch = this.catch.bind(this)),
        (this.describe = this.describe.bind(this)),
        (this.pipe = this.pipe.bind(this)),
        (this.readonly = this.readonly.bind(this)),
        (this.isNullable = this.isNullable.bind(this)),
        (this.isOptional = this.isOptional.bind(this)),
        (this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (r) => this["~validate"](r),
        });
    }
    optional() {
      return Dr.create(this, this._def);
    }
    nullable() {
      return hn.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return zn.create(this);
    }
    promise() {
      return wa.create(this, this._def);
    }
    or(e) {
      return ds.create([this, e], this._def);
    }
    and(e) {
      return fs.create(this, e, this._def);
    }
    transform(e) {
      return new br({
        ...Ce(this._def),
        schema: this,
        typeName: X.ZodEffects,
        effect: { type: "transform", transform: e },
      });
    }
    default(e) {
      const r = typeof e == "function" ? e : () => e;
      return new gs({
        ...Ce(this._def),
        innerType: this,
        defaultValue: r,
        typeName: X.ZodDefault,
      });
    }
    brand() {
      return new xc({ typeName: X.ZodBranded, type: this, ...Ce(this._def) });
    }
    catch(e) {
      const r = typeof e == "function" ? e : () => e;
      return new ys({
        ...Ce(this._def),
        innerType: this,
        catchValue: r,
        typeName: X.ZodCatch,
      });
    }
    describe(e) {
      const r = this.constructor;
      return new r({ ...this._def, description: e });
    }
    pipe(e) {
      return _s.create(this, e);
    }
    readonly() {
      return ws.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  const eS = /^c[^\s-]{8,}$/i,
    tS = /^[0-9a-z]+$/,
    rS = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
    nS =
      /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
    aS = /^[a-z0-9_-]{21}$/i,
    sS = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
    oS =
      /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
    iS =
      /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
    lS = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
  let Pc;
  const cS =
      /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    uS =
      /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    dS =
      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
    fS =
      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    pS = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    hS =
      /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    Mp =
      "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
    mS = new RegExp(`^${Mp}$`);
  function jp(t) {
    let e = "[0-5]\\d";
    t.precision
      ? (e = `${e}\\.\\d{${t.precision}}`)
      : t.precision == null && (e = `${e}(\\.\\d+)?`);
    const r = t.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${r}`;
  }
  function vS(t) {
    return new RegExp(`^${jp(t)}$`);
  }
  function Dp(t) {
    let e = `${Mp}T${jp(t)}`;
    const r = [];
    return (
      r.push(t.local ? "Z?" : "Z"),
      t.offset && r.push("([+-]\\d{2}:?\\d{2})"),
      (e = `${e}(${r.join("|")})`),
      new RegExp(`^${e}$`)
    );
  }
  function gS(t, e) {
    return !!(
      ((e === "v4" || !e) && cS.test(t)) ||
      ((e === "v6" || !e) && dS.test(t))
    );
  }
  function yS(t, e) {
    if (!sS.test(t)) return !1;
    try {
      const [r] = t.split(".");
      if (!r) return !1;
      const a = r
          .replace(/-/g, "+")
          .replace(/_/g, "/")
          .padEnd(r.length + ((4 - (r.length % 4)) % 4), "="),
        n = JSON.parse(atob(a));
      return !(
        typeof n != "object" ||
        n === null ||
        ("typ" in n && (n == null ? void 0 : n.typ) !== "JWT") ||
        !n.alg ||
        (e && n.alg !== e)
      );
    } catch {
      return !1;
    }
  }
  function _S(t, e) {
    return !!(
      ((e === "v4" || !e) && uS.test(t)) ||
      ((e === "v6" || !e) && fS.test(t))
    );
  }
  let va = class yo extends Oe {
    _parse(e) {
      if (
        (this._def.coerce && (e.data = String(e.data)),
        this._getType(e) !== ie.string)
      ) {
        const s = this._getOrReturnCtx(e);
        return (
          ne(s, {
            code: Y.invalid_type,
            expected: ie.string,
            received: s.parsedType,
          }),
          Ee
        );
      }
      const a = new Mt();
      let n;
      for (const s of this._def.checks)
        if (s.kind === "min")
          e.data.length < s.value &&
            ((n = this._getOrReturnCtx(e, n)),
            ne(n, {
              code: Y.too_small,
              minimum: s.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: s.message,
            }),
            a.dirty());
        else if (s.kind === "max")
          e.data.length > s.value &&
            ((n = this._getOrReturnCtx(e, n)),
            ne(n, {
              code: Y.too_big,
              maximum: s.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: s.message,
            }),
            a.dirty());
        else if (s.kind === "length") {
          const o = e.data.length > s.value,
            i = e.data.length < s.value;
          (o || i) &&
            ((n = this._getOrReturnCtx(e, n)),
            o
              ? ne(n, {
                  code: Y.too_big,
                  maximum: s.value,
                  type: "string",
                  inclusive: !0,
                  exact: !0,
                  message: s.message,
                })
              : i &&
                ne(n, {
                  code: Y.too_small,
                  minimum: s.value,
                  type: "string",
                  inclusive: !0,
                  exact: !0,
                  message: s.message,
                }),
            a.dirty());
        } else if (s.kind === "email")
          iS.test(e.data) ||
            ((n = this._getOrReturnCtx(e, n)),
            ne(n, {
              validation: "email",
              code: Y.invalid_string,
              message: s.message,
            }),
            a.dirty());
        else if (s.kind === "emoji")
          Pc || (Pc = new RegExp(lS, "u")),
            Pc.test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                validation: "emoji",
                code: Y.invalid_string,
                message: s.message,
              }),
              a.dirty());
        else if (s.kind === "uuid")
          nS.test(e.data) ||
            ((n = this._getOrReturnCtx(e, n)),
            ne(n, {
              validation: "uuid",
              code: Y.invalid_string,
              message: s.message,
            }),
            a.dirty());
        else if (s.kind === "nanoid")
          aS.test(e.data) ||
            ((n = this._getOrReturnCtx(e, n)),
            ne(n, {
              validation: "nanoid",
              code: Y.invalid_string,
              message: s.message,
            }),
            a.dirty());
        else if (s.kind === "cuid")
          eS.test(e.data) ||
            ((n = this._getOrReturnCtx(e, n)),
            ne(n, {
              validation: "cuid",
              code: Y.invalid_string,
              message: s.message,
            }),
            a.dirty());
        else if (s.kind === "cuid2")
          tS.test(e.data) ||
            ((n = this._getOrReturnCtx(e, n)),
            ne(n, {
              validation: "cuid2",
              code: Y.invalid_string,
              message: s.message,
            }),
            a.dirty());
        else if (s.kind === "ulid")
          rS.test(e.data) ||
            ((n = this._getOrReturnCtx(e, n)),
            ne(n, {
              validation: "ulid",
              code: Y.invalid_string,
              message: s.message,
            }),
            a.dirty());
        else if (s.kind === "url")
          try {
            new URL(e.data);
          } catch {
            (n = this._getOrReturnCtx(e, n)),
              ne(n, {
                validation: "url",
                code: Y.invalid_string,
                message: s.message,
              }),
              a.dirty();
          }
        else
          s.kind === "regex"
            ? ((s.regex.lastIndex = 0),
              s.regex.test(e.data) ||
                ((n = this._getOrReturnCtx(e, n)),
                ne(n, {
                  validation: "regex",
                  code: Y.invalid_string,
                  message: s.message,
                }),
                a.dirty()))
            : s.kind === "trim"
            ? (e.data = e.data.trim())
            : s.kind === "includes"
            ? e.data.includes(s.value, s.position) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                code: Y.invalid_string,
                validation: { includes: s.value, position: s.position },
                message: s.message,
              }),
              a.dirty())
            : s.kind === "toLowerCase"
            ? (e.data = e.data.toLowerCase())
            : s.kind === "toUpperCase"
            ? (e.data = e.data.toUpperCase())
            : s.kind === "startsWith"
            ? e.data.startsWith(s.value) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                code: Y.invalid_string,
                validation: { startsWith: s.value },
                message: s.message,
              }),
              a.dirty())
            : s.kind === "endsWith"
            ? e.data.endsWith(s.value) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                code: Y.invalid_string,
                validation: { endsWith: s.value },
                message: s.message,
              }),
              a.dirty())
            : s.kind === "datetime"
            ? Dp(s).test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                code: Y.invalid_string,
                validation: "datetime",
                message: s.message,
              }),
              a.dirty())
            : s.kind === "date"
            ? mS.test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                code: Y.invalid_string,
                validation: "date",
                message: s.message,
              }),
              a.dirty())
            : s.kind === "time"
            ? vS(s).test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                code: Y.invalid_string,
                validation: "time",
                message: s.message,
              }),
              a.dirty())
            : s.kind === "duration"
            ? oS.test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                validation: "duration",
                code: Y.invalid_string,
                message: s.message,
              }),
              a.dirty())
            : s.kind === "ip"
            ? gS(e.data, s.version) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                validation: "ip",
                code: Y.invalid_string,
                message: s.message,
              }),
              a.dirty())
            : s.kind === "jwt"
            ? yS(e.data, s.alg) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                validation: "jwt",
                code: Y.invalid_string,
                message: s.message,
              }),
              a.dirty())
            : s.kind === "cidr"
            ? _S(e.data, s.version) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                validation: "cidr",
                code: Y.invalid_string,
                message: s.message,
              }),
              a.dirty())
            : s.kind === "base64"
            ? pS.test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                validation: "base64",
                code: Y.invalid_string,
                message: s.message,
              }),
              a.dirty())
            : s.kind === "base64url"
            ? hS.test(e.data) ||
              ((n = this._getOrReturnCtx(e, n)),
              ne(n, {
                validation: "base64url",
                code: Y.invalid_string,
                message: s.message,
              }),
              a.dirty())
            : Le.assertNever(s);
      return { status: a.value, value: e.data };
    }
    _regex(e, r, a) {
      return this.refinement((n) => e.test(n), {
        validation: r,
        code: Y.invalid_string,
        ...pe.errToObj(a),
      });
    }
    _addCheck(e) {
      return new yo({ ...this._def, checks: [...this._def.checks, e] });
    }
    email(e) {
      return this._addCheck({ kind: "email", ...pe.errToObj(e) });
    }
    url(e) {
      return this._addCheck({ kind: "url", ...pe.errToObj(e) });
    }
    emoji(e) {
      return this._addCheck({ kind: "emoji", ...pe.errToObj(e) });
    }
    uuid(e) {
      return this._addCheck({ kind: "uuid", ...pe.errToObj(e) });
    }
    nanoid(e) {
      return this._addCheck({ kind: "nanoid", ...pe.errToObj(e) });
    }
    cuid(e) {
      return this._addCheck({ kind: "cuid", ...pe.errToObj(e) });
    }
    cuid2(e) {
      return this._addCheck({ kind: "cuid2", ...pe.errToObj(e) });
    }
    ulid(e) {
      return this._addCheck({ kind: "ulid", ...pe.errToObj(e) });
    }
    base64(e) {
      return this._addCheck({ kind: "base64", ...pe.errToObj(e) });
    }
    base64url(e) {
      return this._addCheck({ kind: "base64url", ...pe.errToObj(e) });
    }
    jwt(e) {
      return this._addCheck({ kind: "jwt", ...pe.errToObj(e) });
    }
    ip(e) {
      return this._addCheck({ kind: "ip", ...pe.errToObj(e) });
    }
    cidr(e) {
      return this._addCheck({ kind: "cidr", ...pe.errToObj(e) });
    }
    datetime(e) {
      return typeof e == "string"
        ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: e,
          })
        : this._addCheck({
            kind: "datetime",
            precision:
              typeof (e == null ? void 0 : e.precision) > "u"
                ? null
                : e == null
                ? void 0
                : e.precision,
            offset: (e == null ? void 0 : e.offset) ?? !1,
            local: (e == null ? void 0 : e.local) ?? !1,
            ...pe.errToObj(e == null ? void 0 : e.message),
          });
    }
    date(e) {
      return this._addCheck({ kind: "date", message: e });
    }
    time(e) {
      return typeof e == "string"
        ? this._addCheck({ kind: "time", precision: null, message: e })
        : this._addCheck({
            kind: "time",
            precision:
              typeof (e == null ? void 0 : e.precision) > "u"
                ? null
                : e == null
                ? void 0
                : e.precision,
            ...pe.errToObj(e == null ? void 0 : e.message),
          });
    }
    duration(e) {
      return this._addCheck({ kind: "duration", ...pe.errToObj(e) });
    }
    regex(e, r) {
      return this._addCheck({ kind: "regex", regex: e, ...pe.errToObj(r) });
    }
    includes(e, r) {
      return this._addCheck({
        kind: "includes",
        value: e,
        position: r == null ? void 0 : r.position,
        ...pe.errToObj(r == null ? void 0 : r.message),
      });
    }
    startsWith(e, r) {
      return this._addCheck({
        kind: "startsWith",
        value: e,
        ...pe.errToObj(r),
      });
    }
    endsWith(e, r) {
      return this._addCheck({ kind: "endsWith", value: e, ...pe.errToObj(r) });
    }
    min(e, r) {
      return this._addCheck({ kind: "min", value: e, ...pe.errToObj(r) });
    }
    max(e, r) {
      return this._addCheck({ kind: "max", value: e, ...pe.errToObj(r) });
    }
    length(e, r) {
      return this._addCheck({ kind: "length", value: e, ...pe.errToObj(r) });
    }
    nonempty(e) {
      return this.min(1, pe.errToObj(e));
    }
    trim() {
      return new yo({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }],
      });
    }
    toLowerCase() {
      return new yo({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }],
      });
    }
    toUpperCase() {
      return new yo({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }],
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((e) => e.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((e) => e.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((e) => e.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((e) => e.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((e) => e.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((e) => e.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((e) => e.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((e) => e.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((e) => e.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((e) => e.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((e) => e.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((e) => e.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((e) => e.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((e) => e.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((e) => e.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((e) => e.kind === "base64url");
    }
    get minLength() {
      let e = null;
      for (const r of this._def.checks)
        r.kind === "min" && (e === null || r.value > e) && (e = r.value);
      return e;
    }
    get maxLength() {
      let e = null;
      for (const r of this._def.checks)
        r.kind === "max" && (e === null || r.value < e) && (e = r.value);
      return e;
    }
  };
  va.create = (t) =>
    new va({
      checks: [],
      typeName: X.ZodString,
      coerce: (t == null ? void 0 : t.coerce) ?? !1,
      ...Ce(t),
    });
  function wS(t, e) {
    const r = (t.toString().split(".")[1] || "").length,
      a = (e.toString().split(".")[1] || "").length,
      n = r > a ? r : a,
      s = Number.parseInt(t.toFixed(n).replace(".", "")),
      o = Number.parseInt(e.toFixed(n).replace(".", ""));
    return (s % o) / 10 ** n;
  }
  let is = class of extends Oe {
    constructor() {
      super(...arguments),
        (this.min = this.gte),
        (this.max = this.lte),
        (this.step = this.multipleOf);
    }
    _parse(e) {
      if (
        (this._def.coerce && (e.data = Number(e.data)),
        this._getType(e) !== ie.number)
      ) {
        const s = this._getOrReturnCtx(e);
        return (
          ne(s, {
            code: Y.invalid_type,
            expected: ie.number,
            received: s.parsedType,
          }),
          Ee
        );
      }
      let a;
      const n = new Mt();
      for (const s of this._def.checks)
        s.kind === "int"
          ? Le.isInteger(e.data) ||
            ((a = this._getOrReturnCtx(e, a)),
            ne(a, {
              code: Y.invalid_type,
              expected: "integer",
              received: "float",
              message: s.message,
            }),
            n.dirty())
          : s.kind === "min"
          ? (s.inclusive ? e.data < s.value : e.data <= s.value) &&
            ((a = this._getOrReturnCtx(e, a)),
            ne(a, {
              code: Y.too_small,
              minimum: s.value,
              type: "number",
              inclusive: s.inclusive,
              exact: !1,
              message: s.message,
            }),
            n.dirty())
          : s.kind === "max"
          ? (s.inclusive ? e.data > s.value : e.data >= s.value) &&
            ((a = this._getOrReturnCtx(e, a)),
            ne(a, {
              code: Y.too_big,
              maximum: s.value,
              type: "number",
              inclusive: s.inclusive,
              exact: !1,
              message: s.message,
            }),
            n.dirty())
          : s.kind === "multipleOf"
          ? wS(e.data, s.value) !== 0 &&
            ((a = this._getOrReturnCtx(e, a)),
            ne(a, {
              code: Y.not_multiple_of,
              multipleOf: s.value,
              message: s.message,
            }),
            n.dirty())
          : s.kind === "finite"
          ? Number.isFinite(e.data) ||
            ((a = this._getOrReturnCtx(e, a)),
            ne(a, { code: Y.not_finite, message: s.message }),
            n.dirty())
          : Le.assertNever(s);
      return { status: n.value, value: e.data };
    }
    gte(e, r) {
      return this.setLimit("min", e, !0, pe.toString(r));
    }
    gt(e, r) {
      return this.setLimit("min", e, !1, pe.toString(r));
    }
    lte(e, r) {
      return this.setLimit("max", e, !0, pe.toString(r));
    }
    lt(e, r) {
      return this.setLimit("max", e, !1, pe.toString(r));
    }
    setLimit(e, r, a, n) {
      return new of({
        ...this._def,
        checks: [
          ...this._def.checks,
          { kind: e, value: r, inclusive: a, message: pe.toString(n) },
        ],
      });
    }
    _addCheck(e) {
      return new of({ ...this._def, checks: [...this._def.checks, e] });
    }
    int(e) {
      return this._addCheck({ kind: "int", message: pe.toString(e) });
    }
    positive(e) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: pe.toString(e),
      });
    }
    negative(e) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: pe.toString(e),
      });
    }
    nonpositive(e) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: pe.toString(e),
      });
    }
    nonnegative(e) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: pe.toString(e),
      });
    }
    multipleOf(e, r) {
      return this._addCheck({
        kind: "multipleOf",
        value: e,
        message: pe.toString(r),
      });
    }
    finite(e) {
      return this._addCheck({ kind: "finite", message: pe.toString(e) });
    }
    safe(e) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: pe.toString(e),
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: pe.toString(e),
      });
    }
    get minValue() {
      let e = null;
      for (const r of this._def.checks)
        r.kind === "min" && (e === null || r.value > e) && (e = r.value);
      return e;
    }
    get maxValue() {
      let e = null;
      for (const r of this._def.checks)
        r.kind === "max" && (e === null || r.value < e) && (e = r.value);
      return e;
    }
    get isInt() {
      return !!this._def.checks.find(
        (e) =>
          e.kind === "int" || (e.kind === "multipleOf" && Le.isInteger(e.value))
      );
    }
    get isFinite() {
      let e = null,
        r = null;
      for (const a of this._def.checks) {
        if (a.kind === "finite" || a.kind === "int" || a.kind === "multipleOf")
          return !0;
        a.kind === "min"
          ? (r === null || a.value > r) && (r = a.value)
          : a.kind === "max" && (e === null || a.value < e) && (e = a.value);
      }
      return Number.isFinite(r) && Number.isFinite(e);
    }
  };
  is.create = (t) =>
    new is({
      checks: [],
      typeName: X.ZodNumber,
      coerce: (t == null ? void 0 : t.coerce) || !1,
      ...Ce(t),
    });
  class pn extends Oe {
    constructor() {
      super(...arguments), (this.min = this.gte), (this.max = this.lte);
    }
    _parse(e) {
      if (this._def.coerce)
        try {
          e.data = BigInt(e.data);
        } catch {
          return this._getInvalidInput(e);
        }
      if (this._getType(e) !== ie.bigint) return this._getInvalidInput(e);
      let a;
      const n = new Mt();
      for (const s of this._def.checks)
        s.kind === "min"
          ? (s.inclusive ? e.data < s.value : e.data <= s.value) &&
            ((a = this._getOrReturnCtx(e, a)),
            ne(a, {
              code: Y.too_small,
              type: "bigint",
              minimum: s.value,
              inclusive: s.inclusive,
              message: s.message,
            }),
            n.dirty())
          : s.kind === "max"
          ? (s.inclusive ? e.data > s.value : e.data >= s.value) &&
            ((a = this._getOrReturnCtx(e, a)),
            ne(a, {
              code: Y.too_big,
              type: "bigint",
              maximum: s.value,
              inclusive: s.inclusive,
              message: s.message,
            }),
            n.dirty())
          : s.kind === "multipleOf"
          ? e.data % s.value !== BigInt(0) &&
            ((a = this._getOrReturnCtx(e, a)),
            ne(a, {
              code: Y.not_multiple_of,
              multipleOf: s.value,
              message: s.message,
            }),
            n.dirty())
          : Le.assertNever(s);
      return { status: n.value, value: e.data };
    }
    _getInvalidInput(e) {
      const r = this._getOrReturnCtx(e);
      return (
        ne(r, {
          code: Y.invalid_type,
          expected: ie.bigint,
          received: r.parsedType,
        }),
        Ee
      );
    }
    gte(e, r) {
      return this.setLimit("min", e, !0, pe.toString(r));
    }
    gt(e, r) {
      return this.setLimit("min", e, !1, pe.toString(r));
    }
    lte(e, r) {
      return this.setLimit("max", e, !0, pe.toString(r));
    }
    lt(e, r) {
      return this.setLimit("max", e, !1, pe.toString(r));
    }
    setLimit(e, r, a, n) {
      return new pn({
        ...this._def,
        checks: [
          ...this._def.checks,
          { kind: e, value: r, inclusive: a, message: pe.toString(n) },
        ],
      });
    }
    _addCheck(e) {
      return new pn({ ...this._def, checks: [...this._def.checks, e] });
    }
    positive(e) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: pe.toString(e),
      });
    }
    negative(e) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: pe.toString(e),
      });
    }
    nonpositive(e) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: pe.toString(e),
      });
    }
    nonnegative(e) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: pe.toString(e),
      });
    }
    multipleOf(e, r) {
      return this._addCheck({
        kind: "multipleOf",
        value: e,
        message: pe.toString(r),
      });
    }
    get minValue() {
      let e = null;
      for (const r of this._def.checks)
        r.kind === "min" && (e === null || r.value > e) && (e = r.value);
      return e;
    }
    get maxValue() {
      let e = null;
      for (const r of this._def.checks)
        r.kind === "max" && (e === null || r.value < e) && (e = r.value);
      return e;
    }
  }
  pn.create = (t) =>
    new pn({
      checks: [],
      typeName: X.ZodBigInt,
      coerce: (t == null ? void 0 : t.coerce) ?? !1,
      ...Ce(t),
    });
  let ls = class extends Oe {
    _parse(e) {
      if (
        (this._def.coerce && (e.data = !!e.data),
        this._getType(e) !== ie.boolean)
      ) {
        const a = this._getOrReturnCtx(e);
        return (
          ne(a, {
            code: Y.invalid_type,
            expected: ie.boolean,
            received: a.parsedType,
          }),
          Ee
        );
      }
      return qt(e.data);
    }
  };
  ls.create = (t) =>
    new ls({
      typeName: X.ZodBoolean,
      coerce: (t == null ? void 0 : t.coerce) || !1,
      ...Ce(t),
    });
  class Dn extends Oe {
    _parse(e) {
      if (
        (this._def.coerce && (e.data = new Date(e.data)),
        this._getType(e) !== ie.date)
      ) {
        const s = this._getOrReturnCtx(e);
        return (
          ne(s, {
            code: Y.invalid_type,
            expected: ie.date,
            received: s.parsedType,
          }),
          Ee
        );
      }
      if (Number.isNaN(e.data.getTime())) {
        const s = this._getOrReturnCtx(e);
        return ne(s, { code: Y.invalid_date }), Ee;
      }
      const a = new Mt();
      let n;
      for (const s of this._def.checks)
        s.kind === "min"
          ? e.data.getTime() < s.value &&
            ((n = this._getOrReturnCtx(e, n)),
            ne(n, {
              code: Y.too_small,
              message: s.message,
              inclusive: !0,
              exact: !1,
              minimum: s.value,
              type: "date",
            }),
            a.dirty())
          : s.kind === "max"
          ? e.data.getTime() > s.value &&
            ((n = this._getOrReturnCtx(e, n)),
            ne(n, {
              code: Y.too_big,
              message: s.message,
              inclusive: !0,
              exact: !1,
              maximum: s.value,
              type: "date",
            }),
            a.dirty())
          : Le.assertNever(s);
      return { status: a.value, value: new Date(e.data.getTime()) };
    }
    _addCheck(e) {
      return new Dn({ ...this._def, checks: [...this._def.checks, e] });
    }
    min(e, r) {
      return this._addCheck({
        kind: "min",
        value: e.getTime(),
        message: pe.toString(r),
      });
    }
    max(e, r) {
      return this._addCheck({
        kind: "max",
        value: e.getTime(),
        message: pe.toString(r),
      });
    }
    get minDate() {
      let e = null;
      for (const r of this._def.checks)
        r.kind === "min" && (e === null || r.value > e) && (e = r.value);
      return e != null ? new Date(e) : null;
    }
    get maxDate() {
      let e = null;
      for (const r of this._def.checks)
        r.kind === "max" && (e === null || r.value < e) && (e = r.value);
      return e != null ? new Date(e) : null;
    }
  }
  Dn.create = (t) =>
    new Dn({
      checks: [],
      coerce: (t == null ? void 0 : t.coerce) || !1,
      typeName: X.ZodDate,
      ...Ce(t),
    });
  class Vo extends Oe {
    _parse(e) {
      if (this._getType(e) !== ie.symbol) {
        const a = this._getOrReturnCtx(e);
        return (
          ne(a, {
            code: Y.invalid_type,
            expected: ie.symbol,
            received: a.parsedType,
          }),
          Ee
        );
      }
      return qt(e.data);
    }
  }
  Vo.create = (t) => new Vo({ typeName: X.ZodSymbol, ...Ce(t) });
  class cs extends Oe {
    _parse(e) {
      if (this._getType(e) !== ie.undefined) {
        const a = this._getOrReturnCtx(e);
        return (
          ne(a, {
            code: Y.invalid_type,
            expected: ie.undefined,
            received: a.parsedType,
          }),
          Ee
        );
      }
      return qt(e.data);
    }
  }
  cs.create = (t) => new cs({ typeName: X.ZodUndefined, ...Ce(t) });
  let us = class extends Oe {
    _parse(e) {
      if (this._getType(e) !== ie.null) {
        const a = this._getOrReturnCtx(e);
        return (
          ne(a, {
            code: Y.invalid_type,
            expected: ie.null,
            received: a.parsedType,
          }),
          Ee
        );
      }
      return qt(e.data);
    }
  };
  us.create = (t) => new us({ typeName: X.ZodNull, ...Ce(t) });
  let ga = class extends Oe {
    constructor() {
      super(...arguments), (this._any = !0);
    }
    _parse(e) {
      return qt(e.data);
    }
  };
  ga.create = (t) => new ga({ typeName: X.ZodAny, ...Ce(t) });
  let Ln = class extends Oe {
    constructor() {
      super(...arguments), (this._unknown = !0);
    }
    _parse(e) {
      return qt(e.data);
    }
  };
  Ln.create = (t) => new Ln({ typeName: X.ZodUnknown, ...Ce(t) });
  let tn = class extends Oe {
    _parse(e) {
      const r = this._getOrReturnCtx(e);
      return (
        ne(r, {
          code: Y.invalid_type,
          expected: ie.never,
          received: r.parsedType,
        }),
        Ee
      );
    }
  };
  tn.create = (t) => new tn({ typeName: X.ZodNever, ...Ce(t) });
  class Zo extends Oe {
    _parse(e) {
      if (this._getType(e) !== ie.undefined) {
        const a = this._getOrReturnCtx(e);
        return (
          ne(a, {
            code: Y.invalid_type,
            expected: ie.void,
            received: a.parsedType,
          }),
          Ee
        );
      }
      return qt(e.data);
    }
  }
  Zo.create = (t) => new Zo({ typeName: X.ZodVoid, ...Ce(t) });
  let zn = class gl extends Oe {
    _parse(e) {
      const { ctx: r, status: a } = this._processInputParams(e),
        n = this._def;
      if (r.parsedType !== ie.array)
        return (
          ne(r, {
            code: Y.invalid_type,
            expected: ie.array,
            received: r.parsedType,
          }),
          Ee
        );
      if (n.exactLength !== null) {
        const o = r.data.length > n.exactLength.value,
          i = r.data.length < n.exactLength.value;
        (o || i) &&
          (ne(r, {
            code: o ? Y.too_big : Y.too_small,
            minimum: i ? n.exactLength.value : void 0,
            maximum: o ? n.exactLength.value : void 0,
            type: "array",
            inclusive: !0,
            exact: !0,
            message: n.exactLength.message,
          }),
          a.dirty());
      }
      if (
        (n.minLength !== null &&
          r.data.length < n.minLength.value &&
          (ne(r, {
            code: Y.too_small,
            minimum: n.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: n.minLength.message,
          }),
          a.dirty()),
        n.maxLength !== null &&
          r.data.length > n.maxLength.value &&
          (ne(r, {
            code: Y.too_big,
            maximum: n.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: n.maxLength.message,
          }),
          a.dirty()),
        r.common.async)
      )
        return Promise.all(
          [...r.data].map((o, i) => n.type._parseAsync(new Mr(r, o, r.path, i)))
        ).then((o) => Mt.mergeArray(a, o));
      const s = [...r.data].map((o, i) =>
        n.type._parseSync(new Mr(r, o, r.path, i))
      );
      return Mt.mergeArray(a, s);
    }
    get element() {
      return this._def.type;
    }
    min(e, r) {
      return new gl({
        ...this._def,
        minLength: { value: e, message: pe.toString(r) },
      });
    }
    max(e, r) {
      return new gl({
        ...this._def,
        maxLength: { value: e, message: pe.toString(r) },
      });
    }
    length(e, r) {
      return new gl({
        ...this._def,
        exactLength: { value: e, message: pe.toString(r) },
      });
    }
    nonempty(e) {
      return this.min(1, e);
    }
  };
  zn.create = (t, e) =>
    new zn({
      type: t,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: X.ZodArray,
      ...Ce(e),
    });
  function ya(t) {
    if (t instanceof lr) {
      const e = {};
      for (const r in t.shape) {
        const a = t.shape[r];
        e[r] = Dr.create(ya(a));
      }
      return new lr({ ...t._def, shape: () => e });
    } else return t instanceof zn ? new zn({ ...t._def, type: ya(t.element) }) : t instanceof Dr ? Dr.create(ya(t.unwrap())) : t instanceof hn ? hn.create(ya(t.unwrap())) : t instanceof jr ? jr.create(t.items.map((e) => ya(e))) : t;
  }
  let lr = class Cr extends Oe {
    constructor() {
      super(...arguments),
        (this._cached = null),
        (this.nonstrict = this.passthrough),
        (this.augment = this.extend);
    }
    _getCached() {
      if (this._cached !== null) return this._cached;
      const e = this._def.shape(),
        r = Le.objectKeys(e);
      return (this._cached = { shape: e, keys: r }), this._cached;
    }
    _parse(e) {
      if (this._getType(e) !== ie.object) {
        const c = this._getOrReturnCtx(e);
        return (
          ne(c, {
            code: Y.invalid_type,
            expected: ie.object,
            received: c.parsedType,
          }),
          Ee
        );
      }
      const { status: a, ctx: n } = this._processInputParams(e),
        { shape: s, keys: o } = this._getCached(),
        i = [];
      if (
        !(this._def.catchall instanceof tn && this._def.unknownKeys === "strip")
      )
        for (const c in n.data) o.includes(c) || i.push(c);
      const l = [];
      for (const c of o) {
        const u = s[c],
          f = n.data[c];
        l.push({
          key: { status: "valid", value: c },
          value: u._parse(new Mr(n, f, n.path, c)),
          alwaysSet: c in n.data,
        });
      }
      if (this._def.catchall instanceof tn) {
        const c = this._def.unknownKeys;
        if (c === "passthrough")
          for (const u of i)
            l.push({
              key: { status: "valid", value: u },
              value: { status: "valid", value: n.data[u] },
            });
        else if (c === "strict")
          i.length > 0 &&
            (ne(n, { code: Y.unrecognized_keys, keys: i }), a.dirty());
        else if (c !== "strip")
          throw new Error(
            "Internal ZodObject error: invalid unknownKeys value."
          );
      } else {
        const c = this._def.catchall;
        for (const u of i) {
          const f = n.data[u];
          l.push({
            key: { status: "valid", value: u },
            value: c._parse(new Mr(n, f, n.path, u)),
            alwaysSet: u in n.data,
          });
        }
      }
      return n.common.async
        ? Promise.resolve()
            .then(async () => {
              const c = [];
              for (const u of l) {
                const f = await u.key,
                  v = await u.value;
                c.push({ key: f, value: v, alwaysSet: u.alwaysSet });
              }
              return c;
            })
            .then((c) => Mt.mergeObjectSync(a, c))
        : Mt.mergeObjectSync(a, l);
    }
    get shape() {
      return this._def.shape();
    }
    strict(e) {
      return (
        pe.errToObj,
        new Cr({
          ...this._def,
          unknownKeys: "strict",
          ...(e !== void 0
            ? {
                errorMap: (r, a) => {
                  var s, o;
                  const n =
                    ((o = (s = this._def).errorMap) == null
                      ? void 0
                      : o.call(s, r, a).message) ?? a.defaultError;
                  return r.code === "unrecognized_keys"
                    ? { message: pe.errToObj(e).message ?? n }
                    : { message: n };
                },
              }
            : {}),
        })
      );
    }
    strip() {
      return new Cr({ ...this._def, unknownKeys: "strip" });
    }
    passthrough() {
      return new Cr({ ...this._def, unknownKeys: "passthrough" });
    }
    extend(e) {
      return new Cr({
        ...this._def,
        shape: () => ({ ...this._def.shape(), ...e }),
      });
    }
    merge(e) {
      return new Cr({
        unknownKeys: e._def.unknownKeys,
        catchall: e._def.catchall,
        shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
        typeName: X.ZodObject,
      });
    }
    setKey(e, r) {
      return this.augment({ [e]: r });
    }
    catchall(e) {
      return new Cr({ ...this._def, catchall: e });
    }
    pick(e) {
      const r = {};
      for (const a of Le.objectKeys(e))
        e[a] && this.shape[a] && (r[a] = this.shape[a]);
      return new Cr({ ...this._def, shape: () => r });
    }
    omit(e) {
      const r = {};
      for (const a of Le.objectKeys(this.shape)) e[a] || (r[a] = this.shape[a]);
      return new Cr({ ...this._def, shape: () => r });
    }
    deepPartial() {
      return ya(this);
    }
    partial(e) {
      const r = {};
      for (const a of Le.objectKeys(this.shape)) {
        const n = this.shape[a];
        e && !e[a] ? (r[a] = n) : (r[a] = n.optional());
      }
      return new Cr({ ...this._def, shape: () => r });
    }
    required(e) {
      const r = {};
      for (const a of Le.objectKeys(this.shape))
        if (e && !e[a]) r[a] = this.shape[a];
        else {
          let s = this.shape[a];
          for (; s instanceof Dr; ) s = s._def.innerType;
          r[a] = s;
        }
      return new Cr({ ...this._def, shape: () => r });
    }
    keyof() {
      return qp(Le.objectKeys(this.shape));
    }
  };
  (lr.create = (t, e) =>
    new lr({
      shape: () => t,
      unknownKeys: "strip",
      catchall: tn.create(),
      typeName: X.ZodObject,
      ...Ce(e),
    })),
    (lr.strictCreate = (t, e) =>
      new lr({
        shape: () => t,
        unknownKeys: "strict",
        catchall: tn.create(),
        typeName: X.ZodObject,
        ...Ce(e),
      })),
    (lr.lazycreate = (t, e) =>
      new lr({
        shape: t,
        unknownKeys: "strip",
        catchall: tn.create(),
        typeName: X.ZodObject,
        ...Ce(e),
      }));
  let ds = class extends Oe {
    _parse(e) {
      const { ctx: r } = this._processInputParams(e),
        a = this._def.options;
      function n(s) {
        for (const i of s) if (i.result.status === "valid") return i.result;
        for (const i of s)
          if (i.result.status === "dirty")
            return r.common.issues.push(...i.ctx.common.issues), i.result;
        const o = s.map((i) => new er(i.ctx.common.issues));
        return ne(r, { code: Y.invalid_union, unionErrors: o }), Ee;
      }
      if (r.common.async)
        return Promise.all(
          a.map(async (s) => {
            const o = {
              ...r,
              common: { ...r.common, issues: [] },
              parent: null,
            };
            return {
              result: await s._parseAsync({
                data: r.data,
                path: r.path,
                parent: o,
              }),
              ctx: o,
            };
          })
        ).then(n);
      {
        let s;
        const o = [];
        for (const l of a) {
          const c = { ...r, common: { ...r.common, issues: [] }, parent: null },
            u = l._parseSync({ data: r.data, path: r.path, parent: c });
          if (u.status === "valid") return u;
          u.status === "dirty" && !s && (s = { result: u, ctx: c }),
            c.common.issues.length && o.push(c.common.issues);
        }
        if (s) return r.common.issues.push(...s.ctx.common.issues), s.result;
        const i = o.map((l) => new er(l));
        return ne(r, { code: Y.invalid_union, unionErrors: i }), Ee;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ds.create = (t, e) => new ds({ options: t, typeName: X.ZodUnion, ...Ce(e) });
  const rn = (t) =>
    t instanceof ps
      ? rn(t.schema)
      : t instanceof br
      ? rn(t.innerType())
      : t instanceof hs
      ? [t.value]
      : t instanceof ms
      ? t.options
      : t instanceof vs
      ? Le.objectValues(t.enum)
      : t instanceof gs
      ? rn(t._def.innerType)
      : t instanceof cs
      ? [void 0]
      : t instanceof us
      ? [null]
      : t instanceof Dr
      ? [void 0, ...rn(t.unwrap())]
      : t instanceof hn
      ? [null, ...rn(t.unwrap())]
      : t instanceof xc || t instanceof ws
      ? rn(t.unwrap())
      : t instanceof ys
      ? rn(t._def.innerType)
      : [];
  let Lp = class j0 extends Oe {
    _parse(e) {
      const { ctx: r } = this._processInputParams(e);
      if (r.parsedType !== ie.object)
        return (
          ne(r, {
            code: Y.invalid_type,
            expected: ie.object,
            received: r.parsedType,
          }),
          Ee
        );
      const a = this.discriminator,
        n = r.data[a],
        s = this.optionsMap.get(n);
      return s
        ? r.common.async
          ? s._parseAsync({ data: r.data, path: r.path, parent: r })
          : s._parseSync({ data: r.data, path: r.path, parent: r })
        : (ne(r, {
            code: Y.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [a],
          }),
          Ee);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(e, r, a) {
      const n = new Map();
      for (const s of r) {
        const o = rn(s.shape[e]);
        if (!o.length)
          throw new Error(
            `A discriminator value for key \`${e}\` could not be extracted from all schema options`
          );
        for (const i of o) {
          if (n.has(i))
            throw new Error(
              `Discriminator property ${String(e)} has duplicate value ${String(
                i
              )}`
            );
          n.set(i, s);
        }
      }
      return new j0({
        typeName: X.ZodDiscriminatedUnion,
        discriminator: e,
        options: r,
        optionsMap: n,
        ...Ce(a),
      });
    }
  };
  function Tc(t, e) {
    const r = en(t),
      a = en(e);
    if (t === e) return { valid: !0, data: t };
    if (r === ie.object && a === ie.object) {
      const n = Le.objectKeys(e),
        s = Le.objectKeys(t).filter((i) => n.indexOf(i) !== -1),
        o = { ...t, ...e };
      for (const i of s) {
        const l = Tc(t[i], e[i]);
        if (!l.valid) return { valid: !1 };
        o[i] = l.data;
      }
      return { valid: !0, data: o };
    } else if (r === ie.array && a === ie.array) {
      if (t.length !== e.length) return { valid: !1 };
      const n = [];
      for (let s = 0; s < t.length; s++) {
        const o = t[s],
          i = e[s],
          l = Tc(o, i);
        if (!l.valid) return { valid: !1 };
        n.push(l.data);
      }
      return { valid: !0, data: n };
    } else
      return r === ie.date && a === ie.date && +t == +e
        ? { valid: !0, data: t }
        : { valid: !1 };
  }
  let fs = class extends Oe {
    _parse(e) {
      const { status: r, ctx: a } = this._processInputParams(e),
        n = (s, o) => {
          if (Sc(s) || Sc(o)) return Ee;
          const i = Tc(s.value, o.value);
          return i.valid
            ? (($c(s) || $c(o)) && r.dirty(),
              { status: r.value, value: i.data })
            : (ne(a, { code: Y.invalid_intersection_types }), Ee);
        };
      return a.common.async
        ? Promise.all([
            this._def.left._parseAsync({
              data: a.data,
              path: a.path,
              parent: a,
            }),
            this._def.right._parseAsync({
              data: a.data,
              path: a.path,
              parent: a,
            }),
          ]).then(([s, o]) => n(s, o))
        : n(
            this._def.left._parseSync({
              data: a.data,
              path: a.path,
              parent: a,
            }),
            this._def.right._parseSync({
              data: a.data,
              path: a.path,
              parent: a,
            })
          );
    }
  };
  fs.create = (t, e, r) =>
    new fs({ left: t, right: e, typeName: X.ZodIntersection, ...Ce(r) });
  class jr extends Oe {
    _parse(e) {
      const { status: r, ctx: a } = this._processInputParams(e);
      if (a.parsedType !== ie.array)
        return (
          ne(a, {
            code: Y.invalid_type,
            expected: ie.array,
            received: a.parsedType,
          }),
          Ee
        );
      if (a.data.length < this._def.items.length)
        return (
          ne(a, {
            code: Y.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array",
          }),
          Ee
        );
      !this._def.rest &&
        a.data.length > this._def.items.length &&
        (ne(a, {
          code: Y.too_big,
          maximum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        r.dirty());
      const s = [...a.data]
        .map((o, i) => {
          const l = this._def.items[i] || this._def.rest;
          return l ? l._parse(new Mr(a, o, a.path, i)) : null;
        })
        .filter((o) => !!o);
      return a.common.async
        ? Promise.all(s).then((o) => Mt.mergeArray(r, o))
        : Mt.mergeArray(r, s);
    }
    get items() {
      return this._def.items;
    }
    rest(e) {
      return new jr({ ...this._def, rest: e });
    }
  }
  jr.create = (t, e) => {
    if (!Array.isArray(t))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new jr({ items: t, typeName: X.ZodTuple, rest: null, ...Ce(e) });
  };
  let zp = class lf extends Oe {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(e) {
      const { status: r, ctx: a } = this._processInputParams(e);
      if (a.parsedType !== ie.object)
        return (
          ne(a, {
            code: Y.invalid_type,
            expected: ie.object,
            received: a.parsedType,
          }),
          Ee
        );
      const n = [],
        s = this._def.keyType,
        o = this._def.valueType;
      for (const i in a.data)
        n.push({
          key: s._parse(new Mr(a, i, a.path, i)),
          value: o._parse(new Mr(a, a.data[i], a.path, i)),
          alwaysSet: i in a.data,
        });
      return a.common.async
        ? Mt.mergeObjectAsync(r, n)
        : Mt.mergeObjectSync(r, n);
    }
    get element() {
      return this._def.valueType;
    }
    static create(e, r, a) {
      return r instanceof Oe
        ? new lf({ keyType: e, valueType: r, typeName: X.ZodRecord, ...Ce(a) })
        : new lf({
            keyType: va.create(),
            valueType: e,
            typeName: X.ZodRecord,
            ...Ce(r),
          });
    }
  };
  class Ho extends Oe {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(e) {
      const { status: r, ctx: a } = this._processInputParams(e);
      if (a.parsedType !== ie.map)
        return (
          ne(a, {
            code: Y.invalid_type,
            expected: ie.map,
            received: a.parsedType,
          }),
          Ee
        );
      const n = this._def.keyType,
        s = this._def.valueType,
        o = [...a.data.entries()].map(([i, l], c) => ({
          key: n._parse(new Mr(a, i, a.path, [c, "key"])),
          value: s._parse(new Mr(a, l, a.path, [c, "value"])),
        }));
      if (a.common.async) {
        const i = new Map();
        return Promise.resolve().then(async () => {
          for (const l of o) {
            const c = await l.key,
              u = await l.value;
            if (c.status === "aborted" || u.status === "aborted") return Ee;
            (c.status === "dirty" || u.status === "dirty") && r.dirty(),
              i.set(c.value, u.value);
          }
          return { status: r.value, value: i };
        });
      } else {
        const i = new Map();
        for (const l of o) {
          const c = l.key,
            u = l.value;
          if (c.status === "aborted" || u.status === "aborted") return Ee;
          (c.status === "dirty" || u.status === "dirty") && r.dirty(),
            i.set(c.value, u.value);
        }
        return { status: r.value, value: i };
      }
    }
  }
  Ho.create = (t, e, r) =>
    new Ho({ valueType: e, keyType: t, typeName: X.ZodMap, ...Ce(r) });
  class qn extends Oe {
    _parse(e) {
      const { status: r, ctx: a } = this._processInputParams(e);
      if (a.parsedType !== ie.set)
        return (
          ne(a, {
            code: Y.invalid_type,
            expected: ie.set,
            received: a.parsedType,
          }),
          Ee
        );
      const n = this._def;
      n.minSize !== null &&
        a.data.size < n.minSize.value &&
        (ne(a, {
          code: Y.too_small,
          minimum: n.minSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: n.minSize.message,
        }),
        r.dirty()),
        n.maxSize !== null &&
          a.data.size > n.maxSize.value &&
          (ne(a, {
            code: Y.too_big,
            maximum: n.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: n.maxSize.message,
          }),
          r.dirty());
      const s = this._def.valueType;
      function o(l) {
        const c = new Set();
        for (const u of l) {
          if (u.status === "aborted") return Ee;
          u.status === "dirty" && r.dirty(), c.add(u.value);
        }
        return { status: r.value, value: c };
      }
      const i = [...a.data.values()].map((l, c) =>
        s._parse(new Mr(a, l, a.path, c))
      );
      return a.common.async ? Promise.all(i).then((l) => o(l)) : o(i);
    }
    min(e, r) {
      return new qn({
        ...this._def,
        minSize: { value: e, message: pe.toString(r) },
      });
    }
    max(e, r) {
      return new qn({
        ...this._def,
        maxSize: { value: e, message: pe.toString(r) },
      });
    }
    size(e, r) {
      return this.min(e, r).max(e, r);
    }
    nonempty(e) {
      return this.min(1, e);
    }
  }
  qn.create = (t, e) =>
    new qn({
      valueType: t,
      minSize: null,
      maxSize: null,
      typeName: X.ZodSet,
      ...Ce(e),
    });
  class _a extends Oe {
    constructor() {
      super(...arguments), (this.validate = this.implement);
    }
    _parse(e) {
      const { ctx: r } = this._processInputParams(e);
      if (r.parsedType !== ie.function)
        return (
          ne(r, {
            code: Y.invalid_type,
            expected: ie.function,
            received: r.parsedType,
          }),
          Ee
        );
      function a(i, l) {
        return Fo({
          data: i,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            Uo(),
            ha,
          ].filter((c) => !!c),
          issueData: { code: Y.invalid_arguments, argumentsError: l },
        });
      }
      function n(i, l) {
        return Fo({
          data: i,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            Uo(),
            ha,
          ].filter((c) => !!c),
          issueData: { code: Y.invalid_return_type, returnTypeError: l },
        });
      }
      const s = { errorMap: r.common.contextualErrorMap },
        o = r.data;
      if (this._def.returns instanceof wa) {
        const i = this;
        return qt(async function (...l) {
          const c = new er([]),
            u = await i._def.args.parseAsync(l, s).catch((d) => {
              throw (c.addIssue(a(l, d)), c);
            }),
            f = await Reflect.apply(o, this, u);
          return await i._def.returns._def.type.parseAsync(f, s).catch((d) => {
            throw (c.addIssue(n(f, d)), c);
          });
        });
      } else {
        const i = this;
        return qt(function (...l) {
          const c = i._def.args.safeParse(l, s);
          if (!c.success) throw new er([a(l, c.error)]);
          const u = Reflect.apply(o, this, c.data),
            f = i._def.returns.safeParse(u, s);
          if (!f.success) throw new er([n(u, f.error)]);
          return f.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...e) {
      return new _a({ ...this._def, args: jr.create(e).rest(Ln.create()) });
    }
    returns(e) {
      return new _a({ ...this._def, returns: e });
    }
    implement(e) {
      return this.parse(e);
    }
    strictImplement(e) {
      return this.parse(e);
    }
    static create(e, r, a) {
      return new _a({
        args: e || jr.create([]).rest(Ln.create()),
        returns: r || Ln.create(),
        typeName: X.ZodFunction,
        ...Ce(a),
      });
    }
  }
  let ps = class extends Oe {
    get schema() {
      return this._def.getter();
    }
    _parse(e) {
      const { ctx: r } = this._processInputParams(e);
      return this._def
        .getter()
        ._parse({ data: r.data, path: r.path, parent: r });
    }
  };
  ps.create = (t, e) => new ps({ getter: t, typeName: X.ZodLazy, ...Ce(e) });
  let hs = class extends Oe {
    _parse(e) {
      if (e.data !== this._def.value) {
        const r = this._getOrReturnCtx(e);
        return (
          ne(r, {
            received: r.data,
            code: Y.invalid_literal,
            expected: this._def.value,
          }),
          Ee
        );
      }
      return { status: "valid", value: e.data };
    }
    get value() {
      return this._def.value;
    }
  };
  hs.create = (t, e) => new hs({ value: t, typeName: X.ZodLiteral, ...Ce(e) });
  function qp(t, e) {
    return new ms({ values: t, typeName: X.ZodEnum, ...Ce(e) });
  }
  let ms = class cf extends Oe {
    _parse(e) {
      if (typeof e.data != "string") {
        const r = this._getOrReturnCtx(e),
          a = this._def.values;
        return (
          ne(r, {
            expected: Le.joinValues(a),
            received: r.parsedType,
            code: Y.invalid_type,
          }),
          Ee
        );
      }
      if (
        (this._cache || (this._cache = new Set(this._def.values)),
        !this._cache.has(e.data))
      ) {
        const r = this._getOrReturnCtx(e),
          a = this._def.values;
        return (
          ne(r, { received: r.data, code: Y.invalid_enum_value, options: a }),
          Ee
        );
      }
      return qt(e.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const e = {};
      for (const r of this._def.values) e[r] = r;
      return e;
    }
    get Values() {
      const e = {};
      for (const r of this._def.values) e[r] = r;
      return e;
    }
    get Enum() {
      const e = {};
      for (const r of this._def.values) e[r] = r;
      return e;
    }
    extract(e, r = this._def) {
      return cf.create(e, { ...this._def, ...r });
    }
    exclude(e, r = this._def) {
      return cf.create(
        this.options.filter((a) => !e.includes(a)),
        { ...this._def, ...r }
      );
    }
  };
  ms.create = qp;
  class vs extends Oe {
    _parse(e) {
      const r = Le.getValidEnumValues(this._def.values),
        a = this._getOrReturnCtx(e);
      if (a.parsedType !== ie.string && a.parsedType !== ie.number) {
        const n = Le.objectValues(r);
        return (
          ne(a, {
            expected: Le.joinValues(n),
            received: a.parsedType,
            code: Y.invalid_type,
          }),
          Ee
        );
      }
      if (
        (this._cache ||
          (this._cache = new Set(Le.getValidEnumValues(this._def.values))),
        !this._cache.has(e.data))
      ) {
        const n = Le.objectValues(r);
        return (
          ne(a, { received: a.data, code: Y.invalid_enum_value, options: n }),
          Ee
        );
      }
      return qt(e.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  vs.create = (t, e) =>
    new vs({ values: t, typeName: X.ZodNativeEnum, ...Ce(e) });
  class wa extends Oe {
    unwrap() {
      return this._def.type;
    }
    _parse(e) {
      const { ctx: r } = this._processInputParams(e);
      if (r.parsedType !== ie.promise && r.common.async === !1)
        return (
          ne(r, {
            code: Y.invalid_type,
            expected: ie.promise,
            received: r.parsedType,
          }),
          Ee
        );
      const a = r.parsedType === ie.promise ? r.data : Promise.resolve(r.data);
      return qt(
        a.then((n) =>
          this._def.type.parseAsync(n, {
            path: r.path,
            errorMap: r.common.contextualErrorMap,
          })
        )
      );
    }
  }
  wa.create = (t, e) => new wa({ type: t, typeName: X.ZodPromise, ...Ce(e) });
  class br extends Oe {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === X.ZodEffects
        ? this._def.schema.sourceType()
        : this._def.schema;
    }
    _parse(e) {
      const { status: r, ctx: a } = this._processInputParams(e),
        n = this._def.effect || null,
        s = {
          addIssue: (o) => {
            ne(a, o), o.fatal ? r.abort() : r.dirty();
          },
          get path() {
            return a.path;
          },
        };
      if (((s.addIssue = s.addIssue.bind(s)), n.type === "preprocess")) {
        const o = n.transform(a.data, s);
        if (a.common.async)
          return Promise.resolve(o).then(async (i) => {
            if (r.value === "aborted") return Ee;
            const l = await this._def.schema._parseAsync({
              data: i,
              path: a.path,
              parent: a,
            });
            return l.status === "aborted"
              ? Ee
              : l.status === "dirty" || r.value === "dirty"
              ? ma(l.value)
              : l;
          });
        {
          if (r.value === "aborted") return Ee;
          const i = this._def.schema._parseSync({
            data: o,
            path: a.path,
            parent: a,
          });
          return i.status === "aborted"
            ? Ee
            : i.status === "dirty" || r.value === "dirty"
            ? ma(i.value)
            : i;
        }
      }
      if (n.type === "refinement") {
        const o = (i) => {
          const l = n.refinement(i, s);
          if (a.common.async) return Promise.resolve(l);
          if (l instanceof Promise)
            throw new Error(
              "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
            );
          return i;
        };
        if (a.common.async === !1) {
          const i = this._def.schema._parseSync({
            data: a.data,
            path: a.path,
            parent: a,
          });
          return i.status === "aborted"
            ? Ee
            : (i.status === "dirty" && r.dirty(),
              o(i.value),
              { status: r.value, value: i.value });
        } else
          return this._def.schema
            ._parseAsync({ data: a.data, path: a.path, parent: a })
            .then((i) =>
              i.status === "aborted"
                ? Ee
                : (i.status === "dirty" && r.dirty(),
                  o(i.value).then(() => ({ status: r.value, value: i.value })))
            );
      }
      if (n.type === "transform")
        if (a.common.async === !1) {
          const o = this._def.schema._parseSync({
            data: a.data,
            path: a.path,
            parent: a,
          });
          if (!jn(o)) return Ee;
          const i = n.transform(o.value, s);
          if (i instanceof Promise)
            throw new Error(
              "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
            );
          return { status: r.value, value: i };
        } else
          return this._def.schema
            ._parseAsync({ data: a.data, path: a.path, parent: a })
            .then((o) =>
              jn(o)
                ? Promise.resolve(n.transform(o.value, s)).then((i) => ({
                    status: r.value,
                    value: i,
                  }))
                : Ee
            );
      Le.assertNever(n);
    }
  }
  (br.create = (t, e, r) =>
    new br({ schema: t, typeName: X.ZodEffects, effect: e, ...Ce(r) })),
    (br.createWithPreprocess = (t, e, r) =>
      new br({
        schema: e,
        effect: { type: "preprocess", transform: t },
        typeName: X.ZodEffects,
        ...Ce(r),
      }));
  let Dr = class extends Oe {
    _parse(e) {
      return this._getType(e) === ie.undefined
        ? qt(void 0)
        : this._def.innerType._parse(e);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  Dr.create = (t, e) =>
    new Dr({ innerType: t, typeName: X.ZodOptional, ...Ce(e) });
  let hn = class extends Oe {
    _parse(e) {
      return this._getType(e) === ie.null
        ? qt(null)
        : this._def.innerType._parse(e);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  hn.create = (t, e) =>
    new hn({ innerType: t, typeName: X.ZodNullable, ...Ce(e) });
  let gs = class extends Oe {
    _parse(e) {
      const { ctx: r } = this._processInputParams(e);
      let a = r.data;
      return (
        r.parsedType === ie.undefined && (a = this._def.defaultValue()),
        this._def.innerType._parse({ data: a, path: r.path, parent: r })
      );
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  gs.create = (t, e) =>
    new gs({
      innerType: t,
      typeName: X.ZodDefault,
      defaultValue:
        typeof e.default == "function" ? e.default : () => e.default,
      ...Ce(e),
    });
  let ys = class extends Oe {
    _parse(e) {
      const { ctx: r } = this._processInputParams(e),
        a = { ...r, common: { ...r.common, issues: [] } },
        n = this._def.innerType._parse({
          data: a.data,
          path: a.path,
          parent: { ...a },
        });
      return os(n)
        ? n.then((s) => ({
            status: "valid",
            value:
              s.status === "valid"
                ? s.value
                : this._def.catchValue({
                    get error() {
                      return new er(a.common.issues);
                    },
                    input: a.data,
                  }),
          }))
        : {
            status: "valid",
            value:
              n.status === "valid"
                ? n.value
                : this._def.catchValue({
                    get error() {
                      return new er(a.common.issues);
                    },
                    input: a.data,
                  }),
          };
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ys.create = (t, e) =>
    new ys({
      innerType: t,
      typeName: X.ZodCatch,
      catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
      ...Ce(e),
    });
  class Bo extends Oe {
    _parse(e) {
      if (this._getType(e) !== ie.nan) {
        const a = this._getOrReturnCtx(e);
        return (
          ne(a, {
            code: Y.invalid_type,
            expected: ie.nan,
            received: a.parsedType,
          }),
          Ee
        );
      }
      return { status: "valid", value: e.data };
    }
  }
  Bo.create = (t) => new Bo({ typeName: X.ZodNaN, ...Ce(t) });
  const bS = Symbol("zod_brand");
  class xc extends Oe {
    _parse(e) {
      const { ctx: r } = this._processInputParams(e),
        a = r.data;
      return this._def.type._parse({ data: a, path: r.path, parent: r });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class _s extends Oe {
    _parse(e) {
      const { status: r, ctx: a } = this._processInputParams(e);
      if (a.common.async)
        return (async () => {
          const s = await this._def.in._parseAsync({
            data: a.data,
            path: a.path,
            parent: a,
          });
          return s.status === "aborted"
            ? Ee
            : s.status === "dirty"
            ? (r.dirty(), ma(s.value))
            : this._def.out._parseAsync({
                data: s.value,
                path: a.path,
                parent: a,
              });
        })();
      {
        const n = this._def.in._parseSync({
          data: a.data,
          path: a.path,
          parent: a,
        });
        return n.status === "aborted"
          ? Ee
          : n.status === "dirty"
          ? (r.dirty(), { status: "dirty", value: n.value })
          : this._def.out._parseSync({
              data: n.value,
              path: a.path,
              parent: a,
            });
      }
    }
    static create(e, r) {
      return new _s({ in: e, out: r, typeName: X.ZodPipeline });
    }
  }
  let ws = class extends Oe {
    _parse(e) {
      const r = this._def.innerType._parse(e),
        a = (n) => (jn(n) && (n.value = Object.freeze(n.value)), n);
      return os(r) ? r.then((n) => a(n)) : a(r);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ws.create = (t, e) =>
    new ws({ innerType: t, typeName: X.ZodReadonly, ...Ce(e) });
  function Up(t, e) {
    const r =
      typeof t == "function" ? t(e) : typeof t == "string" ? { message: t } : t;
    return typeof r == "string" ? { message: r } : r;
  }
  function Fp(t, e = {}, r) {
    return t
      ? ga.create().superRefine((a, n) => {
          const s = t(a);
          if (s instanceof Promise)
            return s.then((o) => {
              if (!o) {
                const i = Up(e, a),
                  l = i.fatal ?? r ?? !0;
                n.addIssue({ code: "custom", ...i, fatal: l });
              }
            });
          if (!s) {
            const o = Up(e, a),
              i = o.fatal ?? r ?? !0;
            n.addIssue({ code: "custom", ...o, fatal: i });
          }
        })
      : ga.create();
  }
  const ES = { object: lr.lazycreate };
  var X;
  (function (t) {
    (t.ZodString = "ZodString"),
      (t.ZodNumber = "ZodNumber"),
      (t.ZodNaN = "ZodNaN"),
      (t.ZodBigInt = "ZodBigInt"),
      (t.ZodBoolean = "ZodBoolean"),
      (t.ZodDate = "ZodDate"),
      (t.ZodSymbol = "ZodSymbol"),
      (t.ZodUndefined = "ZodUndefined"),
      (t.ZodNull = "ZodNull"),
      (t.ZodAny = "ZodAny"),
      (t.ZodUnknown = "ZodUnknown"),
      (t.ZodNever = "ZodNever"),
      (t.ZodVoid = "ZodVoid"),
      (t.ZodArray = "ZodArray"),
      (t.ZodObject = "ZodObject"),
      (t.ZodUnion = "ZodUnion"),
      (t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
      (t.ZodIntersection = "ZodIntersection"),
      (t.ZodTuple = "ZodTuple"),
      (t.ZodRecord = "ZodRecord"),
      (t.ZodMap = "ZodMap"),
      (t.ZodSet = "ZodSet"),
      (t.ZodFunction = "ZodFunction"),
      (t.ZodLazy = "ZodLazy"),
      (t.ZodLiteral = "ZodLiteral"),
      (t.ZodEnum = "ZodEnum"),
      (t.ZodEffects = "ZodEffects"),
      (t.ZodNativeEnum = "ZodNativeEnum"),
      (t.ZodOptional = "ZodOptional"),
      (t.ZodNullable = "ZodNullable"),
      (t.ZodDefault = "ZodDefault"),
      (t.ZodCatch = "ZodCatch"),
      (t.ZodPromise = "ZodPromise"),
      (t.ZodBranded = "ZodBranded"),
      (t.ZodPipeline = "ZodPipeline"),
      (t.ZodReadonly = "ZodReadonly");
  })(X || (X = {}));
  const SS = (t, e = { message: `Input not instance of ${t.name}` }) =>
      Fp((r) => r instanceof t, e),
    j = va.create,
    St = is.create,
    $S = Bo.create,
    PS = pn.create,
    _t = ls.create,
    TS = Dn.create,
    xS = Vo.create,
    IS = cs.create,
    kS = us.create,
    Vp = ga.create,
    ba = Ln.create,
    CS = tn.create,
    RS = Zo.create,
    ue = zn.create,
    re = lr.create,
    OS = lr.strictCreate,
    jt = ds.create,
    Zp = Lp.create,
    AS = fs.create,
    NS = jr.create,
    Ea = zp.create,
    MS = Ho.create,
    jS = qn.create,
    DS = _a.create,
    LS = ps.create,
    ke = hs.create,
    Lr = ms.create,
    zS = vs.create,
    qS = wa.create,
    Hp = br.create,
    Q = Dr.create,
    US = hn.create,
    FS = br.createWithPreprocess,
    VS = _s.create,
    ZS = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          BRAND: bS,
          DIRTY: ma,
          EMPTY_PATH: XE,
          INVALID: Ee,
          NEVER: Ee,
          OK: qt,
          ParseStatus: Mt,
          Schema: Oe,
          ZodAny: ga,
          ZodArray: zn,
          ZodBigInt: pn,
          ZodBoolean: ls,
          ZodBranded: xc,
          ZodCatch: ys,
          ZodDate: Dn,
          ZodDefault: gs,
          ZodDiscriminatedUnion: Lp,
          ZodEffects: br,
          ZodEnum: ms,
          ZodError: er,
          get ZodFirstPartyTypeKind() {
            return X;
          },
          ZodFunction: _a,
          ZodIntersection: fs,
          ZodIssueCode: Y,
          ZodLazy: ps,
          ZodLiteral: hs,
          ZodMap: Ho,
          ZodNaN: Bo,
          ZodNativeEnum: vs,
          ZodNever: tn,
          ZodNull: us,
          ZodNullable: hn,
          ZodNumber: is,
          ZodObject: lr,
          ZodOptional: Dr,
          ZodParsedType: ie,
          ZodPipeline: _s,
          ZodPromise: wa,
          ZodReadonly: ws,
          ZodRecord: zp,
          ZodSchema: Oe,
          ZodSet: qn,
          ZodString: va,
          ZodSymbol: Vo,
          ZodTransformer: br,
          ZodTuple: jr,
          ZodType: Oe,
          ZodUndefined: cs,
          ZodUnion: ds,
          ZodUnknown: Ln,
          ZodVoid: Zo,
          addIssueToContext: ne,
          any: Vp,
          array: ue,
          bigint: PS,
          boolean: _t,
          coerce: {
            string: (t) => va.create({ ...t, coerce: !0 }),
            number: (t) => is.create({ ...t, coerce: !0 }),
            boolean: (t) => ls.create({ ...t, coerce: !0 }),
            bigint: (t) => pn.create({ ...t, coerce: !0 }),
            date: (t) => Dn.create({ ...t, coerce: !0 }),
          },
          custom: Fp,
          date: TS,
          datetimeRegex: Dp,
          defaultErrorMap: ha,
          discriminatedUnion: Zp,
          effect: Hp,
          enum: Lr,
          function: DS,
          getErrorMap: Uo,
          getParsedType: en,
          instanceof: SS,
          intersection: AS,
          isAborted: Sc,
          isAsync: os,
          isDirty: $c,
          isValid: jn,
          late: ES,
          lazy: LS,
          literal: ke,
          makeIssue: Fo,
          map: MS,
          nan: $S,
          nativeEnum: zS,
          never: CS,
          null: kS,
          nullable: US,
          number: St,
          object: re,
          get objectUtil() {
            return Ec;
          },
          oboolean: () => _t().optional(),
          onumber: () => St().optional(),
          optional: Q,
          ostring: () => j().optional(),
          pipeline: VS,
          preprocess: FS,
          promise: qS,
          quotelessJson: QE,
          record: Ea,
          set: jS,
          setErrorMap: YE,
          strictObject: OS,
          string: j,
          symbol: xS,
          transformer: Hp,
          tuple: NS,
          undefined: IS,
          union: jt,
          unknown: ba,
          get util() {
            return Le;
          },
          void: RS,
        },
        Symbol.toStringTag,
        { value: "Module" }
      )
    ),
    bs = "2025-06-18",
    Bp = [bs, "2025-03-26", "2024-11-05", "2024-10-07"],
    Jo = "2.0",
    Jp = jt([j(), St().int()]),
    Kp = j(),
    HS = re({ progressToken: Q(Jp) }).passthrough(),
    cr = re({ _meta: Q(HS) }).passthrough(),
    Gt = re({ method: j(), params: Q(cr) }),
    Es = re({ _meta: Q(re({}).passthrough()) }).passthrough(),
    zr = re({ method: j(), params: Q(Es) }),
    ur = re({ _meta: Q(re({}).passthrough()) }).passthrough(),
    Ko = jt([j(), St().int()]),
    Gp = re({ jsonrpc: ke(Jo), id: Ko })
      .merge(Gt)
      .strict(),
    Wp = (t) => Gp.safeParse(t).success,
    Qp = re({ jsonrpc: ke(Jo) })
      .merge(zr)
      .strict(),
    BS = (t) => Qp.safeParse(t).success,
    Yp = re({ jsonrpc: ke(Jo), id: Ko, result: ur }).strict(),
    Ic = (t) => Yp.safeParse(t).success;
  var rt;
  (function (t) {
    (t[(t.ConnectionClosed = -32e3)] = "ConnectionClosed"),
      (t[(t.RequestTimeout = -32001)] = "RequestTimeout"),
      (t[(t.ParseError = -32700)] = "ParseError"),
      (t[(t.InvalidRequest = -32600)] = "InvalidRequest"),
      (t[(t.MethodNotFound = -32601)] = "MethodNotFound"),
      (t[(t.InvalidParams = -32602)] = "InvalidParams"),
      (t[(t.InternalError = -32603)] = "InternalError");
  })(rt || (rt = {}));
  const Xp = re({
      jsonrpc: ke(Jo),
      id: Ko,
      error: re({ code: St().int(), message: j(), data: Q(ba()) }),
    }).strict(),
    JS = (t) => Xp.safeParse(t).success,
    Ss = jt([Gp, Qp, Yp, Xp]),
    mn = ur.strict(),
    kc = zr.extend({
      method: ke("notifications/cancelled"),
      params: Es.extend({ requestId: Ko, reason: j().optional() }),
    }),
    $s = re({ name: j(), title: Q(j()) }).passthrough(),
    eh = $s.extend({ version: j() }),
    KS = re({
      experimental: Q(re({}).passthrough()),
      sampling: Q(re({}).passthrough()),
      elicitation: Q(re({}).passthrough()),
      roots: Q(re({ listChanged: Q(_t()) }).passthrough()),
    }).passthrough(),
    th = Gt.extend({
      method: ke("initialize"),
      params: cr.extend({
        protocolVersion: j(),
        capabilities: KS,
        clientInfo: eh,
      }),
    }),
    GS = re({
      experimental: Q(re({}).passthrough()),
      logging: Q(re({}).passthrough()),
      completions: Q(re({}).passthrough()),
      prompts: Q(re({ listChanged: Q(_t()) }).passthrough()),
      resources: Q(
        re({ subscribe: Q(_t()), listChanged: Q(_t()) }).passthrough()
      ),
      tools: Q(re({ listChanged: Q(_t()) }).passthrough()),
    }).passthrough(),
    rh = ur.extend({
      protocolVersion: j(),
      capabilities: GS,
      serverInfo: eh,
      instructions: Q(j()),
    }),
    Cc = zr.extend({ method: ke("notifications/initialized") }),
    WS = (t) => Cc.safeParse(t).success,
    Rc = Gt.extend({ method: ke("ping") }),
    QS = re({ progress: St(), total: Q(St()), message: Q(j()) }).passthrough(),
    Oc = zr.extend({
      method: ke("notifications/progress"),
      params: Es.merge(QS).extend({ progressToken: Jp }),
    }),
    Go = Gt.extend({ params: cr.extend({ cursor: Q(Kp) }).optional() }),
    Wo = ur.extend({ nextCursor: Q(Kp) }),
    nh = re({
      uri: j(),
      mimeType: Q(j()),
      _meta: Q(re({}).passthrough()),
    }).passthrough(),
    ah = nh.extend({ text: j() }),
    Ac = j().refine(
      (t) => {
        try {
          return atob(t), !0;
        } catch {
          return !1;
        }
      },
      { message: "Invalid Base64 string" }
    ),
    sh = nh.extend({ blob: Ac }),
    oh = $s.extend({
      uri: j(),
      description: Q(j()),
      mimeType: Q(j()),
      _meta: Q(re({}).passthrough()),
    }),
    YS = $s.extend({
      uriTemplate: j(),
      description: Q(j()),
      mimeType: Q(j()),
      _meta: Q(re({}).passthrough()),
    }),
    Qo = Go.extend({ method: ke("resources/list") }),
    ih = Wo.extend({ resources: ue(oh) }),
    Nc = Go.extend({ method: ke("resources/templates/list") }),
    lh = Wo.extend({ resourceTemplates: ue(YS) }),
    Mc = Gt.extend({
      method: ke("resources/read"),
      params: cr.extend({ uri: j() }),
    }),
    ch = ur.extend({ contents: ue(jt([ah, sh])) }),
    uh = zr.extend({ method: ke("notifications/resources/list_changed") }),
    dh = Gt.extend({
      method: ke("resources/subscribe"),
      params: cr.extend({ uri: j() }),
    }),
    fh = Gt.extend({
      method: ke("resources/unsubscribe"),
      params: cr.extend({ uri: j() }),
    }),
    ph = zr.extend({
      method: ke("notifications/resources/updated"),
      params: Es.extend({ uri: j() }),
    }),
    XS = re({
      name: j(),
      description: Q(j()),
      required: Q(_t()),
    }).passthrough(),
    e$ = $s.extend({
      description: Q(j()),
      arguments: Q(ue(XS)),
      _meta: Q(re({}).passthrough()),
    }),
    jc = Go.extend({ method: ke("prompts/list") }),
    hh = Wo.extend({ prompts: ue(e$) }),
    Dc = Gt.extend({
      method: ke("prompts/get"),
      params: cr.extend({ name: j(), arguments: Q(Ea(j())) }),
    }),
    Lc = re({
      type: ke("text"),
      text: j(),
      _meta: Q(re({}).passthrough()),
    }).passthrough(),
    zc = re({
      type: ke("image"),
      data: Ac,
      mimeType: j(),
      _meta: Q(re({}).passthrough()),
    }).passthrough(),
    qc = re({
      type: ke("audio"),
      data: Ac,
      mimeType: j(),
      _meta: Q(re({}).passthrough()),
    }).passthrough(),
    t$ = re({
      type: ke("resource"),
      resource: jt([ah, sh]),
      _meta: Q(re({}).passthrough()),
    }).passthrough(),
    r$ = oh.extend({ type: ke("resource_link") }),
    mh = jt([Lc, zc, qc, r$, t$]),
    n$ = re({ role: Lr(["user", "assistant"]), content: mh }).passthrough(),
    vh = ur.extend({ description: Q(j()), messages: ue(n$) }),
    gh = zr.extend({ method: ke("notifications/prompts/list_changed") }),
    a$ = re({
      title: Q(j()),
      readOnlyHint: Q(_t()),
      destructiveHint: Q(_t()),
      idempotentHint: Q(_t()),
      openWorldHint: Q(_t()),
    }).passthrough(),
    s$ = $s.extend({
      description: Q(j()),
      inputSchema: re({
        type: ke("object"),
        properties: Q(re({}).passthrough()),
        required: Q(ue(j())),
      }).passthrough(),
      outputSchema: Q(
        re({
          type: ke("object"),
          properties: Q(re({}).passthrough()),
          required: Q(ue(j())),
        }).passthrough()
      ),
      annotations: Q(a$),
      _meta: Q(re({}).passthrough()),
    }),
    Uc = Go.extend({ method: ke("tools/list") }),
    yh = Wo.extend({ tools: ue(s$) }),
    Yo = ur.extend({
      content: ue(mh).default([]),
      structuredContent: re({}).passthrough().optional(),
      isError: Q(_t()),
    });
  Yo.or(ur.extend({ toolResult: ba() }));
  const Fc = Gt.extend({
      method: ke("tools/call"),
      params: cr.extend({ name: j(), arguments: Q(Ea(ba())) }),
    }),
    _h = zr.extend({ method: ke("notifications/tools/list_changed") }),
    wh = Lr([
      "debug",
      "info",
      "notice",
      "warning",
      "error",
      "critical",
      "alert",
      "emergency",
    ]),
    Vc = Gt.extend({
      method: ke("logging/setLevel"),
      params: cr.extend({ level: wh }),
    }),
    bh = zr.extend({
      method: ke("notifications/message"),
      params: Es.extend({ level: wh, logger: Q(j()), data: ba() }),
    }),
    o$ = re({ name: j().optional() }).passthrough(),
    i$ = re({
      hints: Q(ue(o$)),
      costPriority: Q(St().min(0).max(1)),
      speedPriority: Q(St().min(0).max(1)),
      intelligencePriority: Q(St().min(0).max(1)),
    }).passthrough(),
    l$ = re({
      role: Lr(["user", "assistant"]),
      content: jt([Lc, zc, qc]),
    }).passthrough(),
    Eh = Gt.extend({
      method: ke("sampling/createMessage"),
      params: cr.extend({
        messages: ue(l$),
        systemPrompt: Q(j()),
        includeContext: Q(Lr(["none", "thisServer", "allServers"])),
        temperature: Q(St()),
        maxTokens: St().int(),
        stopSequences: Q(ue(j())),
        metadata: Q(re({}).passthrough()),
        modelPreferences: Q(i$),
      }),
    }),
    Zc = ur.extend({
      model: j(),
      stopReason: Q(Lr(["endTurn", "stopSequence", "maxTokens"]).or(j())),
      role: Lr(["user", "assistant"]),
      content: Zp("type", [Lc, zc, qc]),
    }),
    c$ = re({
      type: ke("boolean"),
      title: Q(j()),
      description: Q(j()),
      default: Q(_t()),
    }).passthrough(),
    u$ = re({
      type: ke("string"),
      title: Q(j()),
      description: Q(j()),
      minLength: Q(St()),
      maxLength: Q(St()),
      format: Q(Lr(["email", "uri", "date", "date-time"])),
    }).passthrough(),
    d$ = re({
      type: Lr(["number", "integer"]),
      title: Q(j()),
      description: Q(j()),
      minimum: Q(St()),
      maximum: Q(St()),
    }).passthrough(),
    f$ = re({
      type: ke("string"),
      title: Q(j()),
      description: Q(j()),
      enum: ue(j()),
      enumNames: Q(ue(j())),
    }).passthrough(),
    p$ = jt([c$, u$, d$, f$]),
    Sh = Gt.extend({
      method: ke("elicitation/create"),
      params: cr.extend({
        message: j(),
        requestedSchema: re({
          type: ke("object"),
          properties: Ea(j(), p$),
          required: Q(ue(j())),
        }).passthrough(),
      }),
    }),
    Hc = ur.extend({
      action: Lr(["accept", "decline", "cancel"]),
      content: Q(Ea(j(), ba())),
    }),
    h$ = re({ type: ke("ref/resource"), uri: j() }).passthrough(),
    m$ = re({ type: ke("ref/prompt"), name: j() }).passthrough(),
    Bc = Gt.extend({
      method: ke("completion/complete"),
      params: cr.extend({
        ref: jt([m$, h$]),
        argument: re({ name: j(), value: j() }).passthrough(),
        context: Q(re({ arguments: Q(Ea(j(), j())) })),
      }),
    }),
    $h = ur.extend({
      completion: re({
        values: ue(j()).max(100),
        total: Q(St().int()),
        hasMore: Q(_t()),
      }).passthrough(),
    }),
    v$ = re({
      uri: j().startsWith("file://"),
      name: Q(j()),
      _meta: Q(re({}).passthrough()),
    }).passthrough(),
    Ph = Gt.extend({ method: ke("roots/list") }),
    Jc = ur.extend({ roots: ue(v$) }),
    Th = zr.extend({ method: ke("notifications/roots/list_changed") });
  jt([Rc, th, Bc, Vc, Dc, jc, Qo, Nc, Mc, dh, fh, Fc, Uc]),
    jt([kc, Oc, Cc, Th]),
    jt([mn, Zc, Hc, Jc]),
    jt([Rc, Eh, Sh, Ph]),
    jt([kc, Oc, bh, ph, uh, _h, gh]),
    jt([mn, rh, $h, vh, hh, ih, lh, ch, Yo, yh]);
  class st extends Error {
    constructor(e, r, a) {
      super(`MCP error ${e}: ${r}`),
        (this.code = e),
        (this.data = a),
        (this.name = "McpError");
    }
  }
  const g$ = 6e4;
  class xh {
    constructor(e) {
      (this._options = e),
        (this._requestMessageId = 0),
        (this._requestHandlers = new Map()),
        (this._requestHandlerAbortControllers = new Map()),
        (this._notificationHandlers = new Map()),
        (this._responseHandlers = new Map()),
        (this._progressHandlers = new Map()),
        (this._timeoutInfo = new Map()),
        (this._pendingDebouncedNotifications = new Set()),
        this.setNotificationHandler(kc, (r) => {
          const a = this._requestHandlerAbortControllers.get(
            r.params.requestId
          );
          a == null || a.abort(r.params.reason);
        }),
        this.setNotificationHandler(Oc, (r) => {
          this._onprogress(r);
        }),
        this.setRequestHandler(Rc, (r) => ({}));
    }
    _setupTimeout(e, r, a, n, s = !1) {
      this._timeoutInfo.set(e, {
        timeoutId: setTimeout(n, r),
        startTime: Date.now(),
        timeout: r,
        maxTotalTimeout: a,
        resetTimeoutOnProgress: s,
        onTimeout: n,
      });
    }
    _resetTimeout(e) {
      const r = this._timeoutInfo.get(e);
      if (!r) return !1;
      const a = Date.now() - r.startTime;
      if (r.maxTotalTimeout && a >= r.maxTotalTimeout)
        throw (
          (this._timeoutInfo.delete(e),
          new st(rt.RequestTimeout, "Maximum total timeout exceeded", {
            maxTotalTimeout: r.maxTotalTimeout,
            totalElapsed: a,
          }))
        );
      return (
        clearTimeout(r.timeoutId),
        (r.timeoutId = setTimeout(r.onTimeout, r.timeout)),
        !0
      );
    }
    _cleanupTimeout(e) {
      const r = this._timeoutInfo.get(e);
      r && (clearTimeout(r.timeoutId), this._timeoutInfo.delete(e));
    }
    async connect(e) {
      var r, a, n;
      this._transport = e;
      const s =
        (r = this.transport) === null || r === void 0 ? void 0 : r.onclose;
      this._transport.onclose = () => {
        s == null || s(), this._onclose();
      };
      const o =
        (a = this.transport) === null || a === void 0 ? void 0 : a.onerror;
      this._transport.onerror = (l) => {
        o == null || o(l), this._onerror(l);
      };
      const i =
        (n = this._transport) === null || n === void 0 ? void 0 : n.onmessage;
      (this._transport.onmessage = (l, c) => {
        i == null || i(l, c),
          Ic(l) || JS(l)
            ? this._onresponse(l)
            : Wp(l)
            ? this._onrequest(l, c)
            : BS(l)
            ? this._onnotification(l)
            : this._onerror(
                new Error(`Unknown message type: ${JSON.stringify(l)}`)
              );
      }),
        await this._transport.start();
    }
    _onclose() {
      var e;
      const r = this._responseHandlers;
      (this._responseHandlers = new Map()),
        this._progressHandlers.clear(),
        this._pendingDebouncedNotifications.clear(),
        (this._transport = void 0),
        (e = this.onclose) === null || e === void 0 || e.call(this);
      const a = new st(rt.ConnectionClosed, "Connection closed");
      for (const n of r.values()) n(a);
    }
    _onerror(e) {
      var r;
      (r = this.onerror) === null || r === void 0 || r.call(this, e);
    }
    _onnotification(e) {
      var r;
      const a =
        (r = this._notificationHandlers.get(e.method)) !== null && r !== void 0
          ? r
          : this.fallbackNotificationHandler;
      a !== void 0 &&
        Promise.resolve()
          .then(() => a(e))
          .catch((n) =>
            this._onerror(
              new Error(`Uncaught error in notification handler: ${n}`)
            )
          );
    }
    _onrequest(e, r) {
      var a, n, s, o;
      const i =
        (a = this._requestHandlers.get(e.method)) !== null && a !== void 0
          ? a
          : this.fallbackRequestHandler;
      if (i === void 0) {
        (n = this._transport) === null ||
          n === void 0 ||
          n
            .send({
              jsonrpc: "2.0",
              id: e.id,
              error: { code: rt.MethodNotFound, message: "Method not found" },
            })
            .catch((u) =>
              this._onerror(new Error(`Failed to send an error response: ${u}`))
            );
        return;
      }
      const l = new AbortController();
      this._requestHandlerAbortControllers.set(e.id, l);
      const c = {
        signal: l.signal,
        sessionId:
          (s = this._transport) === null || s === void 0 ? void 0 : s.sessionId,
        _meta: (o = e.params) === null || o === void 0 ? void 0 : o._meta,
        sendNotification: (u) =>
          this.notification(u, { relatedRequestId: e.id }),
        sendRequest: (u, f, v) =>
          this.request(u, f, { ...v, relatedRequestId: e.id }),
        authInfo: r == null ? void 0 : r.authInfo,
        requestId: e.id,
        requestInfo: r == null ? void 0 : r.requestInfo,
      };
      Promise.resolve()
        .then(() => i(e, c))
        .then(
          (u) => {
            var f;
            if (!l.signal.aborted)
              return (f = this._transport) === null || f === void 0
                ? void 0
                : f.send({ result: u, jsonrpc: "2.0", id: e.id });
          },
          (u) => {
            var f, v;
            if (!l.signal.aborted)
              return (f = this._transport) === null || f === void 0
                ? void 0
                : f.send({
                    jsonrpc: "2.0",
                    id: e.id,
                    error: {
                      code: Number.isSafeInteger(u.code)
                        ? u.code
                        : rt.InternalError,
                      message:
                        (v = u.message) !== null && v !== void 0
                          ? v
                          : "Internal error",
                    },
                  });
          }
        )
        .catch((u) => this._onerror(new Error(`Failed to send response: ${u}`)))
        .finally(() => {
          this._requestHandlerAbortControllers.delete(e.id);
        });
    }
    _onprogress(e) {
      const { progressToken: r, ...a } = e.params,
        n = Number(r),
        s = this._progressHandlers.get(n);
      if (!s) {
        this._onerror(
          new Error(
            `Received a progress notification for an unknown token: ${JSON.stringify(
              e
            )}`
          )
        );
        return;
      }
      const o = this._responseHandlers.get(n),
        i = this._timeoutInfo.get(n);
      if (i && o && i.resetTimeoutOnProgress)
        try {
          this._resetTimeout(n);
        } catch (l) {
          o(l);
          return;
        }
      s(a);
    }
    _onresponse(e) {
      const r = Number(e.id),
        a = this._responseHandlers.get(r);
      if (a === void 0) {
        this._onerror(
          new Error(
            `Received a response for an unknown message ID: ${JSON.stringify(
              e
            )}`
          )
        );
        return;
      }
      if (
        (this._responseHandlers.delete(r),
        this._progressHandlers.delete(r),
        this._cleanupTimeout(r),
        Ic(e))
      )
        a(e);
      else {
        const n = new st(e.error.code, e.error.message, e.error.data);
        a(n);
      }
    }
    get transport() {
      return this._transport;
    }
    async close() {
      var e;
      await ((e = this._transport) === null || e === void 0
        ? void 0
        : e.close());
    }
    request(e, r, a) {
      const {
        relatedRequestId: n,
        resumptionToken: s,
        onresumptiontoken: o,
      } = a ?? {};
      return new Promise((i, l) => {
        var c, u, f, v, d, p;
        if (!this._transport) {
          l(new Error("Not connected"));
          return;
        }
        ((c = this._options) === null || c === void 0
          ? void 0
          : c.enforceStrictCapabilities) === !0 &&
          this.assertCapabilityForMethod(e.method),
          (u = a == null ? void 0 : a.signal) === null ||
            u === void 0 ||
            u.throwIfAborted();
        const g = this._requestMessageId++,
          m = { ...e, jsonrpc: "2.0", id: g };
        a != null &&
          a.onprogress &&
          (this._progressHandlers.set(g, a.onprogress),
          (m.params = {
            ...e.params,
            _meta: {
              ...(((f = e.params) === null || f === void 0
                ? void 0
                : f._meta) || {}),
              progressToken: g,
            },
          }));
        const h = (w) => {
          var E;
          this._responseHandlers.delete(g),
            this._progressHandlers.delete(g),
            this._cleanupTimeout(g),
            (E = this._transport) === null ||
              E === void 0 ||
              E.send(
                {
                  jsonrpc: "2.0",
                  method: "notifications/cancelled",
                  params: { requestId: g, reason: String(w) },
                },
                {
                  relatedRequestId: n,
                  resumptionToken: s,
                  onresumptiontoken: o,
                }
              ).catch((P) =>
                this._onerror(new Error(`Failed to send cancellation: ${P}`))
              ),
            l(w);
        };
        this._responseHandlers.set(g, (w) => {
          var E;
          if (
            !(
              !((E = a == null ? void 0 : a.signal) === null || E === void 0) &&
              E.aborted
            )
          ) {
            if (w instanceof Error) return l(w);
            try {
              const P = r.parse(w.result);
              i(P);
            } catch (P) {
              l(P);
            }
          }
        }),
          (v = a == null ? void 0 : a.signal) === null ||
            v === void 0 ||
            v.addEventListener("abort", () => {
              var w;
              h(
                (w = a == null ? void 0 : a.signal) === null || w === void 0
                  ? void 0
                  : w.reason
              );
            });
        const y =
            (d = a == null ? void 0 : a.timeout) !== null && d !== void 0
              ? d
              : g$,
          _ = () =>
            h(new st(rt.RequestTimeout, "Request timed out", { timeout: y }));
        this._setupTimeout(
          g,
          y,
          a == null ? void 0 : a.maxTotalTimeout,
          _,
          (p = a == null ? void 0 : a.resetTimeoutOnProgress) !== null &&
            p !== void 0
            ? p
            : !1
        ),
          this._transport
            .send(m, {
              relatedRequestId: n,
              resumptionToken: s,
              onresumptiontoken: o,
            })
            .catch((w) => {
              this._cleanupTimeout(g), l(w);
            });
      });
    }
    async notification(e, r) {
      var a, n;
      if (!this._transport) throw new Error("Not connected");
      if (
        (this.assertNotificationCapability(e.method),
        ((n =
          (a = this._options) === null || a === void 0
            ? void 0
            : a.debouncedNotificationMethods) !== null && n !== void 0
          ? n
          : []
        ).includes(e.method) &&
          !e.params &&
          !(r != null && r.relatedRequestId))
      ) {
        if (this._pendingDebouncedNotifications.has(e.method)) return;
        this._pendingDebouncedNotifications.add(e.method),
          Promise.resolve().then(() => {
            var l;
            if (
              (this._pendingDebouncedNotifications.delete(e.method),
              !this._transport)
            )
              return;
            const c = { ...e, jsonrpc: "2.0" };
            (l = this._transport) === null ||
              l === void 0 ||
              l.send(c, r).catch((u) => this._onerror(u));
          });
        return;
      }
      const i = { ...e, jsonrpc: "2.0" };
      await this._transport.send(i, r);
    }
    setRequestHandler(e, r) {
      const a = e.shape.method.value;
      this.assertRequestHandlerCapability(a),
        this._requestHandlers.set(a, (n, s) =>
          Promise.resolve(r(e.parse(n), s))
        );
    }
    removeRequestHandler(e) {
      this._requestHandlers.delete(e);
    }
    assertCanSetRequestHandler(e) {
      if (this._requestHandlers.has(e))
        throw new Error(
          `A request handler for ${e} already exists, which would be overridden`
        );
    }
    setNotificationHandler(e, r) {
      this._notificationHandlers.set(e.shape.method.value, (a) =>
        Promise.resolve(r(e.parse(a)))
      );
    }
    removeNotificationHandler(e) {
      this._notificationHandlers.delete(e);
    }
  }
  function Ih(t, e) {
    return Object.entries(e).reduce(
      (r, [a, n]) => (
        n && typeof n == "object"
          ? (r[a] = r[a] ? { ...r[a], ...n } : n)
          : (r[a] = n),
        r
      ),
      { ...t }
    );
  }
  var Kc = { exports: {} };
  /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function (
    t,
    e
  ) {
    (function (r, a) {
      a(e);
    })(Ha, function (r) {
      function a() {
        for (var I = arguments.length, $ = Array(I), C = 0; C < I; C++)
          $[C] = arguments[C];
        if ($.length > 1) {
          $[0] = $[0].slice(0, -1);
          for (var F = $.length - 1, U = 1; U < F; ++U)
            $[U] = $[U].slice(1, -1);
          return ($[F] = $[F].slice(1)), $.join("");
        } else return $[0];
      }
      function n(I) {
        return "(?:" + I + ")";
      }
      function s(I) {
        return I === void 0
          ? "undefined"
          : I === null
          ? "null"
          : Object.prototype.toString
              .call(I)
              .split(" ")
              .pop()
              .split("]")
              .shift()
              .toLowerCase();
      }
      function o(I) {
        return I.toUpperCase();
      }
      function i(I) {
        return I != null
          ? I instanceof Array
            ? I
            : typeof I.length != "number" || I.split || I.setInterval || I.call
            ? [I]
            : Array.prototype.slice.call(I)
          : [];
      }
      function l(I, $) {
        var C = I;
        if ($) for (var F in $) C[F] = $[F];
        return C;
      }
      function c(I) {
        var $ = "[A-Za-z]",
          C = "[0-9]",
          F = a(C, "[A-Fa-f]"),
          U = n(
            n("%[EFef]" + F + "%" + F + F + "%" + F + F) +
              "|" +
              n("%[89A-Fa-f]" + F + "%" + F + F) +
              "|" +
              n("%" + F + F)
          ),
          ye = "[\\:\\/\\?\\#\\[\\]\\@]",
          _e = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
          Ue = a(ye, _e),
          lt = I
            ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]"
            : "[]",
          bt = I ? "[\\uE000-\\uF8FF]" : "[]",
          De = a($, C, "[\\-\\.\\_\\~]", lt);
        n($ + a($, C, "[\\+\\-\\.]") + "*"),
          n(n(U + "|" + a(De, _e, "[\\:]")) + "*");
        var nt = n(
            n("25[0-5]") +
              "|" +
              n("2[0-4]" + C) +
              "|" +
              n("1" + C + C) +
              "|" +
              n("0?[1-9]" + C) +
              "|0?0?" +
              C
          ),
          Et = n(nt + "\\." + nt + "\\." + nt + "\\." + nt),
          Ie = n(F + "{1,4}"),
          dt = n(n(Ie + "\\:" + Ie) + "|" + Et),
          Pt = n(n(Ie + "\\:") + "{6}" + dt),
          ft = n("\\:\\:" + n(Ie + "\\:") + "{5}" + dt),
          kn = n(n(Ie) + "?\\:\\:" + n(Ie + "\\:") + "{4}" + dt),
          Kr = n(
            n(n(Ie + "\\:") + "{0,1}" + Ie) +
              "?\\:\\:" +
              n(Ie + "\\:") +
              "{3}" +
              dt
          ),
          Gr = n(
            n(n(Ie + "\\:") + "{0,2}" + Ie) +
              "?\\:\\:" +
              n(Ie + "\\:") +
              "{2}" +
              dt
          ),
          Za = n(n(n(Ie + "\\:") + "{0,3}" + Ie) + "?\\:\\:" + Ie + "\\:" + dt),
          ra = n(n(n(Ie + "\\:") + "{0,4}" + Ie) + "?\\:\\:" + dt),
          vr = n(n(n(Ie + "\\:") + "{0,5}" + Ie) + "?\\:\\:" + Ie),
          Wr = n(n(n(Ie + "\\:") + "{0,6}" + Ie) + "?\\:\\:"),
          na = n([Pt, ft, kn, Kr, Gr, Za, ra, vr, Wr].join("|")),
          ln = n(n(De + "|" + U) + "+");
        n("[vV]" + F + "+\\." + a(De, _e, "[\\:]") + "+"),
          n(n(U + "|" + a(De, _e)) + "*");
        var vo = n(U + "|" + a(De, _e, "[\\:\\@]"));
        return (
          n(n(U + "|" + a(De, _e, "[\\@]")) + "+"),
          n(n(vo + "|" + a("[\\/\\?]", bt)) + "*"),
          {
            NOT_SCHEME: new RegExp(a("[^]", $, C, "[\\+\\-\\.]"), "g"),
            NOT_USERINFO: new RegExp(a("[^\\%\\:]", De, _e), "g"),
            NOT_HOST: new RegExp(a("[^\\%\\[\\]\\:]", De, _e), "g"),
            NOT_PATH: new RegExp(a("[^\\%\\/\\:\\@]", De, _e), "g"),
            NOT_PATH_NOSCHEME: new RegExp(a("[^\\%\\/\\@]", De, _e), "g"),
            NOT_QUERY: new RegExp(
              a("[^\\%]", De, _e, "[\\:\\@\\/\\?]", bt),
              "g"
            ),
            NOT_FRAGMENT: new RegExp(
              a("[^\\%]", De, _e, "[\\:\\@\\/\\?]"),
              "g"
            ),
            ESCAPE: new RegExp(a("[^]", De, _e), "g"),
            UNRESERVED: new RegExp(De, "g"),
            OTHER_CHARS: new RegExp(a("[^\\%]", De, Ue), "g"),
            PCT_ENCODED: new RegExp(U, "g"),
            IPV4ADDRESS: new RegExp("^(" + Et + ")$"),
            IPV6ADDRESS: new RegExp(
              "^\\[?(" +
                na +
                ")" +
                n(n("\\%25|\\%(?!" + F + "{2})") + "(" + ln + ")") +
                "?\\]?$"
            ),
          }
        );
      }
      var u = c(!1),
        f = c(!0),
        v = (function () {
          function I($, C) {
            var F = [],
              U = !0,
              ye = !1,
              _e = void 0;
            try {
              for (
                var Ue = $[Symbol.iterator](), lt;
                !(U = (lt = Ue.next()).done) &&
                (F.push(lt.value), !(C && F.length === C));
                U = !0
              );
            } catch (bt) {
              (ye = !0), (_e = bt);
            } finally {
              try {
                !U && Ue.return && Ue.return();
              } finally {
                if (ye) throw _e;
              }
            }
            return F;
          }
          return function ($, C) {
            if (Array.isArray($)) return $;
            if (Symbol.iterator in Object($)) return I($, C);
            throw new TypeError(
              "Invalid attempt to destructure non-iterable instance"
            );
          };
        })(),
        d = function (I) {
          if (Array.isArray(I)) {
            for (var $ = 0, C = Array(I.length); $ < I.length; $++) C[$] = I[$];
            return C;
          } else return Array.from(I);
        },
        p = 2147483647,
        g = 36,
        m = 1,
        h = 26,
        y = 38,
        _ = 700,
        w = 72,
        E = 128,
        P = "-",
        x = /^xn--/,
        A = /[^\0-\x7E]/,
        M = /[\x2E\u3002\uFF0E\uFF61]/g,
        H = {
          overflow: "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input",
        },
        V = g - m,
        J = Math.floor,
        z = String.fromCharCode;
      function Z(I) {
        throw new RangeError(H[I]);
      }
      function te(I, $) {
        for (var C = [], F = I.length; F--; ) C[F] = $(I[F]);
        return C;
      }
      function me(I, $) {
        var C = I.split("@"),
          F = "";
        C.length > 1 && ((F = C[0] + "@"), (I = C[1])), (I = I.replace(M, "."));
        var U = I.split("."),
          ye = te(U, $).join(".");
        return F + ye;
      }
      function ge(I) {
        for (var $ = [], C = 0, F = I.length; C < F; ) {
          var U = I.charCodeAt(C++);
          if (U >= 55296 && U <= 56319 && C < F) {
            var ye = I.charCodeAt(C++);
            (ye & 64512) == 56320
              ? $.push(((U & 1023) << 10) + (ye & 1023) + 65536)
              : ($.push(U), C--);
          } else $.push(U);
        }
        return $;
      }
      var N = function ($) {
          return String.fromCodePoint.apply(String, d($));
        },
        se = function ($) {
          return $ - 48 < 10
            ? $ - 22
            : $ - 65 < 26
            ? $ - 65
            : $ - 97 < 26
            ? $ - 97
            : g;
        },
        D = function ($, C) {
          return $ + 22 + 75 * ($ < 26) - ((C != 0) << 5);
        },
        k = function ($, C, F) {
          var U = 0;
          for (
            $ = F ? J($ / _) : $ >> 1, $ += J($ / C);
            $ > (V * h) >> 1;
            U += g
          )
            $ = J($ / V);
          return J(U + ((V + 1) * $) / ($ + y));
        },
        L = function ($) {
          var C = [],
            F = $.length,
            U = 0,
            ye = E,
            _e = w,
            Ue = $.lastIndexOf(P);
          Ue < 0 && (Ue = 0);
          for (var lt = 0; lt < Ue; ++lt)
            $.charCodeAt(lt) >= 128 && Z("not-basic"), C.push($.charCodeAt(lt));
          for (var bt = Ue > 0 ? Ue + 1 : 0; bt < F; ) {
            for (var De = U, nt = 1, Et = g; ; Et += g) {
              bt >= F && Z("invalid-input");
              var Ie = se($.charCodeAt(bt++));
              (Ie >= g || Ie > J((p - U) / nt)) && Z("overflow"),
                (U += Ie * nt);
              var dt = Et <= _e ? m : Et >= _e + h ? h : Et - _e;
              if (Ie < dt) break;
              var Pt = g - dt;
              nt > J(p / Pt) && Z("overflow"), (nt *= Pt);
            }
            var ft = C.length + 1;
            (_e = k(U - De, ft, De == 0)),
              J(U / ft) > p - ye && Z("overflow"),
              (ye += J(U / ft)),
              (U %= ft),
              C.splice(U++, 0, ye);
          }
          return String.fromCodePoint.apply(String, C);
        },
        R = function ($) {
          var C = [];
          $ = ge($);
          var F = $.length,
            U = E,
            ye = 0,
            _e = w,
            Ue = !0,
            lt = !1,
            bt = void 0;
          try {
            for (
              var De = $[Symbol.iterator](), nt;
              !(Ue = (nt = De.next()).done);
              Ue = !0
            ) {
              var Et = nt.value;
              Et < 128 && C.push(z(Et));
            }
          } catch (go) {
            (lt = !0), (bt = go);
          } finally {
            try {
              !Ue && De.return && De.return();
            } finally {
              if (lt) throw bt;
            }
          }
          var Ie = C.length,
            dt = Ie;
          for (Ie && C.push(P); dt < F; ) {
            var Pt = p,
              ft = !0,
              kn = !1,
              Kr = void 0;
            try {
              for (
                var Gr = $[Symbol.iterator](), Za;
                !(ft = (Za = Gr.next()).done);
                ft = !0
              ) {
                var ra = Za.value;
                ra >= U && ra < Pt && (Pt = ra);
              }
            } catch (go) {
              (kn = !0), (Kr = go);
            } finally {
              try {
                !ft && Gr.return && Gr.return();
              } finally {
                if (kn) throw Kr;
              }
            }
            var vr = dt + 1;
            Pt - U > J((p - ye) / vr) && Z("overflow"),
              (ye += (Pt - U) * vr),
              (U = Pt);
            var Wr = !0,
              na = !1,
              ln = void 0;
            try {
              for (
                var vo = $[Symbol.iterator](), O0;
                !(Wr = (O0 = vo.next()).done);
                Wr = !0
              ) {
                var A0 = O0.value;
                if ((A0 < U && ++ye > p && Z("overflow"), A0 == U)) {
                  for (var hl = ye, ml = g; ; ml += g) {
                    var vl = ml <= _e ? m : ml >= _e + h ? h : ml - _e;
                    if (hl < vl) break;
                    var N0 = hl - vl,
                      M0 = g - vl;
                    C.push(z(D(vl + (N0 % M0), 0))), (hl = J(N0 / M0));
                  }
                  C.push(z(D(hl, 0))),
                    (_e = k(ye, vr, dt == Ie)),
                    (ye = 0),
                    ++dt;
                }
              }
            } catch (go) {
              (na = !0), (ln = go);
            } finally {
              try {
                !Wr && vo.return && vo.return();
              } finally {
                if (na) throw ln;
              }
            }
            ++ye, ++U;
          }
          return C.join("");
        },
        b = function ($) {
          return me($, function (C) {
            return x.test(C) ? L(C.slice(4).toLowerCase()) : C;
          });
        },
        T = function ($) {
          return me($, function (C) {
            return A.test(C) ? "xn--" + R(C) : C;
          });
        },
        q = {
          version: "2.1.0",
          ucs2: { decode: ge, encode: N },
          decode: L,
          encode: R,
          toASCII: T,
          toUnicode: b,
        },
        G = {};
      function ee(I) {
        var $ = I.charCodeAt(0),
          C = void 0;
        return (
          $ < 16
            ? (C = "%0" + $.toString(16).toUpperCase())
            : $ < 128
            ? (C = "%" + $.toString(16).toUpperCase())
            : $ < 2048
            ? (C =
                "%" +
                (($ >> 6) | 192).toString(16).toUpperCase() +
                "%" +
                (($ & 63) | 128).toString(16).toUpperCase())
            : (C =
                "%" +
                (($ >> 12) | 224).toString(16).toUpperCase() +
                "%" +
                ((($ >> 6) & 63) | 128).toString(16).toUpperCase() +
                "%" +
                (($ & 63) | 128).toString(16).toUpperCase()),
          C
        );
      }
      function fe(I) {
        for (var $ = "", C = 0, F = I.length; C < F; ) {
          var U = parseInt(I.substr(C + 1, 2), 16);
          if (U < 128) ($ += String.fromCharCode(U)), (C += 3);
          else if (U >= 194 && U < 224) {
            if (F - C >= 6) {
              var ye = parseInt(I.substr(C + 4, 2), 16);
              $ += String.fromCharCode(((U & 31) << 6) | (ye & 63));
            } else $ += I.substr(C, 6);
            C += 6;
          } else if (U >= 224) {
            if (F - C >= 9) {
              var _e = parseInt(I.substr(C + 4, 2), 16),
                Ue = parseInt(I.substr(C + 7, 2), 16);
              $ += String.fromCharCode(
                ((U & 15) << 12) | ((_e & 63) << 6) | (Ue & 63)
              );
            } else $ += I.substr(C, 9);
            C += 9;
          } else ($ += I.substr(C, 3)), (C += 3);
        }
        return $;
      }
      function le(I, $) {
        function C(F) {
          var U = fe(F);
          return U.match($.UNRESERVED) ? U : F;
        }
        return (
          I.scheme &&
            (I.scheme = String(I.scheme)
              .replace($.PCT_ENCODED, C)
              .toLowerCase()
              .replace($.NOT_SCHEME, "")),
          I.userinfo !== void 0 &&
            (I.userinfo = String(I.userinfo)
              .replace($.PCT_ENCODED, C)
              .replace($.NOT_USERINFO, ee)
              .replace($.PCT_ENCODED, o)),
          I.host !== void 0 &&
            (I.host = String(I.host)
              .replace($.PCT_ENCODED, C)
              .toLowerCase()
              .replace($.NOT_HOST, ee)
              .replace($.PCT_ENCODED, o)),
          I.path !== void 0 &&
            (I.path = String(I.path)
              .replace($.PCT_ENCODED, C)
              .replace(I.scheme ? $.NOT_PATH : $.NOT_PATH_NOSCHEME, ee)
              .replace($.PCT_ENCODED, o)),
          I.query !== void 0 &&
            (I.query = String(I.query)
              .replace($.PCT_ENCODED, C)
              .replace($.NOT_QUERY, ee)
              .replace($.PCT_ENCODED, o)),
          I.fragment !== void 0 &&
            (I.fragment = String(I.fragment)
              .replace($.PCT_ENCODED, C)
              .replace($.NOT_FRAGMENT, ee)
              .replace($.PCT_ENCODED, o)),
          I
        );
      }
      function ve(I) {
        return I.replace(/^0*(.*)/, "$1") || "0";
      }
      function Ae(I, $) {
        var C = I.match($.IPV4ADDRESS) || [],
          F = v(C, 2),
          U = F[1];
        return U ? U.split(".").map(ve).join(".") : I;
      }
      function Pe(I, $) {
        var C = I.match($.IPV6ADDRESS) || [],
          F = v(C, 3),
          U = F[1],
          ye = F[2];
        if (U) {
          for (
            var _e = U.toLowerCase().split("::").reverse(),
              Ue = v(_e, 2),
              lt = Ue[0],
              bt = Ue[1],
              De = bt ? bt.split(":").map(ve) : [],
              nt = lt.split(":").map(ve),
              Et = $.IPV4ADDRESS.test(nt[nt.length - 1]),
              Ie = Et ? 7 : 8,
              dt = nt.length - Ie,
              Pt = Array(Ie),
              ft = 0;
            ft < Ie;
            ++ft
          )
            Pt[ft] = De[ft] || nt[dt + ft] || "";
          Et && (Pt[Ie - 1] = Ae(Pt[Ie - 1], $));
          var kn = Pt.reduce(function (vr, Wr, na) {
              if (!Wr || Wr === "0") {
                var ln = vr[vr.length - 1];
                ln && ln.index + ln.length === na
                  ? ln.length++
                  : vr.push({ index: na, length: 1 });
              }
              return vr;
            }, []),
            Kr = kn.sort(function (vr, Wr) {
              return Wr.length - vr.length;
            })[0],
            Gr = void 0;
          if (Kr && Kr.length > 1) {
            var Za = Pt.slice(0, Kr.index),
              ra = Pt.slice(Kr.index + Kr.length);
            Gr = Za.join(":") + "::" + ra.join(":");
          } else Gr = Pt.join(":");
          return ye && (Gr += "%" + ye), Gr;
        } else return I;
      }
      var xe =
          /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,
        Te = "".match(/(){0}/)[1] === void 0;
      function ze(I) {
        var $ =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
          C = {},
          F = $.iri !== !1 ? f : u;
        $.reference === "suffix" &&
          (I = ($.scheme ? $.scheme + ":" : "") + "//" + I);
        var U = I.match(xe);
        if (U) {
          Te
            ? ((C.scheme = U[1]),
              (C.userinfo = U[3]),
              (C.host = U[4]),
              (C.port = parseInt(U[5], 10)),
              (C.path = U[6] || ""),
              (C.query = U[7]),
              (C.fragment = U[8]),
              isNaN(C.port) && (C.port = U[5]))
            : ((C.scheme = U[1] || void 0),
              (C.userinfo = I.indexOf("@") !== -1 ? U[3] : void 0),
              (C.host = I.indexOf("//") !== -1 ? U[4] : void 0),
              (C.port = parseInt(U[5], 10)),
              (C.path = U[6] || ""),
              (C.query = I.indexOf("?") !== -1 ? U[7] : void 0),
              (C.fragment = I.indexOf("#") !== -1 ? U[8] : void 0),
              isNaN(C.port) &&
                (C.port = I.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/)
                  ? U[4]
                  : void 0)),
            C.host && (C.host = Pe(Ae(C.host, F), F)),
            C.scheme === void 0 &&
            C.userinfo === void 0 &&
            C.host === void 0 &&
            C.port === void 0 &&
            !C.path &&
            C.query === void 0
              ? (C.reference = "same-document")
              : C.scheme === void 0
              ? (C.reference = "relative")
              : C.fragment === void 0
              ? (C.reference = "absolute")
              : (C.reference = "uri"),
            $.reference &&
              $.reference !== "suffix" &&
              $.reference !== C.reference &&
              (C.error =
                C.error || "URI is not a " + $.reference + " reference.");
          var ye = G[($.scheme || C.scheme || "").toLowerCase()];
          if (!$.unicodeSupport && (!ye || !ye.unicodeSupport)) {
            if (C.host && ($.domainHost || (ye && ye.domainHost)))
              try {
                C.host = q.toASCII(
                  C.host.replace(F.PCT_ENCODED, fe).toLowerCase()
                );
              } catch (_e) {
                C.error =
                  C.error ||
                  "Host's domain name can not be converted to ASCII via punycode: " +
                    _e;
              }
            le(C, u);
          } else le(C, F);
          ye && ye.parse && ye.parse(C, $);
        } else C.error = C.error || "URI can not be parsed.";
        return C;
      }
      function ae(I, $) {
        var C = $.iri !== !1 ? f : u,
          F = [];
        return (
          I.userinfo !== void 0 && (F.push(I.userinfo), F.push("@")),
          I.host !== void 0 &&
            F.push(
              Pe(Ae(String(I.host), C), C).replace(
                C.IPV6ADDRESS,
                function (U, ye, _e) {
                  return "[" + ye + (_e ? "%25" + _e : "") + "]";
                }
              )
            ),
          (typeof I.port == "number" || typeof I.port == "string") &&
            (F.push(":"), F.push(String(I.port))),
          F.length ? F.join("") : void 0
        );
      }
      var qe = /^\.\.?\//,
        we = /^\/\.(\/|$)/,
        ht = /^\/\.\.(\/|$)/,
        Zt = /^\/?(?:.|\n)*?(?=\/|$)/;
      function Ge(I) {
        for (var $ = []; I.length; )
          if (I.match(qe)) I = I.replace(qe, "");
          else if (I.match(we)) I = I.replace(we, "/");
          else if (I.match(ht)) (I = I.replace(ht, "/")), $.pop();
          else if (I === "." || I === "..") I = "";
          else {
            var C = I.match(Zt);
            if (C) {
              var F = C[0];
              (I = I.slice(F.length)), $.push(F);
            } else throw new Error("Unexpected dot segment condition");
          }
        return $.join("");
      }
      function We(I) {
        var $ =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
          C = $.iri ? f : u,
          F = [],
          U = G[($.scheme || I.scheme || "").toLowerCase()];
        if (
          (U && U.serialize && U.serialize(I, $),
          I.host && !C.IPV6ADDRESS.test(I.host))
        ) {
          if ($.domainHost || (U && U.domainHost))
            try {
              I.host = $.iri
                ? q.toUnicode(I.host)
                : q.toASCII(I.host.replace(C.PCT_ENCODED, fe).toLowerCase());
            } catch (Ue) {
              I.error =
                I.error ||
                "Host's domain name can not be converted to " +
                  ($.iri ? "Unicode" : "ASCII") +
                  " via punycode: " +
                  Ue;
            }
        }
        le(I, C),
          $.reference !== "suffix" &&
            I.scheme &&
            (F.push(I.scheme), F.push(":"));
        var ye = ae(I, $);
        if (
          (ye !== void 0 &&
            ($.reference !== "suffix" && F.push("//"),
            F.push(ye),
            I.path && I.path.charAt(0) !== "/" && F.push("/")),
          I.path !== void 0)
        ) {
          var _e = I.path;
          !$.absolutePath && (!U || !U.absolutePath) && (_e = Ge(_e)),
            ye === void 0 && (_e = _e.replace(/^\/\//, "/%2F")),
            F.push(_e);
        }
        return (
          I.query !== void 0 && (F.push("?"), F.push(I.query)),
          I.fragment !== void 0 && (F.push("#"), F.push(I.fragment)),
          F.join("")
        );
      }
      function tt(I, $) {
        var C =
            arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
          F = arguments[3],
          U = {};
        return (
          F || ((I = ze(We(I, C), C)), ($ = ze(We($, C), C))),
          (C = C || {}),
          !C.tolerant && $.scheme
            ? ((U.scheme = $.scheme),
              (U.userinfo = $.userinfo),
              (U.host = $.host),
              (U.port = $.port),
              (U.path = Ge($.path || "")),
              (U.query = $.query))
            : ($.userinfo !== void 0 || $.host !== void 0 || $.port !== void 0
                ? ((U.userinfo = $.userinfo),
                  (U.host = $.host),
                  (U.port = $.port),
                  (U.path = Ge($.path || "")),
                  (U.query = $.query))
                : ($.path
                    ? ($.path.charAt(0) === "/"
                        ? (U.path = Ge($.path))
                        : ((I.userinfo !== void 0 ||
                            I.host !== void 0 ||
                            I.port !== void 0) &&
                          !I.path
                            ? (U.path = "/" + $.path)
                            : I.path
                            ? (U.path =
                                I.path.slice(0, I.path.lastIndexOf("/") + 1) +
                                $.path)
                            : (U.path = $.path),
                          (U.path = Ge(U.path))),
                      (U.query = $.query))
                    : ((U.path = I.path),
                      $.query !== void 0
                        ? (U.query = $.query)
                        : (U.query = I.query)),
                  (U.userinfo = I.userinfo),
                  (U.host = I.host),
                  (U.port = I.port)),
              (U.scheme = I.scheme)),
          (U.fragment = $.fragment),
          U
        );
      }
      function gt(I, $, C) {
        var F = l({ scheme: "null" }, C);
        return We(tt(ze(I, F), ze($, F), F, !0), F);
      }
      function Ht(I, $) {
        return (
          typeof I == "string"
            ? (I = We(ze(I, $), $))
            : s(I) === "object" && (I = ze(We(I, $), $)),
          I
        );
      }
      function Dt(I, $, C) {
        return (
          typeof I == "string"
            ? (I = We(ze(I, C), C))
            : s(I) === "object" && (I = We(I, C)),
          typeof $ == "string"
            ? ($ = We(ze($, C), C))
            : s($) === "object" && ($ = We($, C)),
          I === $
        );
      }
      function Ir(I, $) {
        return (
          I && I.toString().replace(!$ || !$.iri ? u.ESCAPE : f.ESCAPE, ee)
        );
      }
      function Ze(I, $) {
        return (
          I &&
          I.toString().replace(!$ || !$.iri ? u.PCT_ENCODED : f.PCT_ENCODED, fe)
        );
      }
      var Lt = {
          scheme: "http",
          domainHost: !0,
          parse: function ($, C) {
            return (
              $.host || ($.error = $.error || "HTTP URIs must have a host."), $
            );
          },
          serialize: function ($, C) {
            var F = String($.scheme).toLowerCase() === "https";
            return (
              ($.port === (F ? 443 : 80) || $.port === "") && ($.port = void 0),
              $.path || ($.path = "/"),
              $
            );
          },
        },
        Tn = {
          scheme: "https",
          domainHost: Lt.domainHost,
          parse: Lt.parse,
          serialize: Lt.serialize,
        };
      function io(I) {
        return typeof I.secure == "boolean"
          ? I.secure
          : String(I.scheme).toLowerCase() === "wss";
      }
      var hr = {
          scheme: "ws",
          domainHost: !0,
          parse: function ($, C) {
            var F = $;
            return (
              (F.secure = io(F)),
              (F.resourceName =
                (F.path || "/") + (F.query ? "?" + F.query : "")),
              (F.path = void 0),
              (F.query = void 0),
              F
            );
          },
          serialize: function ($, C) {
            if (
              (($.port === (io($) ? 443 : 80) || $.port === "") &&
                ($.port = void 0),
              typeof $.secure == "boolean" &&
                (($.scheme = $.secure ? "wss" : "ws"), ($.secure = void 0)),
              $.resourceName)
            ) {
              var F = $.resourceName.split("?"),
                U = v(F, 2),
                ye = U[0],
                _e = U[1];
              ($.path = ye && ye !== "/" ? ye : void 0),
                ($.query = _e),
                ($.resourceName = void 0);
            }
            return ($.fragment = void 0), $;
          },
        },
        lo = {
          scheme: "wss",
          domainHost: hr.domainHost,
          parse: hr.parse,
          serialize: hr.serialize,
        },
        sf = {},
        pl =
          "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]",
        Bt = "[0-9A-Fa-f]",
        co = n(
          n("%[EFef]" + Bt + "%" + Bt + Bt + "%" + Bt + Bt) +
            "|" +
            n("%[89A-Fa-f]" + Bt + "%" + Bt + Bt) +
            "|" +
            n("%" + Bt + Bt)
        ),
        uo = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]",
        fo = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]",
        xn = a(fo, '[\\"\\\\]'),
        or = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]",
        po = new RegExp(pl, "g"),
        on = new RegExp(co, "g"),
        mr = new RegExp(a("[^]", uo, "[\\.]", '[\\"]', xn), "g"),
        ho = new RegExp(a("[^]", pl, or), "g"),
        be = ho;
      function wt(I) {
        var $ = fe(I);
        return $.match(po) ? $ : I;
      }
      var In = {
          scheme: "mailto",
          parse: function ($, C) {
            var F = $,
              U = (F.to = F.path ? F.path.split(",") : []);
            if (((F.path = void 0), F.query)) {
              for (
                var ye = !1,
                  _e = {},
                  Ue = F.query.split("&"),
                  lt = 0,
                  bt = Ue.length;
                lt < bt;
                ++lt
              ) {
                var De = Ue[lt].split("=");
                switch (De[0]) {
                  case "to":
                    for (
                      var nt = De[1].split(","), Et = 0, Ie = nt.length;
                      Et < Ie;
                      ++Et
                    )
                      U.push(nt[Et]);
                    break;
                  case "subject":
                    F.subject = Ze(De[1], C);
                    break;
                  case "body":
                    F.body = Ze(De[1], C);
                    break;
                  default:
                    (ye = !0), (_e[Ze(De[0], C)] = Ze(De[1], C));
                    break;
                }
              }
              ye && (F.headers = _e);
            }
            F.query = void 0;
            for (var dt = 0, Pt = U.length; dt < Pt; ++dt) {
              var ft = U[dt].split("@");
              if (((ft[0] = Ze(ft[0])), C.unicodeSupport))
                ft[1] = Ze(ft[1], C).toLowerCase();
              else
                try {
                  ft[1] = q.toASCII(Ze(ft[1], C).toLowerCase());
                } catch (kn) {
                  F.error =
                    F.error ||
                    "Email address's domain name can not be converted to ASCII via punycode: " +
                      kn;
                }
              U[dt] = ft.join("@");
            }
            return F;
          },
          serialize: function ($, C) {
            var F = $,
              U = i($.to);
            if (U) {
              for (var ye = 0, _e = U.length; ye < _e; ++ye) {
                var Ue = String(U[ye]),
                  lt = Ue.lastIndexOf("@"),
                  bt = Ue.slice(0, lt)
                    .replace(on, wt)
                    .replace(on, o)
                    .replace(mr, ee),
                  De = Ue.slice(lt + 1);
                try {
                  De = C.iri
                    ? q.toUnicode(De)
                    : q.toASCII(Ze(De, C).toLowerCase());
                } catch (dt) {
                  F.error =
                    F.error ||
                    "Email address's domain name can not be converted to " +
                      (C.iri ? "Unicode" : "ASCII") +
                      " via punycode: " +
                      dt;
                }
                U[ye] = bt + "@" + De;
              }
              F.path = U.join(",");
            }
            var nt = ($.headers = $.headers || {});
            $.subject && (nt.subject = $.subject), $.body && (nt.body = $.body);
            var Et = [];
            for (var Ie in nt)
              nt[Ie] !== sf[Ie] &&
                Et.push(
                  Ie.replace(on, wt).replace(on, o).replace(ho, ee) +
                    "=" +
                    nt[Ie].replace(on, wt).replace(on, o).replace(be, ee)
                );
            return Et.length && (F.query = Et.join("&")), F;
          },
        },
        ea = /^([^\:]+)\:(.*)/,
        ta = {
          scheme: "urn",
          parse: function ($, C) {
            var F = $.path && $.path.match(ea),
              U = $;
            if (F) {
              var ye = C.scheme || U.scheme || "urn",
                _e = F[1].toLowerCase(),
                Ue = F[2],
                lt = ye + ":" + (C.nid || _e),
                bt = G[lt];
              (U.nid = _e),
                (U.nss = Ue),
                (U.path = void 0),
                bt && (U = bt.parse(U, C));
            } else U.error = U.error || "URN can not be parsed.";
            return U;
          },
          serialize: function ($, C) {
            var F = C.scheme || $.scheme || "urn",
              U = $.nid,
              ye = F + ":" + (C.nid || U),
              _e = G[ye];
            _e && ($ = _e.serialize($, C));
            var Ue = $,
              lt = $.nss;
            return (Ue.path = (U || C.nid) + ":" + lt), Ue;
          },
        },
        kr = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/,
        mo = {
          scheme: "urn:uuid",
          parse: function ($, C) {
            var F = $;
            return (
              (F.uuid = F.nss),
              (F.nss = void 0),
              !C.tolerant &&
                (!F.uuid || !F.uuid.match(kr)) &&
                (F.error = F.error || "UUID is not valid."),
              F
            );
          },
          serialize: function ($, C) {
            var F = $;
            return (F.nss = ($.uuid || "").toLowerCase()), F;
          },
        };
      (G[Lt.scheme] = Lt),
        (G[Tn.scheme] = Tn),
        (G[hr.scheme] = hr),
        (G[lo.scheme] = lo),
        (G[In.scheme] = In),
        (G[ta.scheme] = ta),
        (G[mo.scheme] = mo),
        (r.SCHEMES = G),
        (r.pctEncChar = ee),
        (r.pctDecChars = fe),
        (r.parse = ze),
        (r.removeDotSegments = Ge),
        (r.serialize = We),
        (r.resolveComponents = tt),
        (r.resolve = gt),
        (r.normalize = Ht),
        (r.equal = Dt),
        (r.escapeComponent = Ir),
        (r.unescapeComponent = Ze),
        Object.defineProperty(r, "__esModule", { value: !0 });
    });
  })(Kc, Kc.exports);
  var y$ = Kc.exports,
    _$ = function (e) {
      for (var r = 0, a = e.length, n = 0, s; n < a; )
        r++,
          (s = e.charCodeAt(n++)),
          s >= 55296 &&
            s <= 56319 &&
            n < a &&
            ((s = e.charCodeAt(n)), (s & 64512) == 56320 && n++);
      return r;
    },
    Sa = {
      copy: w$,
      checkDataType: Gc,
      checkDataTypes: b$,
      coerceToTypes: E$,
      toHash: Wc,
      getProperty: Qc,
      escapeQuotes: Yc,
      equal: Ka,
      ucs2length: _$,
      varOccurences: P$,
      varReplace: T$,
      schemaHasRules: x$,
      schemaHasRulesExcept: I$,
      schemaUnknownRules: k$,
      toQuotedString: Xc,
      getPathExpr: C$,
      getPath: R$,
      getData: N$,
      unescapeFragment: M$,
      unescapeJsonPointer: tu,
      escapeFragment: j$,
      escapeJsonPointer: eu,
    };
  function w$(t, e) {
    e = e || {};
    for (var r in t) e[r] = t[r];
    return e;
  }
  function Gc(t, e, r, a) {
    var n = a ? " !== " : " === ",
      s = a ? " || " : " && ",
      o = a ? "!" : "",
      i = a ? "" : "!";
    switch (t) {
      case "null":
        return e + n + "null";
      case "array":
        return o + "Array.isArray(" + e + ")";
      case "object":
        return (
          "(" +
          o +
          e +
          s +
          "typeof " +
          e +
          n +
          '"object"' +
          s +
          i +
          "Array.isArray(" +
          e +
          "))"
        );
      case "integer":
        return (
          "(typeof " +
          e +
          n +
          '"number"' +
          s +
          i +
          "(" +
          e +
          " % 1)" +
          s +
          e +
          n +
          e +
          (r ? s + o + "isFinite(" + e + ")" : "") +
          ")"
        );
      case "number":
        return (
          "(typeof " +
          e +
          n +
          '"' +
          t +
          '"' +
          (r ? s + o + "isFinite(" + e + ")" : "") +
          ")"
        );
      default:
        return "typeof " + e + n + '"' + t + '"';
    }
  }
  function b$(t, e, r) {
    switch (t.length) {
      case 1:
        return Gc(t[0], e, r, !0);
      default:
        var a = "",
          n = Wc(t);
        n.array &&
          n.object &&
          ((a = n.null ? "(" : "(!" + e + " || "),
          (a += "typeof " + e + ' !== "object")'),
          delete n.null,
          delete n.array,
          delete n.object),
          n.number && delete n.integer;
        for (var s in n) a += (a ? " && " : "") + Gc(s, e, r, !0);
        return a;
    }
  }
  var kh = Wc(["string", "number", "integer", "boolean", "null"]);
  function E$(t, e) {
    if (Array.isArray(e)) {
      for (var r = [], a = 0; a < e.length; a++) {
        var n = e[a];
        (kh[n] || (t === "array" && n === "array")) && (r[r.length] = n);
      }
      if (r.length) return r;
    } else {
      if (kh[e]) return [e];
      if (t === "array" && e === "array") return ["array"];
    }
  }
  function Wc(t) {
    for (var e = {}, r = 0; r < t.length; r++) e[t[r]] = !0;
    return e;
  }
  var S$ = /^[a-z$_][a-z$_0-9]*$/i,
    $$ = /'|\\/g;
  function Qc(t) {
    return typeof t == "number"
      ? "[" + t + "]"
      : S$.test(t)
      ? "." + t
      : "['" + Yc(t) + "']";
  }
  function Yc(t) {
    return t
      .replace($$, "\\$&")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/\f/g, "\\f")
      .replace(/\t/g, "\\t");
  }
  function P$(t, e) {
    e += "[^0-9]";
    var r = t.match(new RegExp(e, "g"));
    return r ? r.length : 0;
  }
  function T$(t, e, r) {
    return (
      (e += "([^0-9])"),
      (r = r.replace(/\$/g, "$$$$")),
      t.replace(new RegExp(e, "g"), r + "$1")
    );
  }
  function x$(t, e) {
    if (typeof t == "boolean") return !t;
    for (var r in t) if (e[r]) return !0;
  }
  function I$(t, e, r) {
    if (typeof t == "boolean") return !t && r != "not";
    for (var a in t) if (a != r && e[a]) return !0;
  }
  function k$(t, e) {
    if (typeof t != "boolean") {
      for (var r in t) if (!e[r]) return r;
    }
  }
  function Xc(t) {
    return "'" + Yc(t) + "'";
  }
  function C$(t, e, r, a) {
    var n = r
      ? "'/' + " + e + (a ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')")
      : a
      ? "'[' + " + e + " + ']'"
      : "'[\\'' + " + e + " + '\\']'";
    return Ch(t, n);
  }
  function R$(t, e, r) {
    var a = Xc(r ? "/" + eu(e) : Qc(e));
    return Ch(t, a);
  }
  var O$ = /^\/(?:[^~]|~0|~1)*$/,
    A$ = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function N$(t, e, r) {
    var a, n, s, o;
    if (t === "") return "rootData";
    if (t[0] == "/") {
      if (!O$.test(t)) throw new Error("Invalid JSON-pointer: " + t);
      (n = t), (s = "rootData");
    } else {
      if (((o = t.match(A$)), !o))
        throw new Error("Invalid JSON-pointer: " + t);
      if (((a = +o[1]), (n = o[2]), n == "#")) {
        if (a >= e)
          throw new Error(
            "Cannot access property/index " +
              a +
              " levels up, current level is " +
              e
          );
        return r[e - a];
      }
      if (a > e)
        throw new Error(
          "Cannot access data " + a + " levels up, current level is " + e
        );
      if (((s = "data" + (e - a || "")), !n)) return s;
    }
    for (var i = s, l = n.split("/"), c = 0; c < l.length; c++) {
      var u = l[c];
      u && ((s += Qc(tu(u))), (i += " && " + s));
    }
    return i;
  }
  function Ch(t, e) {
    return t == '""' ? e : (t + " + " + e).replace(/([^\\])' \+ '/g, "$1");
  }
  function M$(t) {
    return tu(decodeURIComponent(t));
  }
  function j$(t) {
    return encodeURIComponent(eu(t));
  }
  function eu(t) {
    return t.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function tu(t) {
    return t.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  var D$ = Sa,
    Rh = L$;
  function L$(t) {
    D$.copy(t, this);
  }
  var Oh = { exports: {} },
    vn = (Oh.exports = function (t, e, r) {
      typeof e == "function" && ((r = e), (e = {})), (r = e.cb || r);
      var a = typeof r == "function" ? r : r.pre || function () {},
        n = r.post || function () {};
      Xo(e, a, n, t, "", t);
    });
  (vn.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
  }),
    (vn.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 }),
    (vn.propsKeywords = {
      definitions: !0,
      properties: !0,
      patternProperties: !0,
      dependencies: !0,
    }),
    (vn.skipKeywords = {
      default: !0,
      enum: !0,
      const: !0,
      required: !0,
      maximum: !0,
      minimum: !0,
      exclusiveMaximum: !0,
      exclusiveMinimum: !0,
      multipleOf: !0,
      maxLength: !0,
      minLength: !0,
      pattern: !0,
      format: !0,
      maxItems: !0,
      minItems: !0,
      uniqueItems: !0,
      maxProperties: !0,
      minProperties: !0,
    });
  function Xo(t, e, r, a, n, s, o, i, l, c) {
    if (a && typeof a == "object" && !Array.isArray(a)) {
      e(a, n, s, o, i, l, c);
      for (var u in a) {
        var f = a[u];
        if (Array.isArray(f)) {
          if (u in vn.arrayKeywords)
            for (var v = 0; v < f.length; v++)
              Xo(t, e, r, f[v], n + "/" + u + "/" + v, s, n, u, a, v);
        } else if (u in vn.propsKeywords) {
          if (f && typeof f == "object")
            for (var d in f)
              Xo(t, e, r, f[d], n + "/" + u + "/" + z$(d), s, n, u, a, d);
        } else
          (u in vn.keywords || (t.allKeys && !(u in vn.skipKeywords))) &&
            Xo(t, e, r, f, n + "/" + u, s, n, u, a);
      }
      r(a, n, s, o, i, l, c);
    }
  }
  function z$(t) {
    return t.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  var q$ = Oh.exports,
    Ps = y$,
    Ah = Ka,
    ei = Sa,
    ti = Rh,
    U$ = q$,
    ru = gn;
  (gn.normalizeId = yn),
    (gn.fullPath = ni),
    (gn.url = ai),
    (gn.ids = B$),
    (gn.inlineRef = nu),
    (gn.schema = ri);
  function gn(t, e, r) {
    var a = this._refs[r];
    if (typeof a == "string")
      if (this._refs[a]) a = this._refs[a];
      else return gn.call(this, t, e, a);
    if (((a = a || this._schemas[r]), a instanceof ti))
      return nu(a.schema, this._opts.inlineRefs)
        ? a.schema
        : a.validate || this._compile(a);
    var n = ri.call(this, e, r),
      s,
      o,
      i;
    return (
      n && ((s = n.schema), (e = n.root), (i = n.baseId)),
      s instanceof ti
        ? (o = s.validate || t.call(this, s.schema, e, void 0, i))
        : s !== void 0 &&
          (o = nu(s, this._opts.inlineRefs)
            ? s
            : t.call(this, s, e, void 0, i)),
      o
    );
  }
  function ri(t, e) {
    var r = Ps.parse(e),
      a = Mh(r),
      n = ni(this._getId(t.schema));
    if (Object.keys(t.schema).length === 0 || a !== n) {
      var s = yn(a),
        o = this._refs[s];
      if (typeof o == "string") return F$.call(this, t, o, r);
      if (o instanceof ti) o.validate || this._compile(o), (t = o);
      else if (((o = this._schemas[s]), o instanceof ti)) {
        if ((o.validate || this._compile(o), s == yn(e)))
          return { schema: o, root: t, baseId: n };
        t = o;
      } else return;
      if (!t.schema) return;
      n = ni(this._getId(t.schema));
    }
    return Nh.call(this, r, n, t.schema, t);
  }
  function F$(t, e, r) {
    var a = ri.call(this, t, e);
    if (a) {
      var n = a.schema,
        s = a.baseId;
      t = a.root;
      var o = this._getId(n);
      return o && (s = ai(s, o)), Nh.call(this, r, s, n, t);
    }
  }
  var V$ = ei.toHash([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions",
  ]);
  function Nh(t, e, r, a) {
    if (((t.fragment = t.fragment || ""), t.fragment.slice(0, 1) == "/")) {
      for (var n = t.fragment.split("/"), s = 1; s < n.length; s++) {
        var o = n[s];
        if (o) {
          if (((o = ei.unescapeFragment(o)), (r = r[o]), r === void 0)) break;
          var i;
          if (!V$[o] && ((i = this._getId(r)), i && (e = ai(e, i)), r.$ref)) {
            var l = ai(e, r.$ref),
              c = ri.call(this, a, l);
            c && ((r = c.schema), (a = c.root), (e = c.baseId));
          }
        }
      }
      if (r !== void 0 && r !== a.schema)
        return { schema: r, root: a, baseId: e };
    }
  }
  var Z$ = ei.toHash([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
  ]);
  function nu(t, e) {
    if (e === !1) return !1;
    if (e === void 0 || e === !0) return au(t);
    if (e) return su(t) <= e;
  }
  function au(t) {
    var e;
    if (Array.isArray(t)) {
      for (var r = 0; r < t.length; r++)
        if (((e = t[r]), typeof e == "object" && !au(e))) return !1;
    } else for (var a in t) if (a == "$ref" || ((e = t[a]), typeof e == "object" && !au(e))) return !1;
    return !0;
  }
  function su(t) {
    var e = 0,
      r;
    if (Array.isArray(t)) {
      for (var a = 0; a < t.length; a++)
        if (((r = t[a]), typeof r == "object" && (e += su(r)), e == 1 / 0))
          return 1 / 0;
    } else
      for (var n in t) {
        if (n == "$ref") return 1 / 0;
        if (Z$[n]) e++;
        else if (
          ((r = t[n]), typeof r == "object" && (e += su(r) + 1), e == 1 / 0)
        )
          return 1 / 0;
      }
    return e;
  }
  function ni(t, e) {
    e !== !1 && (t = yn(t));
    var r = Ps.parse(t);
    return Mh(r);
  }
  function Mh(t) {
    return Ps.serialize(t).split("#")[0] + "#";
  }
  var H$ = /#\/?$/;
  function yn(t) {
    return t ? t.replace(H$, "") : "";
  }
  function ai(t, e) {
    return (e = yn(e)), Ps.resolve(t, e);
  }
  function B$(t) {
    var e = yn(this._getId(t)),
      r = { "": e },
      a = { "": ni(e, !1) },
      n = {},
      s = this;
    return (
      U$(t, { allKeys: !0 }, function (o, i, l, c, u, f, v) {
        if (i !== "") {
          var d = s._getId(o),
            p = r[c],
            g = a[c] + "/" + u;
          if (
            (v !== void 0 &&
              (g += "/" + (typeof v == "number" ? v : ei.escapeFragment(v))),
            typeof d == "string")
          ) {
            d = p = yn(p ? Ps.resolve(p, d) : d);
            var m = s._refs[d];
            if ((typeof m == "string" && (m = s._refs[m]), m && m.schema)) {
              if (!Ah(o, m.schema))
                throw new Error(
                  'id "' + d + '" resolves to more than one schema'
                );
            } else if (d != yn(g))
              if (d[0] == "#") {
                if (n[d] && !Ah(o, n[d]))
                  throw new Error(
                    'id "' + d + '" resolves to more than one schema'
                  );
                n[d] = o;
              } else s._refs[d] = g;
          }
          (r[i] = p), (a[i] = g);
        }
      }),
      n
    );
  }
  var ou = ru,
    iu = { Validation: jh(J$), MissingRef: jh(lu) };
  function J$(t) {
    (this.message = "validation failed"),
      (this.errors = t),
      (this.ajv = this.validation = !0);
  }
  lu.message = function (t, e) {
    return "can't resolve reference " + e + " from id " + t;
  };
  function lu(t, e, r) {
    (this.message = r || lu.message(t, e)),
      (this.missingRef = ou.url(t, e)),
      (this.missingSchema = ou.normalizeId(ou.fullPath(this.missingRef)));
  }
  function jh(t) {
    return (
      (t.prototype = Object.create(Error.prototype)),
      (t.prototype.constructor = t),
      t
    );
  }
  var Dh = function (t, e) {
      e || (e = {}), typeof e == "function" && (e = { cmp: e });
      var r = typeof e.cycles == "boolean" ? e.cycles : !1,
        a =
          e.cmp &&
          (function (s) {
            return function (o) {
              return function (i, l) {
                var c = { key: i, value: o[i] },
                  u = { key: l, value: o[l] };
                return s(c, u);
              };
            };
          })(e.cmp),
        n = [];
      return (function s(o) {
        if (
          (o && o.toJSON && typeof o.toJSON == "function" && (o = o.toJSON()),
          o !== void 0)
        ) {
          if (typeof o == "number") return isFinite(o) ? "" + o : "null";
          if (typeof o != "object") return JSON.stringify(o);
          var i, l;
          if (Array.isArray(o)) {
            for (l = "[", i = 0; i < o.length; i++)
              i && (l += ","), (l += s(o[i]) || "null");
            return l + "]";
          }
          if (o === null) return "null";
          if (n.indexOf(o) !== -1) {
            if (r) return JSON.stringify("__cycle__");
            throw new TypeError("Converting circular structure to JSON");
          }
          var c = n.push(o) - 1,
            u = Object.keys(o).sort(a && a(o));
          for (l = "", i = 0; i < u.length; i++) {
            var f = u[i],
              v = s(o[f]);
            v && (l && (l += ","), (l += JSON.stringify(f) + ":" + v));
          }
          return n.splice(c, 1), "{" + l + "}";
        }
      })(t);
    },
    Lh = function (e, r, a) {
      var n = "",
        s = e.schema.$async === !0,
        o = e.util.schemaHasRulesExcept(e.schema, e.RULES.all, "$ref"),
        i = e.self._getId(e.schema);
      if (e.opts.strictKeywords) {
        var l = e.util.schemaUnknownRules(e.schema, e.RULES.keywords);
        if (l) {
          var c = "unknown keyword: " + l;
          if (e.opts.strictKeywords === "log") e.logger.warn(c);
          else throw new Error(c);
        }
      }
      if (
        (e.isTop &&
          ((n += " var validate = "),
          s && ((e.async = !0), (n += "async ")),
          (n +=
            "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; "),
          i &&
            (e.opts.sourceCode || e.opts.processCode) &&
            (n += " " + ("/*# sourceURL=" + i + " */") + " ")),
        typeof e.schema == "boolean" || !(o || e.schema.$ref))
      ) {
        var r = "false schema",
          u = e.level,
          f = e.dataLevel,
          v = e.schema[r],
          d = e.schemaPath + e.util.getProperty(r),
          p = e.errSchemaPath + "/" + r,
          E = !e.opts.allErrors,
          A,
          g = "data" + (f || ""),
          w = "valid" + u;
        if (e.schema === !1) {
          e.isTop ? (E = !0) : (n += " var " + w + " = false; ");
          var m = m || [];
          m.push(n),
            (n = ""),
            e.createErrors !== !1
              ? ((n +=
                  " { keyword: '" +
                  (A || "false schema") +
                  "' , dataPath: (dataPath || '') + " +
                  e.errorPath +
                  " , schemaPath: " +
                  e.util.toQuotedString(p) +
                  " , params: {} "),
                e.opts.messages !== !1 &&
                  (n += " , message: 'boolean schema is false' "),
                e.opts.verbose &&
                  (n +=
                    " , schema: false , parentSchema: validate.schema" +
                    e.schemaPath +
                    " , data: " +
                    g +
                    " "),
                (n += " } "))
              : (n += " {} ");
          var h = n;
          (n = m.pop()),
            !e.compositeRule && E
              ? e.async
                ? (n += " throw new ValidationError([" + h + "]); ")
                : (n += " validate.errors = [" + h + "]; return false; ")
              : (n +=
                  " var err = " +
                  h +
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ");
        } else
          e.isTop
            ? s
              ? (n += " return data; ")
              : (n += " validate.errors = null; return true; ")
            : (n += " var " + w + " = true; ");
        return e.isTop && (n += " }; return validate; "), n;
      }
      if (e.isTop) {
        var y = e.isTop,
          u = (e.level = 0),
          f = (e.dataLevel = 0),
          g = "data";
        if (
          ((e.rootId = e.resolve.fullPath(e.self._getId(e.root.schema))),
          (e.baseId = e.baseId || e.rootId),
          delete e.isTop,
          (e.dataPathArr = [""]),
          e.schema.default !== void 0 &&
            e.opts.useDefaults &&
            e.opts.strictDefaults)
        ) {
          var _ = "default is ignored in the schema root";
          if (e.opts.strictDefaults === "log") e.logger.warn(_);
          else throw new Error(_);
        }
        (n += " var vErrors = null; "),
          (n += " var errors = 0;     "),
          (n += " if (rootData === undefined) rootData = data; ");
      } else {
        var u = e.level,
          f = e.dataLevel,
          g = "data" + (f || "");
        if ((i && (e.baseId = e.resolve.url(e.baseId, i)), s && !e.async))
          throw new Error("async schema in sync schema");
        n += " var errs_" + u + " = errors;";
      }
      var w = "valid" + u,
        E = !e.opts.allErrors,
        P = "",
        x = "",
        A,
        M = e.schema.type,
        H = Array.isArray(M);
      if (
        (M &&
          e.opts.nullable &&
          e.schema.nullable === !0 &&
          (H
            ? M.indexOf("null") == -1 && (M = M.concat("null"))
            : M != "null" && ((M = [M, "null"]), (H = !0))),
        H && M.length == 1 && ((M = M[0]), (H = !1)),
        e.schema.$ref && o)
      ) {
        if (e.opts.extendRefs == "fail")
          throw new Error(
            '$ref: validation keywords used in schema at path "' +
              e.errSchemaPath +
              '" (see option extendRefs)'
          );
        e.opts.extendRefs !== !0 &&
          ((o = !1),
          e.logger.warn(
            '$ref: keywords ignored in schema at path "' + e.errSchemaPath + '"'
          ));
      }
      if (
        (e.schema.$comment &&
          e.opts.$comment &&
          (n += " " + e.RULES.all.$comment.code(e, "$comment")),
        M)
      ) {
        if (e.opts.coerceTypes)
          var V = e.util.coerceToTypes(e.opts.coerceTypes, M);
        var J = e.RULES.types[M];
        if (V || H || J === !0 || (J && !we(J))) {
          var d = e.schemaPath + ".type",
            p = e.errSchemaPath + "/type",
            d = e.schemaPath + ".type",
            p = e.errSchemaPath + "/type",
            z = H ? "checkDataTypes" : "checkDataType";
          if (
            ((n +=
              " if (" + e.util[z](M, g, e.opts.strictNumbers, !0) + ") { "),
            V)
          ) {
            var Z = "dataType" + u,
              te = "coerced" + u;
            (n +=
              " var " +
              Z +
              " = typeof " +
              g +
              "; var " +
              te +
              " = undefined; "),
              e.opts.coerceTypes == "array" &&
                (n +=
                  " if (" +
                  Z +
                  " == 'object' && Array.isArray(" +
                  g +
                  ") && " +
                  g +
                  ".length == 1) { " +
                  g +
                  " = " +
                  g +
                  "[0]; " +
                  Z +
                  " = typeof " +
                  g +
                  "; if (" +
                  e.util.checkDataType(e.schema.type, g, e.opts.strictNumbers) +
                  ") " +
                  te +
                  " = " +
                  g +
                  "; } "),
              (n += " if (" + te + " !== undefined) ; ");
            var me = V;
            if (me)
              for (var ge, N = -1, se = me.length - 1; N < se; )
                (ge = me[(N += 1)]),
                  ge == "string"
                    ? (n +=
                        " else if (" +
                        Z +
                        " == 'number' || " +
                        Z +
                        " == 'boolean') " +
                        te +
                        " = '' + " +
                        g +
                        "; else if (" +
                        g +
                        " === null) " +
                        te +
                        " = ''; ")
                    : ge == "number" || ge == "integer"
                    ? ((n +=
                        " else if (" +
                        Z +
                        " == 'boolean' || " +
                        g +
                        " === null || (" +
                        Z +
                        " == 'string' && " +
                        g +
                        " && " +
                        g +
                        " == +" +
                        g +
                        " "),
                      ge == "integer" && (n += " && !(" + g + " % 1)"),
                      (n += ")) " + te + " = +" + g + "; "))
                    : ge == "boolean"
                    ? (n +=
                        " else if (" +
                        g +
                        " === 'false' || " +
                        g +
                        " === 0 || " +
                        g +
                        " === null) " +
                        te +
                        " = false; else if (" +
                        g +
                        " === 'true' || " +
                        g +
                        " === 1) " +
                        te +
                        " = true; ")
                    : ge == "null"
                    ? (n +=
                        " else if (" +
                        g +
                        " === '' || " +
                        g +
                        " === 0 || " +
                        g +
                        " === false) " +
                        te +
                        " = null; ")
                    : e.opts.coerceTypes == "array" &&
                      ge == "array" &&
                      (n +=
                        " else if (" +
                        Z +
                        " == 'string' || " +
                        Z +
                        " == 'number' || " +
                        Z +
                        " == 'boolean' || " +
                        g +
                        " == null) " +
                        te +
                        " = [" +
                        g +
                        "]; ");
            n += " else {   ";
            var m = m || [];
            m.push(n),
              (n = ""),
              e.createErrors !== !1
                ? ((n +=
                    " { keyword: '" +
                    (A || "type") +
                    "' , dataPath: (dataPath || '') + " +
                    e.errorPath +
                    " , schemaPath: " +
                    e.util.toQuotedString(p) +
                    " , params: { type: '"),
                  H ? (n += "" + M.join(",")) : (n += "" + M),
                  (n += "' } "),
                  e.opts.messages !== !1 &&
                    ((n += " , message: 'should be "),
                    H ? (n += "" + M.join(",")) : (n += "" + M),
                    (n += "' ")),
                  e.opts.verbose &&
                    (n +=
                      " , schema: validate.schema" +
                      d +
                      " , parentSchema: validate.schema" +
                      e.schemaPath +
                      " , data: " +
                      g +
                      " "),
                  (n += " } "))
                : (n += " {} ");
            var h = n;
            (n = m.pop()),
              !e.compositeRule && E
                ? e.async
                  ? (n += " throw new ValidationError([" + h + "]); ")
                  : (n += " validate.errors = [" + h + "]; return false; ")
                : (n +=
                    " var err = " +
                    h +
                    ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
              (n += " } if (" + te + " !== undefined) {  ");
            var D = f ? "data" + (f - 1 || "") : "parentData",
              k = f ? e.dataPathArr[f] : "parentDataProperty";
            (n += " " + g + " = " + te + "; "),
              f || (n += "if (" + D + " !== undefined)"),
              (n += " " + D + "[" + k + "] = " + te + "; } ");
          } else {
            var m = m || [];
            m.push(n),
              (n = ""),
              e.createErrors !== !1
                ? ((n +=
                    " { keyword: '" +
                    (A || "type") +
                    "' , dataPath: (dataPath || '') + " +
                    e.errorPath +
                    " , schemaPath: " +
                    e.util.toQuotedString(p) +
                    " , params: { type: '"),
                  H ? (n += "" + M.join(",")) : (n += "" + M),
                  (n += "' } "),
                  e.opts.messages !== !1 &&
                    ((n += " , message: 'should be "),
                    H ? (n += "" + M.join(",")) : (n += "" + M),
                    (n += "' ")),
                  e.opts.verbose &&
                    (n +=
                      " , schema: validate.schema" +
                      d +
                      " , parentSchema: validate.schema" +
                      e.schemaPath +
                      " , data: " +
                      g +
                      " "),
                  (n += " } "))
                : (n += " {} ");
            var h = n;
            (n = m.pop()),
              !e.compositeRule && E
                ? e.async
                  ? (n += " throw new ValidationError([" + h + "]); ")
                  : (n += " validate.errors = [" + h + "]; return false; ")
                : (n +=
                    " var err = " +
                    h +
                    ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ");
          }
          n += " } ";
        }
      }
      if (e.schema.$ref && !o)
        (n += " " + e.RULES.all.$ref.code(e, "$ref") + " "),
          E &&
            ((n += " } if (errors === "),
            y ? (n += "0") : (n += "errs_" + u),
            (n += ") { "),
            (x += "}"));
      else {
        var L = e.RULES;
        if (L) {
          for (var J, R = -1, b = L.length - 1; R < b; )
            if (((J = L[(R += 1)]), we(J))) {
              if (
                (J.type &&
                  (n +=
                    " if (" +
                    e.util.checkDataType(J.type, g, e.opts.strictNumbers) +
                    ") { "),
                e.opts.useDefaults)
              ) {
                if (J.type == "object" && e.schema.properties) {
                  var v = e.schema.properties,
                    T = Object.keys(v),
                    q = T;
                  if (q)
                    for (var G, ee = -1, fe = q.length - 1; ee < fe; ) {
                      G = q[(ee += 1)];
                      var le = v[G];
                      if (le.default !== void 0) {
                        var ve = g + e.util.getProperty(G);
                        if (e.compositeRule) {
                          if (e.opts.strictDefaults) {
                            var _ = "default is ignored for: " + ve;
                            if (e.opts.strictDefaults === "log")
                              e.logger.warn(_);
                            else throw new Error(_);
                          }
                        } else
                          (n += " if (" + ve + " === undefined "),
                            e.opts.useDefaults == "empty" &&
                              (n +=
                                " || " +
                                ve +
                                " === null || " +
                                ve +
                                " === '' "),
                            (n += " ) " + ve + " = "),
                            e.opts.useDefaults == "shared"
                              ? (n += " " + e.useDefault(le.default) + " ")
                              : (n += " " + JSON.stringify(le.default) + " "),
                            (n += "; ");
                      }
                    }
                } else if (J.type == "array" && Array.isArray(e.schema.items)) {
                  var Ae = e.schema.items;
                  if (Ae) {
                    for (var le, N = -1, Pe = Ae.length - 1; N < Pe; )
                      if (((le = Ae[(N += 1)]), le.default !== void 0)) {
                        var ve = g + "[" + N + "]";
                        if (e.compositeRule) {
                          if (e.opts.strictDefaults) {
                            var _ = "default is ignored for: " + ve;
                            if (e.opts.strictDefaults === "log")
                              e.logger.warn(_);
                            else throw new Error(_);
                          }
                        } else
                          (n += " if (" + ve + " === undefined "),
                            e.opts.useDefaults == "empty" &&
                              (n +=
                                " || " +
                                ve +
                                " === null || " +
                                ve +
                                " === '' "),
                            (n += " ) " + ve + " = "),
                            e.opts.useDefaults == "shared"
                              ? (n += " " + e.useDefault(le.default) + " ")
                              : (n += " " + JSON.stringify(le.default) + " "),
                            (n += "; ");
                      }
                  }
                }
              }
              var xe = J.rules;
              if (xe) {
                for (var Te, ze = -1, ae = xe.length - 1; ze < ae; )
                  if (((Te = xe[(ze += 1)]), ht(Te))) {
                    var qe = Te.code(e, Te.keyword, J.type);
                    qe && ((n += " " + qe + " "), E && (P += "}"));
                  }
              }
              if (
                (E && ((n += " " + P + " "), (P = "")),
                J.type && ((n += " } "), M && M === J.type && !V))
              ) {
                n += " else { ";
                var d = e.schemaPath + ".type",
                  p = e.errSchemaPath + "/type",
                  m = m || [];
                m.push(n),
                  (n = ""),
                  e.createErrors !== !1
                    ? ((n +=
                        " { keyword: '" +
                        (A || "type") +
                        "' , dataPath: (dataPath || '') + " +
                        e.errorPath +
                        " , schemaPath: " +
                        e.util.toQuotedString(p) +
                        " , params: { type: '"),
                      H ? (n += "" + M.join(",")) : (n += "" + M),
                      (n += "' } "),
                      e.opts.messages !== !1 &&
                        ((n += " , message: 'should be "),
                        H ? (n += "" + M.join(",")) : (n += "" + M),
                        (n += "' ")),
                      e.opts.verbose &&
                        (n +=
                          " , schema: validate.schema" +
                          d +
                          " , parentSchema: validate.schema" +
                          e.schemaPath +
                          " , data: " +
                          g +
                          " "),
                      (n += " } "))
                    : (n += " {} ");
                var h = n;
                (n = m.pop()),
                  !e.compositeRule && E
                    ? e.async
                      ? (n += " throw new ValidationError([" + h + "]); ")
                      : (n += " validate.errors = [" + h + "]; return false; ")
                    : (n +=
                        " var err = " +
                        h +
                        ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
                  (n += " } ");
              }
              E &&
                ((n += " if (errors === "),
                y ? (n += "0") : (n += "errs_" + u),
                (n += ") { "),
                (x += "}"));
            }
        }
      }
      E && (n += " " + x + " "),
        y
          ? (s
              ? ((n += " if (errors === 0) return data;           "),
                (n += " else throw new ValidationError(vErrors); "))
              : ((n += " validate.errors = vErrors; "),
                (n += " return errors === 0;       ")),
            (n += " }; return validate;"))
          : (n += " var " + w + " = errors === errs_" + u + ";");
      function we(Ge) {
        for (var We = Ge.rules, tt = 0; tt < We.length; tt++)
          if (ht(We[tt])) return !0;
      }
      function ht(Ge) {
        return e.schema[Ge.keyword] !== void 0 || (Ge.implements && Zt(Ge));
      }
      function Zt(Ge) {
        for (var We = Ge.implements, tt = 0; tt < We.length; tt++)
          if (e.schema[We[tt]] !== void 0) return !0;
      }
      return n;
    },
    si = ru,
    oi = Sa,
    zh = iu,
    K$ = Dh,
    qh = Lh,
    G$ = oi.ucs2length,
    W$ = Ka,
    Q$ = zh.Validation,
    Y$ = cu;
  function cu(t, e, r, a) {
    var n = this,
      s = this._opts,
      o = [void 0],
      i = {},
      l = [],
      c = {},
      u = [],
      f = {},
      v = [];
    e = e || { schema: t, refVal: o, refs: i };
    var d = X$.call(this, t, e, a),
      p = this._compilations[d.index];
    if (d.compiling) return (p.callValidate = _);
    var g = this._formats,
      m = this.RULES;
    try {
      var h = w(t, e, r, a);
      p.validate = h;
      var y = p.callValidate;
      return (
        y &&
          ((y.schema = h.schema),
          (y.errors = null),
          (y.refs = h.refs),
          (y.refVal = h.refVal),
          (y.root = h.root),
          (y.$async = h.$async),
          s.sourceCode && (y.source = h.source)),
        h
      );
    } finally {
      eP.call(this, t, e, a);
    }
    function _() {
      var z = p.validate,
        Z = z.apply(this, arguments);
      return (_.errors = z.errors), Z;
    }
    function w(z, Z, te, me) {
      var ge = !Z || (Z && Z.schema == z);
      if (Z.schema != e.schema) return cu.call(n, z, Z, te, me);
      var N = z.$async === !0,
        se = qh({
          isTop: !0,
          schema: z,
          isRoot: ge,
          baseId: me,
          root: Z,
          schemaPath: "",
          errSchemaPath: "#",
          errorPath: '""',
          MissingRefError: zh.MissingRef,
          RULES: m,
          validate: qh,
          util: oi,
          resolve: si,
          resolveRef: E,
          usePattern: H,
          useDefault: V,
          useCustomRule: J,
          opts: s,
          formats: g,
          logger: n.logger,
          self: n,
        });
      (se = ii(o, nP) + ii(l, tP) + ii(u, rP) + ii(v, aP) + se),
        s.processCode && (se = s.processCode(se, z));
      var D;
      try {
        var k = new Function(
          "self",
          "RULES",
          "formats",
          "root",
          "refVal",
          "defaults",
          "customRules",
          "equal",
          "ucs2length",
          "ValidationError",
          se
        );
        (D = k(n, m, g, e, o, u, v, W$, G$, Q$)), (o[0] = D);
      } catch (L) {
        throw (n.logger.error("Error compiling schema, function code:", se), L);
      }
      return (
        (D.schema = z),
        (D.errors = null),
        (D.refs = i),
        (D.refVal = o),
        (D.root = ge ? D : Z),
        N && (D.$async = !0),
        s.sourceCode === !0 &&
          (D.source = { code: se, patterns: l, defaults: u }),
        D
      );
    }
    function E(z, Z, te) {
      Z = si.url(z, Z);
      var me = i[Z],
        ge,
        N;
      if (me !== void 0)
        return (ge = o[me]), (N = "refVal[" + me + "]"), M(ge, N);
      if (!te && e.refs) {
        var se = e.refs[Z];
        if (se !== void 0) return (ge = e.refVal[se]), (N = P(Z, ge)), M(ge, N);
      }
      N = P(Z);
      var D = si.call(n, w, e, Z);
      if (D === void 0) {
        var k = r && r[Z];
        k && (D = si.inlineRef(k, s.inlineRefs) ? k : cu.call(n, k, e, r, z));
      }
      if (D === void 0) x(Z);
      else return A(Z, D), M(D, N);
    }
    function P(z, Z) {
      var te = o.length;
      return (o[te] = Z), (i[z] = te), "refVal" + te;
    }
    function x(z) {
      delete i[z];
    }
    function A(z, Z) {
      var te = i[z];
      o[te] = Z;
    }
    function M(z, Z) {
      return typeof z == "object" || typeof z == "boolean"
        ? { code: Z, schema: z, inline: !0 }
        : { code: Z, $async: z && !!z.$async };
    }
    function H(z) {
      var Z = c[z];
      return Z === void 0 && ((Z = c[z] = l.length), (l[Z] = z)), "pattern" + Z;
    }
    function V(z) {
      switch (typeof z) {
        case "boolean":
        case "number":
          return "" + z;
        case "string":
          return oi.toQuotedString(z);
        case "object":
          if (z === null) return "null";
          var Z = K$(z),
            te = f[Z];
          return (
            te === void 0 && ((te = f[Z] = u.length), (u[te] = z)),
            "default" + te
          );
      }
    }
    function J(z, Z, te, me) {
      if (n._opts.validateSchema !== !1) {
        var ge = z.definition.dependencies;
        if (
          ge &&
          !ge.every(function (q) {
            return Object.prototype.hasOwnProperty.call(te, q);
          })
        )
          throw new Error(
            "parent schema must have all required keywords: " + ge.join(",")
          );
        var N = z.definition.validateSchema;
        if (N) {
          var se = N(Z);
          if (!se) {
            var D = "keyword schema is invalid: " + n.errorsText(N.errors);
            if (n._opts.validateSchema == "log") n.logger.error(D);
            else throw new Error(D);
          }
        }
      }
      var k = z.definition.compile,
        L = z.definition.inline,
        R = z.definition.macro,
        b;
      if (k) b = k.call(n, Z, te, me);
      else if (R)
        (b = R.call(n, Z, te, me)),
          s.validateSchema !== !1 && n.validateSchema(b, !0);
      else if (L) b = L.call(n, me, z.keyword, Z, te);
      else if (((b = z.definition.validate), !b)) return;
      if (b === void 0)
        throw new Error('custom keyword "' + z.keyword + '"failed to compile');
      var T = v.length;
      return (v[T] = b), { code: "customRule" + T, validate: b };
    }
  }
  function X$(t, e, r) {
    var a = Uh.call(this, t, e, r);
    return a >= 0
      ? { index: a, compiling: !0 }
      : ((a = this._compilations.length),
        (this._compilations[a] = { schema: t, root: e, baseId: r }),
        { index: a, compiling: !1 });
  }
  function eP(t, e, r) {
    var a = Uh.call(this, t, e, r);
    a >= 0 && this._compilations.splice(a, 1);
  }
  function Uh(t, e, r) {
    for (var a = 0; a < this._compilations.length; a++) {
      var n = this._compilations[a];
      if (n.schema == t && n.root == e && n.baseId == r) return a;
    }
    return -1;
  }
  function tP(t, e) {
    return (
      "var pattern" + t + " = new RegExp(" + oi.toQuotedString(e[t]) + ");"
    );
  }
  function rP(t) {
    return "var default" + t + " = defaults[" + t + "];";
  }
  function nP(t, e) {
    return e[t] === void 0 ? "" : "var refVal" + t + " = refVal[" + t + "];";
  }
  function aP(t) {
    return "var customRule" + t + " = customRules[" + t + "];";
  }
  function ii(t, e) {
    if (!t.length) return "";
    for (var r = "", a = 0; a < t.length; a++) r += e(a, t);
    return r;
  }
  var Fh = { exports: {} },
    li = (Fh.exports = function () {
      this._cache = {};
    });
  (li.prototype.put = function (e, r) {
    this._cache[e] = r;
  }),
    (li.prototype.get = function (e) {
      return this._cache[e];
    }),
    (li.prototype.del = function (e) {
      delete this._cache[e];
    }),
    (li.prototype.clear = function () {
      this._cache = {};
    });
  var sP = Fh.exports,
    oP = Sa,
    iP = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
    lP = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    cP = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i,
    Vh =
      /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    uP =
      /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    dP =
      /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    Zh =
      /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    Hh =
      /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i,
    Bh = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    Jh = /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    Kh = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    Gh = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    fP = ci;
  function ci(t) {
    return (t = t == "full" ? "full" : "fast"), oP.copy(ci[t]);
  }
  (ci.fast = {
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    "date-time":
      /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference":
      /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": Zh,
    url: Hh,
    email:
      /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: Vh,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: Yh,
    uuid: Bh,
    "json-pointer": Jh,
    "json-pointer-uri-fragment": Kh,
    "relative-json-pointer": Gh,
  }),
    (ci.full = {
      date: Wh,
      time: Qh,
      "date-time": mP,
      uri: gP,
      "uri-reference": dP,
      "uri-template": Zh,
      url: Hh,
      email:
        /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: Vh,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex: Yh,
      uuid: Bh,
      "json-pointer": Jh,
      "json-pointer-uri-fragment": Kh,
      "relative-json-pointer": Gh,
    });
  function pP(t) {
    return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
  }
  function Wh(t) {
    var e = t.match(iP);
    if (!e) return !1;
    var r = +e[1],
      a = +e[2],
      n = +e[3];
    return a >= 1 && a <= 12 && n >= 1 && n <= (a == 2 && pP(r) ? 29 : lP[a]);
  }
  function Qh(t, e) {
    var r = t.match(cP);
    if (!r) return !1;
    var a = r[1],
      n = r[2],
      s = r[3],
      o = r[5];
    return (
      ((a <= 23 && n <= 59 && s <= 59) || (a == 23 && n == 59 && s == 60)) &&
      (!e || o)
    );
  }
  var hP = /t|\s/i;
  function mP(t) {
    var e = t.split(hP);
    return e.length == 2 && Wh(e[0]) && Qh(e[1], !0);
  }
  var vP = /\/|:/;
  function gP(t) {
    return vP.test(t) && uP.test(t);
  }
  var yP = /[^\\]\\Z/;
  function Yh(t) {
    if (yP.test(t)) return !1;
    try {
      return new RegExp(t), !0;
    } catch {
      return !1;
    }
  }
  var _P = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.errSchemaPath + "/" + r,
        c = !e.opts.allErrors,
        u = "data" + (o || ""),
        f = "valid" + s,
        v,
        d;
      if (i == "#" || i == "#/")
        e.isRoot
          ? ((v = e.async), (d = "validate"))
          : ((v = e.root.schema.$async === !0), (d = "root.refVal[0]"));
      else {
        var p = e.resolveRef(e.baseId, i, e.isRoot);
        if (p === void 0) {
          var g = e.MissingRefError.message(e.baseId, i);
          if (e.opts.missingRefs == "fail") {
            e.logger.error(g);
            var m = m || [];
            m.push(n),
              (n = ""),
              e.createErrors !== !1
                ? ((n +=
                    " { keyword: '$ref' , dataPath: (dataPath || '') + " +
                    e.errorPath +
                    " , schemaPath: " +
                    e.util.toQuotedString(l) +
                    " , params: { ref: '" +
                    e.util.escapeQuotes(i) +
                    "' } "),
                  e.opts.messages !== !1 &&
                    (n +=
                      " , message: 'can\\'t resolve reference " +
                      e.util.escapeQuotes(i) +
                      "' "),
                  e.opts.verbose &&
                    (n +=
                      " , schema: " +
                      e.util.toQuotedString(i) +
                      " , parentSchema: validate.schema" +
                      e.schemaPath +
                      " , data: " +
                      u +
                      " "),
                  (n += " } "))
                : (n += " {} ");
            var h = n;
            (n = m.pop()),
              !e.compositeRule && c
                ? e.async
                  ? (n += " throw new ValidationError([" + h + "]); ")
                  : (n += " validate.errors = [" + h + "]; return false; ")
                : (n +=
                    " var err = " +
                    h +
                    ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
              c && (n += " if (false) { ");
          } else if (e.opts.missingRefs == "ignore")
            e.logger.warn(g), c && (n += " if (true) { ");
          else throw new e.MissingRefError(e.baseId, i, g);
        } else if (p.inline) {
          var y = e.util.copy(e);
          y.level++;
          var _ = "valid" + y.level;
          (y.schema = p.schema), (y.schemaPath = ""), (y.errSchemaPath = i);
          var w = e.validate(y).replace(/validate\.schema/g, p.code);
          (n += " " + w + " "), c && (n += " if (" + _ + ") { ");
        } else
          (v = p.$async === !0 || (e.async && p.$async !== !1)), (d = p.code);
      }
      if (d) {
        var m = m || [];
        m.push(n),
          (n = ""),
          e.opts.passContext
            ? (n += " " + d + ".call(this, ")
            : (n += " " + d + "( "),
          (n += " " + u + ", (dataPath || '')"),
          e.errorPath != '""' && (n += " + " + e.errorPath);
        var E = o ? "data" + (o - 1 || "") : "parentData",
          P = o ? e.dataPathArr[o] : "parentDataProperty";
        n += " , " + E + " , " + P + ", rootData)  ";
        var x = n;
        if (((n = m.pop()), v)) {
          if (!e.async)
            throw new Error("async schema referenced by sync schema");
          c && (n += " var " + f + "; "),
            (n += " try { await " + x + "; "),
            c && (n += " " + f + " = true; "),
            (n +=
              " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; "),
            c && (n += " " + f + " = false; "),
            (n += " } "),
            c && (n += " if (" + f + ") { ");
        } else
          (n +=
            " if (!" +
            x +
            ") { if (vErrors === null) vErrors = " +
            d +
            ".errors; else vErrors = vErrors.concat(" +
            d +
            ".errors); errors = vErrors.length; } "),
            c && (n += " else { ");
      }
      return n;
    },
    wP = function (e, r, a) {
      var n = " ",
        s = e.schema[r],
        o = e.schemaPath + e.util.getProperty(r),
        i = e.errSchemaPath + "/" + r,
        l = !e.opts.allErrors,
        c = e.util.copy(e),
        u = "";
      c.level++;
      var f = "valid" + c.level,
        v = c.baseId,
        d = !0,
        p = s;
      if (p)
        for (var g, m = -1, h = p.length - 1; m < h; )
          (g = p[(m += 1)]),
            (e.opts.strictKeywords
              ? (typeof g == "object" && Object.keys(g).length > 0) || g === !1
              : e.util.schemaHasRules(g, e.RULES.all)) &&
              ((d = !1),
              (c.schema = g),
              (c.schemaPath = o + "[" + m + "]"),
              (c.errSchemaPath = i + "/" + m),
              (n += "  " + e.validate(c) + " "),
              (c.baseId = v),
              l && ((n += " if (" + f + ") { "), (u += "}")));
      return (
        l && (d ? (n += " if (true) { ") : (n += " " + u.slice(0, -1) + " ")), n
      );
    },
    bP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "valid" + s,
        d = "errs__" + s,
        p = e.util.copy(e),
        g = "";
      p.level++;
      var m = "valid" + p.level,
        h = i.every(function (A) {
          return e.opts.strictKeywords
            ? (typeof A == "object" && Object.keys(A).length > 0) || A === !1
            : e.util.schemaHasRules(A, e.RULES.all);
        });
      if (h) {
        var y = p.baseId;
        n += " var " + d + " = errors; var " + v + " = false;  ";
        var _ = e.compositeRule;
        e.compositeRule = p.compositeRule = !0;
        var w = i;
        if (w)
          for (var E, P = -1, x = w.length - 1; P < x; )
            (E = w[(P += 1)]),
              (p.schema = E),
              (p.schemaPath = l + "[" + P + "]"),
              (p.errSchemaPath = c + "/" + P),
              (n += "  " + e.validate(p) + " "),
              (p.baseId = y),
              (n += " " + v + " = " + v + " || " + m + "; if (!" + v + ") { "),
              (g += "}");
        (e.compositeRule = p.compositeRule = _),
          (n += " " + g + " if (!" + v + ") {   var err =   "),
          e.createErrors !== !1
            ? ((n +=
                " { keyword: 'anyOf' , dataPath: (dataPath || '') + " +
                e.errorPath +
                " , schemaPath: " +
                e.util.toQuotedString(c) +
                " , params: {} "),
              e.opts.messages !== !1 &&
                (n += " , message: 'should match some schema in anyOf' "),
              e.opts.verbose &&
                (n +=
                  " , schema: validate.schema" +
                  l +
                  " , parentSchema: validate.schema" +
                  e.schemaPath +
                  " , data: " +
                  f +
                  " "),
              (n += " } "))
            : (n += " {} "),
          (n +=
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
          !e.compositeRule &&
            u &&
            (e.async
              ? (n += " throw new ValidationError(vErrors); ")
              : (n += " validate.errors = vErrors; return false; ")),
          (n +=
            " } else {  errors = " +
            d +
            "; if (vErrors !== null) { if (" +
            d +
            ") vErrors.length = " +
            d +
            "; else vErrors = null; } "),
          e.opts.allErrors && (n += " } ");
      } else u && (n += " if (true) { ");
      return n;
    },
    EP = function (e, r, a) {
      var n = " ",
        s = e.schema[r],
        o = e.errSchemaPath + "/" + r;
      e.opts.allErrors;
      var i = e.util.toQuotedString(s);
      return (
        e.opts.$comment === !0
          ? (n += " console.log(" + i + ");")
          : typeof e.opts.$comment == "function" &&
            (n +=
              " self._opts.$comment(" +
              i +
              ", " +
              e.util.toQuotedString(o) +
              ", validate.root.schema);"),
        n
      );
    },
    SP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "valid" + s,
        d = e.opts.$data && i && i.$data;
      d &&
        (n +=
          " var schema" +
          s +
          " = " +
          e.util.getData(i.$data, o, e.dataPathArr) +
          "; "),
        d || (n += " var schema" + s + " = validate.schema" + l + ";"),
        (n +=
          "var " +
          v +
          " = equal(" +
          f +
          ", schema" +
          s +
          "); if (!" +
          v +
          ") {   ");
      var p = p || [];
      p.push(n),
        (n = ""),
        e.createErrors !== !1
          ? ((n +=
              " { keyword: 'const' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(c) +
              " , params: { allowedValue: schema" +
              s +
              " } "),
            e.opts.messages !== !1 &&
              (n += " , message: 'should be equal to constant' "),
            e.opts.verbose &&
              (n +=
                " , schema: validate.schema" +
                l +
                " , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                f +
                " "),
            (n += " } "))
          : (n += " {} ");
      var g = n;
      return (
        (n = p.pop()),
        !e.compositeRule && u
          ? e.async
            ? (n += " throw new ValidationError([" + g + "]); ")
            : (n += " validate.errors = [" + g + "]; return false; ")
          : (n +=
              " var err = " +
              g +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (n += " }"),
        u && (n += " else { "),
        n
      );
    },
    $P = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "valid" + s,
        d = "errs__" + s,
        p = e.util.copy(e),
        g = "";
      p.level++;
      var m = "valid" + p.level,
        h = "i" + s,
        y = (p.dataLevel = e.dataLevel + 1),
        _ = "data" + y,
        w = e.baseId,
        E = e.opts.strictKeywords
          ? (typeof i == "object" && Object.keys(i).length > 0) || i === !1
          : e.util.schemaHasRules(i, e.RULES.all);
      if (((n += "var " + d + " = errors;var " + v + ";"), E)) {
        var P = e.compositeRule;
        (e.compositeRule = p.compositeRule = !0),
          (p.schema = i),
          (p.schemaPath = l),
          (p.errSchemaPath = c),
          (n +=
            " var " +
            m +
            " = false; for (var " +
            h +
            " = 0; " +
            h +
            " < " +
            f +
            ".length; " +
            h +
            "++) { "),
          (p.errorPath = e.util.getPathExpr(
            e.errorPath,
            h,
            e.opts.jsonPointers,
            !0
          ));
        var x = f + "[" + h + "]";
        p.dataPathArr[y] = h;
        var A = e.validate(p);
        (p.baseId = w),
          e.util.varOccurences(A, _) < 2
            ? (n += " " + e.util.varReplace(A, _, x) + " ")
            : (n += " var " + _ + " = " + x + "; " + A + " "),
          (n += " if (" + m + ") break; }  "),
          (e.compositeRule = p.compositeRule = P),
          (n += " " + g + " if (!" + m + ") {");
      } else n += " if (" + f + ".length == 0) {";
      var M = M || [];
      M.push(n),
        (n = ""),
        e.createErrors !== !1
          ? ((n +=
              " { keyword: 'contains' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(c) +
              " , params: {} "),
            e.opts.messages !== !1 &&
              (n += " , message: 'should contain a valid item' "),
            e.opts.verbose &&
              (n +=
                " , schema: validate.schema" +
                l +
                " , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                f +
                " "),
            (n += " } "))
          : (n += " {} ");
      var H = n;
      return (
        (n = M.pop()),
        !e.compositeRule && u
          ? e.async
            ? (n += " throw new ValidationError([" + H + "]); ")
            : (n += " validate.errors = [" + H + "]; return false; ")
          : (n +=
              " var err = " +
              H +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (n += " } else { "),
        E &&
          (n +=
            "  errors = " +
            d +
            "; if (vErrors !== null) { if (" +
            d +
            ") vErrors.length = " +
            d +
            "; else vErrors = null; } "),
        e.opts.allErrors && (n += " } "),
        n
      );
    },
    PP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "errs__" + s,
        d = e.util.copy(e),
        p = "";
      d.level++;
      var g = "valid" + d.level,
        m = {},
        h = {},
        y = e.opts.ownProperties;
      for (P in i)
        if (P != "__proto__") {
          var _ = i[P],
            w = Array.isArray(_) ? h : m;
          w[P] = _;
        }
      n += "var " + v + " = errors;";
      var E = e.errorPath;
      n += "var missing" + s + ";";
      for (var P in h)
        if (((w = h[P]), w.length)) {
          if (
            ((n += " if ( " + f + e.util.getProperty(P) + " !== undefined "),
            y &&
              (n +=
                " && Object.prototype.hasOwnProperty.call(" +
                f +
                ", '" +
                e.util.escapeQuotes(P) +
                "') "),
            u)
          ) {
            n += " && ( ";
            var x = w;
            if (x)
              for (var A, M = -1, H = x.length - 1; M < H; ) {
                (A = x[(M += 1)]), M && (n += " || ");
                var V = e.util.getProperty(A),
                  J = f + V;
                (n += " ( ( " + J + " === undefined "),
                  y &&
                    (n +=
                      " || ! Object.prototype.hasOwnProperty.call(" +
                      f +
                      ", '" +
                      e.util.escapeQuotes(A) +
                      "') "),
                  (n +=
                    ") && (missing" +
                    s +
                    " = " +
                    e.util.toQuotedString(e.opts.jsonPointers ? A : V) +
                    ") ) ");
              }
            n += ")) {  ";
            var z = "missing" + s,
              Z = "' + " + z + " + '";
            e.opts._errorDataPathProperty &&
              (e.errorPath = e.opts.jsonPointers
                ? e.util.getPathExpr(E, z, !0)
                : E + " + " + z);
            var te = te || [];
            te.push(n),
              (n = ""),
              e.createErrors !== !1
                ? ((n +=
                    " { keyword: 'dependencies' , dataPath: (dataPath || '') + " +
                    e.errorPath +
                    " , schemaPath: " +
                    e.util.toQuotedString(c) +
                    " , params: { property: '" +
                    e.util.escapeQuotes(P) +
                    "', missingProperty: '" +
                    Z +
                    "', depsCount: " +
                    w.length +
                    ", deps: '" +
                    e.util.escapeQuotes(w.length == 1 ? w[0] : w.join(", ")) +
                    "' } "),
                  e.opts.messages !== !1 &&
                    ((n += " , message: 'should have "),
                    w.length == 1
                      ? (n += "property " + e.util.escapeQuotes(w[0]))
                      : (n +=
                          "properties " + e.util.escapeQuotes(w.join(", "))),
                    (n +=
                      " when property " +
                      e.util.escapeQuotes(P) +
                      " is present' ")),
                  e.opts.verbose &&
                    (n +=
                      " , schema: validate.schema" +
                      l +
                      " , parentSchema: validate.schema" +
                      e.schemaPath +
                      " , data: " +
                      f +
                      " "),
                  (n += " } "))
                : (n += " {} ");
            var me = n;
            (n = te.pop()),
              !e.compositeRule && u
                ? e.async
                  ? (n += " throw new ValidationError([" + me + "]); ")
                  : (n += " validate.errors = [" + me + "]; return false; ")
                : (n +=
                    " var err = " +
                    me +
                    ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ");
          } else {
            n += " ) { ";
            var ge = w;
            if (ge)
              for (var A, N = -1, se = ge.length - 1; N < se; ) {
                A = ge[(N += 1)];
                var V = e.util.getProperty(A),
                  Z = e.util.escapeQuotes(A),
                  J = f + V;
                e.opts._errorDataPathProperty &&
                  (e.errorPath = e.util.getPath(E, A, e.opts.jsonPointers)),
                  (n += " if ( " + J + " === undefined "),
                  y &&
                    (n +=
                      " || ! Object.prototype.hasOwnProperty.call(" +
                      f +
                      ", '" +
                      e.util.escapeQuotes(A) +
                      "') "),
                  (n += ") {  var err =   "),
                  e.createErrors !== !1
                    ? ((n +=
                        " { keyword: 'dependencies' , dataPath: (dataPath || '') + " +
                        e.errorPath +
                        " , schemaPath: " +
                        e.util.toQuotedString(c) +
                        " , params: { property: '" +
                        e.util.escapeQuotes(P) +
                        "', missingProperty: '" +
                        Z +
                        "', depsCount: " +
                        w.length +
                        ", deps: '" +
                        e.util.escapeQuotes(
                          w.length == 1 ? w[0] : w.join(", ")
                        ) +
                        "' } "),
                      e.opts.messages !== !1 &&
                        ((n += " , message: 'should have "),
                        w.length == 1
                          ? (n += "property " + e.util.escapeQuotes(w[0]))
                          : (n +=
                              "properties " +
                              e.util.escapeQuotes(w.join(", "))),
                        (n +=
                          " when property " +
                          e.util.escapeQuotes(P) +
                          " is present' ")),
                      e.opts.verbose &&
                        (n +=
                          " , schema: validate.schema" +
                          l +
                          " , parentSchema: validate.schema" +
                          e.schemaPath +
                          " , data: " +
                          f +
                          " "),
                      (n += " } "))
                    : (n += " {} "),
                  (n +=
                    ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ");
              }
          }
          (n += " }   "), u && ((p += "}"), (n += " else { "));
        }
      e.errorPath = E;
      var D = d.baseId;
      for (var P in m) {
        var _ = m[P];
        (e.opts.strictKeywords
          ? (typeof _ == "object" && Object.keys(_).length > 0) || _ === !1
          : e.util.schemaHasRules(_, e.RULES.all)) &&
          ((n +=
            " " +
            g +
            " = true; if ( " +
            f +
            e.util.getProperty(P) +
            " !== undefined "),
          y &&
            (n +=
              " && Object.prototype.hasOwnProperty.call(" +
              f +
              ", '" +
              e.util.escapeQuotes(P) +
              "') "),
          (n += ") { "),
          (d.schema = _),
          (d.schemaPath = l + e.util.getProperty(P)),
          (d.errSchemaPath = c + "/" + e.util.escapeFragment(P)),
          (n += "  " + e.validate(d) + " "),
          (d.baseId = D),
          (n += " }  "),
          u && ((n += " if (" + g + ") { "), (p += "}")));
      }
      return u && (n += "   " + p + " if (" + v + " == errors) {"), n;
    },
    TP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "valid" + s,
        d = e.opts.$data && i && i.$data;
      d &&
        (n +=
          " var schema" +
          s +
          " = " +
          e.util.getData(i.$data, o, e.dataPathArr) +
          "; ");
      var p = "i" + s,
        g = "schema" + s;
      d || (n += " var " + g + " = validate.schema" + l + ";"),
        (n += "var " + v + ";"),
        d &&
          (n +=
            " if (schema" +
            s +
            " === undefined) " +
            v +
            " = true; else if (!Array.isArray(schema" +
            s +
            ")) " +
            v +
            " = false; else {"),
        (n +=
          "" +
          v +
          " = false;for (var " +
          p +
          "=0; " +
          p +
          "<" +
          g +
          ".length; " +
          p +
          "++) if (equal(" +
          f +
          ", " +
          g +
          "[" +
          p +
          "])) { " +
          v +
          " = true; break; }"),
        d && (n += "  }  "),
        (n += " if (!" + v + ") {   ");
      var m = m || [];
      m.push(n),
        (n = ""),
        e.createErrors !== !1
          ? ((n +=
              " { keyword: 'enum' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(c) +
              " , params: { allowedValues: schema" +
              s +
              " } "),
            e.opts.messages !== !1 &&
              (n +=
                " , message: 'should be equal to one of the allowed values' "),
            e.opts.verbose &&
              (n +=
                " , schema: validate.schema" +
                l +
                " , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                f +
                " "),
            (n += " } "))
          : (n += " {} ");
      var h = n;
      return (
        (n = m.pop()),
        !e.compositeRule && u
          ? e.async
            ? (n += " throw new ValidationError([" + h + "]); ")
            : (n += " validate.errors = [" + h + "]; return false; ")
          : (n +=
              " var err = " +
              h +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (n += " }"),
        u && (n += " else { "),
        n
      );
    },
    xP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || "");
      if (e.opts.format === !1) return u && (n += " if (true) { "), n;
      var v = e.opts.$data && i && i.$data,
        d;
      v
        ? ((n +=
            " var schema" +
            s +
            " = " +
            e.util.getData(i.$data, o, e.dataPathArr) +
            "; "),
          (d = "schema" + s))
        : (d = i);
      var p = e.opts.unknownFormats,
        g = Array.isArray(p);
      if (v) {
        var m = "format" + s,
          h = "isObject" + s,
          y = "formatType" + s;
        (n +=
          " var " +
          m +
          " = formats[" +
          d +
          "]; var " +
          h +
          " = typeof " +
          m +
          " == 'object' && !(" +
          m +
          " instanceof RegExp) && " +
          m +
          ".validate; var " +
          y +
          " = " +
          h +
          " && " +
          m +
          ".type || 'string'; if (" +
          h +
          ") { "),
          e.async && (n += " var async" + s + " = " + m + ".async; "),
          (n += " " + m + " = " + m + ".validate; } if (  "),
          v &&
            (n +=
              " (" + d + " !== undefined && typeof " + d + " != 'string') || "),
          (n += " ("),
          p != "ignore" &&
            ((n += " (" + d + " && !" + m + " "),
            g &&
              (n += " && self._opts.unknownFormats.indexOf(" + d + ") == -1 "),
            (n += ") || ")),
          (n +=
            " (" +
            m +
            " && " +
            y +
            " == '" +
            a +
            "' && !(typeof " +
            m +
            " == 'function' ? "),
          e.async
            ? (n +=
                " (async" +
                s +
                " ? await " +
                m +
                "(" +
                f +
                ") : " +
                m +
                "(" +
                f +
                ")) ")
            : (n += " " + m + "(" + f + ") "),
          (n += " : " + m + ".test(" + f + "))))) {");
      } else {
        var m = e.formats[i];
        if (!m) {
          if (p == "ignore")
            return (
              e.logger.warn(
                'unknown format "' +
                  i +
                  '" ignored in schema at path "' +
                  e.errSchemaPath +
                  '"'
              ),
              u && (n += " if (true) { "),
              n
            );
          if (g && p.indexOf(i) >= 0) return u && (n += " if (true) { "), n;
          throw new Error(
            'unknown format "' +
              i +
              '" is used in schema at path "' +
              e.errSchemaPath +
              '"'
          );
        }
        var h = typeof m == "object" && !(m instanceof RegExp) && m.validate,
          y = (h && m.type) || "string";
        if (h) {
          var _ = m.async === !0;
          m = m.validate;
        }
        if (y != a) return u && (n += " if (true) { "), n;
        if (_) {
          if (!e.async) throw new Error("async format in sync schema");
          var w = "formats" + e.util.getProperty(i) + ".validate";
          n += " if (!(await " + w + "(" + f + "))) { ";
        } else {
          n += " if (! ";
          var w = "formats" + e.util.getProperty(i);
          h && (w += ".validate"),
            typeof m == "function"
              ? (n += " " + w + "(" + f + ") ")
              : (n += " " + w + ".test(" + f + ") "),
            (n += ") { ");
        }
      }
      var E = E || [];
      E.push(n),
        (n = ""),
        e.createErrors !== !1
          ? ((n +=
              " { keyword: 'format' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(c) +
              " , params: { format:  "),
            v ? (n += "" + d) : (n += "" + e.util.toQuotedString(i)),
            (n += "  } "),
            e.opts.messages !== !1 &&
              ((n += ` , message: 'should match format "`),
              v
                ? (n += "' + " + d + " + '")
                : (n += "" + e.util.escapeQuotes(i)),
              (n += `"' `)),
            e.opts.verbose &&
              ((n += " , schema:  "),
              v
                ? (n += "validate.schema" + l)
                : (n += "" + e.util.toQuotedString(i)),
              (n +=
                "         , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                f +
                " ")),
            (n += " } "))
          : (n += " {} ");
      var P = n;
      return (
        (n = E.pop()),
        !e.compositeRule && u
          ? e.async
            ? (n += " throw new ValidationError([" + P + "]); ")
            : (n += " validate.errors = [" + P + "]; return false; ")
          : (n +=
              " var err = " +
              P +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (n += " } "),
        u && (n += " else { "),
        n
      );
    },
    IP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "valid" + s,
        d = "errs__" + s,
        p = e.util.copy(e);
      p.level++;
      var g = "valid" + p.level,
        m = e.schema.then,
        h = e.schema.else,
        y =
          m !== void 0 &&
          (e.opts.strictKeywords
            ? (typeof m == "object" && Object.keys(m).length > 0) || m === !1
            : e.util.schemaHasRules(m, e.RULES.all)),
        _ =
          h !== void 0 &&
          (e.opts.strictKeywords
            ? (typeof h == "object" && Object.keys(h).length > 0) || h === !1
            : e.util.schemaHasRules(h, e.RULES.all)),
        w = p.baseId;
      if (y || _) {
        var E;
        (p.createErrors = !1),
          (p.schema = i),
          (p.schemaPath = l),
          (p.errSchemaPath = c),
          (n += " var " + d + " = errors; var " + v + " = true;  ");
        var P = e.compositeRule;
        (e.compositeRule = p.compositeRule = !0),
          (n += "  " + e.validate(p) + " "),
          (p.baseId = w),
          (p.createErrors = !0),
          (n +=
            "  errors = " +
            d +
            "; if (vErrors !== null) { if (" +
            d +
            ") vErrors.length = " +
            d +
            "; else vErrors = null; }  "),
          (e.compositeRule = p.compositeRule = P),
          y
            ? ((n += " if (" + g + ") {  "),
              (p.schema = e.schema.then),
              (p.schemaPath = e.schemaPath + ".then"),
              (p.errSchemaPath = e.errSchemaPath + "/then"),
              (n += "  " + e.validate(p) + " "),
              (p.baseId = w),
              (n += " " + v + " = " + g + "; "),
              y && _
                ? ((E = "ifClause" + s), (n += " var " + E + " = 'then'; "))
                : (E = "'then'"),
              (n += " } "),
              _ && (n += " else { "))
            : (n += " if (!" + g + ") { "),
          _ &&
            ((p.schema = e.schema.else),
            (p.schemaPath = e.schemaPath + ".else"),
            (p.errSchemaPath = e.errSchemaPath + "/else"),
            (n += "  " + e.validate(p) + " "),
            (p.baseId = w),
            (n += " " + v + " = " + g + "; "),
            y && _
              ? ((E = "ifClause" + s), (n += " var " + E + " = 'else'; "))
              : (E = "'else'"),
            (n += " } ")),
          (n += " if (!" + v + ") {   var err =   "),
          e.createErrors !== !1
            ? ((n +=
                " { keyword: 'if' , dataPath: (dataPath || '') + " +
                e.errorPath +
                " , schemaPath: " +
                e.util.toQuotedString(c) +
                " , params: { failingKeyword: " +
                E +
                " } "),
              e.opts.messages !== !1 &&
                (n += ` , message: 'should match "' + ` + E + ` + '" schema' `),
              e.opts.verbose &&
                (n +=
                  " , schema: validate.schema" +
                  l +
                  " , parentSchema: validate.schema" +
                  e.schemaPath +
                  " , data: " +
                  f +
                  " "),
              (n += " } "))
            : (n += " {} "),
          (n +=
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
          !e.compositeRule &&
            u &&
            (e.async
              ? (n += " throw new ValidationError(vErrors); ")
              : (n += " validate.errors = vErrors; return false; ")),
          (n += " }   "),
          u && (n += " else { ");
      } else u && (n += " if (true) { ");
      return n;
    },
    kP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "valid" + s,
        d = "errs__" + s,
        p = e.util.copy(e),
        g = "";
      p.level++;
      var m = "valid" + p.level,
        h = "i" + s,
        y = (p.dataLevel = e.dataLevel + 1),
        _ = "data" + y,
        w = e.baseId;
      if (((n += "var " + d + " = errors;var " + v + ";"), Array.isArray(i))) {
        var E = e.schema.additionalItems;
        if (E === !1) {
          n += " " + v + " = " + f + ".length <= " + i.length + "; ";
          var P = c;
          (c = e.errSchemaPath + "/additionalItems"),
            (n += "  if (!" + v + ") {   ");
          var x = x || [];
          x.push(n),
            (n = ""),
            e.createErrors !== !1
              ? ((n +=
                  " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " +
                  e.errorPath +
                  " , schemaPath: " +
                  e.util.toQuotedString(c) +
                  " , params: { limit: " +
                  i.length +
                  " } "),
                e.opts.messages !== !1 &&
                  (n +=
                    " , message: 'should NOT have more than " +
                    i.length +
                    " items' "),
                e.opts.verbose &&
                  (n +=
                    " , schema: false , parentSchema: validate.schema" +
                    e.schemaPath +
                    " , data: " +
                    f +
                    " "),
                (n += " } "))
              : (n += " {} ");
          var A = n;
          (n = x.pop()),
            !e.compositeRule && u
              ? e.async
                ? (n += " throw new ValidationError([" + A + "]); ")
                : (n += " validate.errors = [" + A + "]; return false; ")
              : (n +=
                  " var err = " +
                  A +
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
            (n += " } "),
            (c = P),
            u && ((g += "}"), (n += " else { "));
        }
        var M = i;
        if (M) {
          for (var H, V = -1, J = M.length - 1; V < J; )
            if (
              ((H = M[(V += 1)]),
              e.opts.strictKeywords
                ? (typeof H == "object" && Object.keys(H).length > 0) ||
                  H === !1
                : e.util.schemaHasRules(H, e.RULES.all))
            ) {
              n += " " + m + " = true; if (" + f + ".length > " + V + ") { ";
              var z = f + "[" + V + "]";
              (p.schema = H),
                (p.schemaPath = l + "[" + V + "]"),
                (p.errSchemaPath = c + "/" + V),
                (p.errorPath = e.util.getPathExpr(
                  e.errorPath,
                  V,
                  e.opts.jsonPointers,
                  !0
                )),
                (p.dataPathArr[y] = V);
              var Z = e.validate(p);
              (p.baseId = w),
                e.util.varOccurences(Z, _) < 2
                  ? (n += " " + e.util.varReplace(Z, _, z) + " ")
                  : (n += " var " + _ + " = " + z + "; " + Z + " "),
                (n += " }  "),
                u && ((n += " if (" + m + ") { "), (g += "}"));
            }
        }
        if (
          typeof E == "object" &&
          (e.opts.strictKeywords
            ? (typeof E == "object" && Object.keys(E).length > 0) || E === !1
            : e.util.schemaHasRules(E, e.RULES.all))
        ) {
          (p.schema = E),
            (p.schemaPath = e.schemaPath + ".additionalItems"),
            (p.errSchemaPath = e.errSchemaPath + "/additionalItems"),
            (n +=
              " " +
              m +
              " = true; if (" +
              f +
              ".length > " +
              i.length +
              ") {  for (var " +
              h +
              " = " +
              i.length +
              "; " +
              h +
              " < " +
              f +
              ".length; " +
              h +
              "++) { "),
            (p.errorPath = e.util.getPathExpr(
              e.errorPath,
              h,
              e.opts.jsonPointers,
              !0
            ));
          var z = f + "[" + h + "]";
          p.dataPathArr[y] = h;
          var Z = e.validate(p);
          (p.baseId = w),
            e.util.varOccurences(Z, _) < 2
              ? (n += " " + e.util.varReplace(Z, _, z) + " ")
              : (n += " var " + _ + " = " + z + "; " + Z + " "),
            u && (n += " if (!" + m + ") break; "),
            (n += " } }  "),
            u && ((n += " if (" + m + ") { "), (g += "}"));
        }
      } else if (
        e.opts.strictKeywords
          ? (typeof i == "object" && Object.keys(i).length > 0) || i === !1
          : e.util.schemaHasRules(i, e.RULES.all)
      ) {
        (p.schema = i),
          (p.schemaPath = l),
          (p.errSchemaPath = c),
          (n +=
            "  for (var " +
            h +
            " = 0; " +
            h +
            " < " +
            f +
            ".length; " +
            h +
            "++) { "),
          (p.errorPath = e.util.getPathExpr(
            e.errorPath,
            h,
            e.opts.jsonPointers,
            !0
          ));
        var z = f + "[" + h + "]";
        p.dataPathArr[y] = h;
        var Z = e.validate(p);
        (p.baseId = w),
          e.util.varOccurences(Z, _) < 2
            ? (n += " " + e.util.varReplace(Z, _, z) + " ")
            : (n += " var " + _ + " = " + z + "; " + Z + " "),
          u && (n += " if (!" + m + ") break; "),
          (n += " }");
      }
      return u && (n += " " + g + " if (" + d + " == errors) {"), n;
    },
    Xh = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        w,
        f = "data" + (o || ""),
        v = e.opts.$data && i && i.$data,
        d;
      v
        ? ((n +=
            " var schema" +
            s +
            " = " +
            e.util.getData(i.$data, o, e.dataPathArr) +
            "; "),
          (d = "schema" + s))
        : (d = i);
      var p = r == "maximum",
        g = p ? "exclusiveMaximum" : "exclusiveMinimum",
        m = e.schema[g],
        h = e.opts.$data && m && m.$data,
        y = p ? "<" : ">",
        _ = p ? ">" : "<",
        w = void 0;
      if (!(v || typeof i == "number" || i === void 0))
        throw new Error(r + " must be number");
      if (!(h || m === void 0 || typeof m == "number" || typeof m == "boolean"))
        throw new Error(g + " must be number or boolean");
      if (h) {
        var E = e.util.getData(m.$data, o, e.dataPathArr),
          P = "exclusive" + s,
          x = "exclType" + s,
          A = "exclIsNumber" + s,
          M = "op" + s,
          H = "' + " + M + " + '";
        (n += " var schemaExcl" + s + " = " + E + "; "),
          (E = "schemaExcl" + s),
          (n +=
            " var " +
            P +
            "; var " +
            x +
            " = typeof " +
            E +
            "; if (" +
            x +
            " != 'boolean' && " +
            x +
            " != 'undefined' && " +
            x +
            " != 'number') { ");
        var w = g,
          V = V || [];
        V.push(n),
          (n = ""),
          e.createErrors !== !1
            ? ((n +=
                " { keyword: '" +
                (w || "_exclusiveLimit") +
                "' , dataPath: (dataPath || '') + " +
                e.errorPath +
                " , schemaPath: " +
                e.util.toQuotedString(c) +
                " , params: {} "),
              e.opts.messages !== !1 &&
                (n += " , message: '" + g + " should be boolean' "),
              e.opts.verbose &&
                (n +=
                  " , schema: validate.schema" +
                  l +
                  " , parentSchema: validate.schema" +
                  e.schemaPath +
                  " , data: " +
                  f +
                  " "),
              (n += " } "))
            : (n += " {} ");
        var J = n;
        (n = V.pop()),
          !e.compositeRule && u
            ? e.async
              ? (n += " throw new ValidationError([" + J + "]); ")
              : (n += " validate.errors = [" + J + "]; return false; ")
            : (n +=
                " var err = " +
                J +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
          (n += " } else if ( "),
          v &&
            (n +=
              " (" + d + " !== undefined && typeof " + d + " != 'number') || "),
          (n +=
            " " +
            x +
            " == 'number' ? ( (" +
            P +
            " = " +
            d +
            " === undefined || " +
            E +
            " " +
            y +
            "= " +
            d +
            ") ? " +
            f +
            " " +
            _ +
            "= " +
            E +
            " : " +
            f +
            " " +
            _ +
            " " +
            d +
            " ) : ( (" +
            P +
            " = " +
            E +
            " === true) ? " +
            f +
            " " +
            _ +
            "= " +
            d +
            " : " +
            f +
            " " +
            _ +
            " " +
            d +
            " ) || " +
            f +
            " !== " +
            f +
            ") { var op" +
            s +
            " = " +
            P +
            " ? '" +
            y +
            "' : '" +
            y +
            "='; "),
          i === void 0 &&
            ((w = g), (c = e.errSchemaPath + "/" + g), (d = E), (v = h));
      } else {
        var A = typeof m == "number",
          H = y;
        if (A && v) {
          var M = "'" + H + "'";
          (n += " if ( "),
            v &&
              (n +=
                " (" +
                d +
                " !== undefined && typeof " +
                d +
                " != 'number') || "),
            (n +=
              " ( " +
              d +
              " === undefined || " +
              m +
              " " +
              y +
              "= " +
              d +
              " ? " +
              f +
              " " +
              _ +
              "= " +
              m +
              " : " +
              f +
              " " +
              _ +
              " " +
              d +
              " ) || " +
              f +
              " !== " +
              f +
              ") { ");
        } else {
          A && i === void 0
            ? ((P = !0),
              (w = g),
              (c = e.errSchemaPath + "/" + g),
              (d = m),
              (_ += "="))
            : (A && (d = Math[p ? "min" : "max"](m, i)),
              m === (A ? d : !0)
                ? ((P = !0),
                  (w = g),
                  (c = e.errSchemaPath + "/" + g),
                  (_ += "="))
                : ((P = !1), (H += "=")));
          var M = "'" + H + "'";
          (n += " if ( "),
            v &&
              (n +=
                " (" +
                d +
                " !== undefined && typeof " +
                d +
                " != 'number') || "),
            (n +=
              " " + f + " " + _ + " " + d + " || " + f + " !== " + f + ") { ");
        }
      }
      w = w || r;
      var V = V || [];
      V.push(n),
        (n = ""),
        e.createErrors !== !1
          ? ((n +=
              " { keyword: '" +
              (w || "_limit") +
              "' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(c) +
              " , params: { comparison: " +
              M +
              ", limit: " +
              d +
              ", exclusive: " +
              P +
              " } "),
            e.opts.messages !== !1 &&
              ((n += " , message: 'should be " + H + " "),
              v ? (n += "' + " + d) : (n += "" + d + "'")),
            e.opts.verbose &&
              ((n += " , schema:  "),
              v ? (n += "validate.schema" + l) : (n += "" + i),
              (n +=
                "         , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                f +
                " ")),
            (n += " } "))
          : (n += " {} ");
      var J = n;
      return (
        (n = V.pop()),
        !e.compositeRule && u
          ? e.async
            ? (n += " throw new ValidationError([" + J + "]); ")
            : (n += " validate.errors = [" + J + "]; return false; ")
          : (n +=
              " var err = " +
              J +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (n += " } "),
        u && (n += " else { "),
        n
      );
    },
    em = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        g,
        f = "data" + (o || ""),
        v = e.opts.$data && i && i.$data,
        d;
      if (
        (v
          ? ((n +=
              " var schema" +
              s +
              " = " +
              e.util.getData(i.$data, o, e.dataPathArr) +
              "; "),
            (d = "schema" + s))
          : (d = i),
        !(v || typeof i == "number"))
      )
        throw new Error(r + " must be number");
      var p = r == "maxItems" ? ">" : "<";
      (n += "if ( "),
        v &&
          (n +=
            " (" + d + " !== undefined && typeof " + d + " != 'number') || "),
        (n += " " + f + ".length " + p + " " + d + ") { ");
      var g = r,
        m = m || [];
      m.push(n),
        (n = ""),
        e.createErrors !== !1
          ? ((n +=
              " { keyword: '" +
              (g || "_limitItems") +
              "' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(c) +
              " , params: { limit: " +
              d +
              " } "),
            e.opts.messages !== !1 &&
              ((n += " , message: 'should NOT have "),
              r == "maxItems" ? (n += "more") : (n += "fewer"),
              (n += " than "),
              v ? (n += "' + " + d + " + '") : (n += "" + i),
              (n += " items' ")),
            e.opts.verbose &&
              ((n += " , schema:  "),
              v ? (n += "validate.schema" + l) : (n += "" + i),
              (n +=
                "         , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                f +
                " ")),
            (n += " } "))
          : (n += " {} ");
      var h = n;
      return (
        (n = m.pop()),
        !e.compositeRule && u
          ? e.async
            ? (n += " throw new ValidationError([" + h + "]); ")
            : (n += " validate.errors = [" + h + "]; return false; ")
          : (n +=
              " var err = " +
              h +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (n += "} "),
        u && (n += " else { "),
        n
      );
    },
    tm = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        g,
        f = "data" + (o || ""),
        v = e.opts.$data && i && i.$data,
        d;
      if (
        (v
          ? ((n +=
              " var schema" +
              s +
              " = " +
              e.util.getData(i.$data, o, e.dataPathArr) +
              "; "),
            (d = "schema" + s))
          : (d = i),
        !(v || typeof i == "number"))
      )
        throw new Error(r + " must be number");
      var p = r == "maxLength" ? ">" : "<";
      (n += "if ( "),
        v &&
          (n +=
            " (" + d + " !== undefined && typeof " + d + " != 'number') || "),
        e.opts.unicode === !1
          ? (n += " " + f + ".length ")
          : (n += " ucs2length(" + f + ") "),
        (n += " " + p + " " + d + ") { ");
      var g = r,
        m = m || [];
      m.push(n),
        (n = ""),
        e.createErrors !== !1
          ? ((n +=
              " { keyword: '" +
              (g || "_limitLength") +
              "' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(c) +
              " , params: { limit: " +
              d +
              " } "),
            e.opts.messages !== !1 &&
              ((n += " , message: 'should NOT be "),
              r == "maxLength" ? (n += "longer") : (n += "shorter"),
              (n += " than "),
              v ? (n += "' + " + d + " + '") : (n += "" + i),
              (n += " characters' ")),
            e.opts.verbose &&
              ((n += " , schema:  "),
              v ? (n += "validate.schema" + l) : (n += "" + i),
              (n +=
                "         , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                f +
                " ")),
            (n += " } "))
          : (n += " {} ");
      var h = n;
      return (
        (n = m.pop()),
        !e.compositeRule && u
          ? e.async
            ? (n += " throw new ValidationError([" + h + "]); ")
            : (n += " validate.errors = [" + h + "]; return false; ")
          : (n +=
              " var err = " +
              h +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (n += "} "),
        u && (n += " else { "),
        n
      );
    },
    rm = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        g,
        f = "data" + (o || ""),
        v = e.opts.$data && i && i.$data,
        d;
      if (
        (v
          ? ((n +=
              " var schema" +
              s +
              " = " +
              e.util.getData(i.$data, o, e.dataPathArr) +
              "; "),
            (d = "schema" + s))
          : (d = i),
        !(v || typeof i == "number"))
      )
        throw new Error(r + " must be number");
      var p = r == "maxProperties" ? ">" : "<";
      (n += "if ( "),
        v &&
          (n +=
            " (" + d + " !== undefined && typeof " + d + " != 'number') || "),
        (n += " Object.keys(" + f + ").length " + p + " " + d + ") { ");
      var g = r,
        m = m || [];
      m.push(n),
        (n = ""),
        e.createErrors !== !1
          ? ((n +=
              " { keyword: '" +
              (g || "_limitProperties") +
              "' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(c) +
              " , params: { limit: " +
              d +
              " } "),
            e.opts.messages !== !1 &&
              ((n += " , message: 'should NOT have "),
              r == "maxProperties" ? (n += "more") : (n += "fewer"),
              (n += " than "),
              v ? (n += "' + " + d + " + '") : (n += "" + i),
              (n += " properties' ")),
            e.opts.verbose &&
              ((n += " , schema:  "),
              v ? (n += "validate.schema" + l) : (n += "" + i),
              (n +=
                "         , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                f +
                " ")),
            (n += " } "))
          : (n += " {} ");
      var h = n;
      return (
        (n = m.pop()),
        !e.compositeRule && u
          ? e.async
            ? (n += " throw new ValidationError([" + h + "]); ")
            : (n += " validate.errors = [" + h + "]; return false; ")
          : (n +=
              " var err = " +
              h +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (n += "} "),
        u && (n += " else { "),
        n
      );
    },
    CP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = e.opts.$data && i && i.$data,
        d;
      if (
        (v
          ? ((n +=
              " var schema" +
              s +
              " = " +
              e.util.getData(i.$data, o, e.dataPathArr) +
              "; "),
            (d = "schema" + s))
          : (d = i),
        !(v || typeof i == "number"))
      )
        throw new Error(r + " must be number");
      (n += "var division" + s + ";if ("),
        v &&
          (n +=
            " " + d + " !== undefined && ( typeof " + d + " != 'number' || "),
        (n += " (division" + s + " = " + f + " / " + d + ", "),
        e.opts.multipleOfPrecision
          ? (n +=
              " Math.abs(Math.round(division" +
              s +
              ") - division" +
              s +
              ") > 1e-" +
              e.opts.multipleOfPrecision +
              " ")
          : (n += " division" + s + " !== parseInt(division" + s + ") "),
        (n += " ) "),
        v && (n += "  )  "),
        (n += " ) {   ");
      var p = p || [];
      p.push(n),
        (n = ""),
        e.createErrors !== !1
          ? ((n +=
              " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(c) +
              " , params: { multipleOf: " +
              d +
              " } "),
            e.opts.messages !== !1 &&
              ((n += " , message: 'should be multiple of "),
              v ? (n += "' + " + d) : (n += "" + d + "'")),
            e.opts.verbose &&
              ((n += " , schema:  "),
              v ? (n += "validate.schema" + l) : (n += "" + i),
              (n +=
                "         , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                f +
                " ")),
            (n += " } "))
          : (n += " {} ");
      var g = n;
      return (
        (n = p.pop()),
        !e.compositeRule && u
          ? e.async
            ? (n += " throw new ValidationError([" + g + "]); ")
            : (n += " validate.errors = [" + g + "]; return false; ")
          : (n +=
              " var err = " +
              g +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (n += "} "),
        u && (n += " else { "),
        n
      );
    },
    RP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "errs__" + s,
        d = e.util.copy(e);
      d.level++;
      var p = "valid" + d.level;
      if (
        e.opts.strictKeywords
          ? (typeof i == "object" && Object.keys(i).length > 0) || i === !1
          : e.util.schemaHasRules(i, e.RULES.all)
      ) {
        (d.schema = i),
          (d.schemaPath = l),
          (d.errSchemaPath = c),
          (n += " var " + v + " = errors;  ");
        var g = e.compositeRule;
        (e.compositeRule = d.compositeRule = !0), (d.createErrors = !1);
        var m;
        d.opts.allErrors && ((m = d.opts.allErrors), (d.opts.allErrors = !1)),
          (n += " " + e.validate(d) + " "),
          (d.createErrors = !0),
          m && (d.opts.allErrors = m),
          (e.compositeRule = d.compositeRule = g),
          (n += " if (" + p + ") {   ");
        var h = h || [];
        h.push(n),
          (n = ""),
          e.createErrors !== !1
            ? ((n +=
                " { keyword: 'not' , dataPath: (dataPath || '') + " +
                e.errorPath +
                " , schemaPath: " +
                e.util.toQuotedString(c) +
                " , params: {} "),
              e.opts.messages !== !1 &&
                (n += " , message: 'should NOT be valid' "),
              e.opts.verbose &&
                (n +=
                  " , schema: validate.schema" +
                  l +
                  " , parentSchema: validate.schema" +
                  e.schemaPath +
                  " , data: " +
                  f +
                  " "),
              (n += " } "))
            : (n += " {} ");
        var y = n;
        (n = h.pop()),
          !e.compositeRule && u
            ? e.async
              ? (n += " throw new ValidationError([" + y + "]); ")
              : (n += " validate.errors = [" + y + "]; return false; ")
            : (n +=
                " var err = " +
                y +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
          (n +=
            " } else {  errors = " +
            v +
            "; if (vErrors !== null) { if (" +
            v +
            ") vErrors.length = " +
            v +
            "; else vErrors = null; } "),
          e.opts.allErrors && (n += " } ");
      } else
        (n += "  var err =   "),
          e.createErrors !== !1
            ? ((n +=
                " { keyword: 'not' , dataPath: (dataPath || '') + " +
                e.errorPath +
                " , schemaPath: " +
                e.util.toQuotedString(c) +
                " , params: {} "),
              e.opts.messages !== !1 &&
                (n += " , message: 'should NOT be valid' "),
              e.opts.verbose &&
                (n +=
                  " , schema: validate.schema" +
                  l +
                  " , parentSchema: validate.schema" +
                  e.schemaPath +
                  " , data: " +
                  f +
                  " "),
              (n += " } "))
            : (n += " {} "),
          (n +=
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
          u && (n += " if (false) { ");
      return n;
    },
    OP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "valid" + s,
        d = "errs__" + s,
        p = e.util.copy(e),
        g = "";
      p.level++;
      var m = "valid" + p.level,
        h = p.baseId,
        y = "prevValid" + s,
        _ = "passingSchemas" + s;
      n +=
        "var " +
        d +
        " = errors , " +
        y +
        " = false , " +
        v +
        " = false , " +
        _ +
        " = null; ";
      var w = e.compositeRule;
      e.compositeRule = p.compositeRule = !0;
      var E = i;
      if (E)
        for (var P, x = -1, A = E.length - 1; x < A; )
          (P = E[(x += 1)]),
            (
              e.opts.strictKeywords
                ? (typeof P == "object" && Object.keys(P).length > 0) ||
                  P === !1
                : e.util.schemaHasRules(P, e.RULES.all)
            )
              ? ((p.schema = P),
                (p.schemaPath = l + "[" + x + "]"),
                (p.errSchemaPath = c + "/" + x),
                (n += "  " + e.validate(p) + " "),
                (p.baseId = h))
              : (n += " var " + m + " = true; "),
            x &&
              ((n +=
                " if (" +
                m +
                " && " +
                y +
                ") { " +
                v +
                " = false; " +
                _ +
                " = [" +
                _ +
                ", " +
                x +
                "]; } else { "),
              (g += "}")),
            (n +=
              " if (" +
              m +
              ") { " +
              v +
              " = " +
              y +
              " = true; " +
              _ +
              " = " +
              x +
              "; }");
      return (
        (e.compositeRule = p.compositeRule = w),
        (n += "" + g + "if (!" + v + ") {   var err =   "),
        e.createErrors !== !1
          ? ((n +=
              " { keyword: 'oneOf' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(c) +
              " , params: { passingSchemas: " +
              _ +
              " } "),
            e.opts.messages !== !1 &&
              (n += " , message: 'should match exactly one schema in oneOf' "),
            e.opts.verbose &&
              (n +=
                " , schema: validate.schema" +
                l +
                " , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                f +
                " "),
            (n += " } "))
          : (n += " {} "),
        (n +=
          ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        !e.compositeRule &&
          u &&
          (e.async
            ? (n += " throw new ValidationError(vErrors); ")
            : (n += " validate.errors = vErrors; return false; ")),
        (n +=
          "} else {  errors = " +
          d +
          "; if (vErrors !== null) { if (" +
          d +
          ") vErrors.length = " +
          d +
          "; else vErrors = null; }"),
        e.opts.allErrors && (n += " } "),
        n
      );
    },
    AP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = e.opts.$data && i && i.$data,
        d;
      v
        ? ((n +=
            " var schema" +
            s +
            " = " +
            e.util.getData(i.$data, o, e.dataPathArr) +
            "; "),
          (d = "schema" + s))
        : (d = i);
      var p = v ? "(new RegExp(" + d + "))" : e.usePattern(i);
      (n += "if ( "),
        v &&
          (n +=
            " (" + d + " !== undefined && typeof " + d + " != 'string') || "),
        (n += " !" + p + ".test(" + f + ") ) {   ");
      var g = g || [];
      g.push(n),
        (n = ""),
        e.createErrors !== !1
          ? ((n +=
              " { keyword: 'pattern' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(c) +
              " , params: { pattern:  "),
            v ? (n += "" + d) : (n += "" + e.util.toQuotedString(i)),
            (n += "  } "),
            e.opts.messages !== !1 &&
              ((n += ` , message: 'should match pattern "`),
              v
                ? (n += "' + " + d + " + '")
                : (n += "" + e.util.escapeQuotes(i)),
              (n += `"' `)),
            e.opts.verbose &&
              ((n += " , schema:  "),
              v
                ? (n += "validate.schema" + l)
                : (n += "" + e.util.toQuotedString(i)),
              (n +=
                "         , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                f +
                " ")),
            (n += " } "))
          : (n += " {} ");
      var m = n;
      return (
        (n = g.pop()),
        !e.compositeRule && u
          ? e.async
            ? (n += " throw new ValidationError([" + m + "]); ")
            : (n += " validate.errors = [" + m + "]; return false; ")
          : (n +=
              " var err = " +
              m +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
        (n += "} "),
        u && (n += " else { "),
        n
      );
    },
    NP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "errs__" + s,
        d = e.util.copy(e),
        p = "";
      d.level++;
      var g = "valid" + d.level,
        m = "key" + s,
        h = "idx" + s,
        y = (d.dataLevel = e.dataLevel + 1),
        _ = "data" + y,
        w = "dataProperties" + s,
        E = Object.keys(i || {}).filter(N),
        P = e.schema.patternProperties || {},
        x = Object.keys(P).filter(N),
        A = e.schema.additionalProperties,
        M = E.length || x.length,
        H = A === !1,
        V = typeof A == "object" && Object.keys(A).length,
        J = e.opts.removeAdditional,
        z = H || V || J,
        Z = e.opts.ownProperties,
        te = e.baseId,
        me = e.schema.required;
      if (me && !(e.opts.$data && me.$data) && me.length < e.opts.loopRequired)
        var ge = e.util.toHash(me);
      function N(Dt) {
        return Dt !== "__proto__";
      }
      if (
        ((n += "var " + v + " = errors;var " + g + " = true;"),
        Z && (n += " var " + w + " = undefined;"),
        z)
      ) {
        if (
          (Z
            ? (n +=
                " " +
                w +
                " = " +
                w +
                " || Object.keys(" +
                f +
                "); for (var " +
                h +
                "=0; " +
                h +
                "<" +
                w +
                ".length; " +
                h +
                "++) { var " +
                m +
                " = " +
                w +
                "[" +
                h +
                "]; ")
            : (n += " for (var " + m + " in " + f + ") { "),
          M)
        ) {
          if (((n += " var isAdditional" + s + " = !(false "), E.length))
            if (E.length > 8)
              n += " || validate.schema" + l + ".hasOwnProperty(" + m + ") ";
            else {
              var se = E;
              if (se)
                for (var D, k = -1, L = se.length - 1; k < L; )
                  (D = se[(k += 1)]),
                    (n += " || " + m + " == " + e.util.toQuotedString(D) + " ");
            }
          if (x.length) {
            var R = x;
            if (R)
              for (var b, T = -1, q = R.length - 1; T < q; )
                (b = R[(T += 1)]),
                  (n += " || " + e.usePattern(b) + ".test(" + m + ") ");
          }
          n += " ); if (isAdditional" + s + ") { ";
        }
        if (J == "all") n += " delete " + f + "[" + m + "]; ";
        else {
          var G = e.errorPath,
            ee = "' + " + m + " + '";
          if (
            (e.opts._errorDataPathProperty &&
              (e.errorPath = e.util.getPathExpr(
                e.errorPath,
                m,
                e.opts.jsonPointers
              )),
            H)
          )
            if (J) n += " delete " + f + "[" + m + "]; ";
            else {
              n += " " + g + " = false; ";
              var fe = c;
              c = e.errSchemaPath + "/additionalProperties";
              var le = le || [];
              le.push(n),
                (n = ""),
                e.createErrors !== !1
                  ? ((n +=
                      " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " +
                      e.errorPath +
                      " , schemaPath: " +
                      e.util.toQuotedString(c) +
                      " , params: { additionalProperty: '" +
                      ee +
                      "' } "),
                    e.opts.messages !== !1 &&
                      ((n += " , message: '"),
                      e.opts._errorDataPathProperty
                        ? (n += "is an invalid additional property")
                        : (n += "should NOT have additional properties"),
                      (n += "' ")),
                    e.opts.verbose &&
                      (n +=
                        " , schema: false , parentSchema: validate.schema" +
                        e.schemaPath +
                        " , data: " +
                        f +
                        " "),
                    (n += " } "))
                  : (n += " {} ");
              var ve = n;
              (n = le.pop()),
                !e.compositeRule && u
                  ? e.async
                    ? (n += " throw new ValidationError([" + ve + "]); ")
                    : (n += " validate.errors = [" + ve + "]; return false; ")
                  : (n +=
                      " var err = " +
                      ve +
                      ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
                (c = fe),
                u && (n += " break; ");
            }
          else if (V)
            if (J == "failing") {
              n += " var " + v + " = errors;  ";
              var Ae = e.compositeRule;
              (e.compositeRule = d.compositeRule = !0),
                (d.schema = A),
                (d.schemaPath = e.schemaPath + ".additionalProperties"),
                (d.errSchemaPath = e.errSchemaPath + "/additionalProperties"),
                (d.errorPath = e.opts._errorDataPathProperty
                  ? e.errorPath
                  : e.util.getPathExpr(e.errorPath, m, e.opts.jsonPointers));
              var Pe = f + "[" + m + "]";
              d.dataPathArr[y] = m;
              var xe = e.validate(d);
              (d.baseId = te),
                e.util.varOccurences(xe, _) < 2
                  ? (n += " " + e.util.varReplace(xe, _, Pe) + " ")
                  : (n += " var " + _ + " = " + Pe + "; " + xe + " "),
                (n +=
                  " if (!" +
                  g +
                  ") { errors = " +
                  v +
                  "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " +
                  f +
                  "[" +
                  m +
                  "]; }  "),
                (e.compositeRule = d.compositeRule = Ae);
            } else {
              (d.schema = A),
                (d.schemaPath = e.schemaPath + ".additionalProperties"),
                (d.errSchemaPath = e.errSchemaPath + "/additionalProperties"),
                (d.errorPath = e.opts._errorDataPathProperty
                  ? e.errorPath
                  : e.util.getPathExpr(e.errorPath, m, e.opts.jsonPointers));
              var Pe = f + "[" + m + "]";
              d.dataPathArr[y] = m;
              var xe = e.validate(d);
              (d.baseId = te),
                e.util.varOccurences(xe, _) < 2
                  ? (n += " " + e.util.varReplace(xe, _, Pe) + " ")
                  : (n += " var " + _ + " = " + Pe + "; " + xe + " "),
                u && (n += " if (!" + g + ") break; ");
            }
          e.errorPath = G;
        }
        M && (n += " } "),
          (n += " }  "),
          u && ((n += " if (" + g + ") { "), (p += "}"));
      }
      var Te = e.opts.useDefaults && !e.compositeRule;
      if (E.length) {
        var ze = E;
        if (ze)
          for (var D, ae = -1, qe = ze.length - 1; ae < qe; ) {
            D = ze[(ae += 1)];
            var we = i[D];
            if (
              e.opts.strictKeywords
                ? (typeof we == "object" && Object.keys(we).length > 0) ||
                  we === !1
                : e.util.schemaHasRules(we, e.RULES.all)
            ) {
              var ht = e.util.getProperty(D),
                Pe = f + ht,
                Zt = Te && we.default !== void 0;
              (d.schema = we),
                (d.schemaPath = l + ht),
                (d.errSchemaPath = c + "/" + e.util.escapeFragment(D)),
                (d.errorPath = e.util.getPath(
                  e.errorPath,
                  D,
                  e.opts.jsonPointers
                )),
                (d.dataPathArr[y] = e.util.toQuotedString(D));
              var xe = e.validate(d);
              if (((d.baseId = te), e.util.varOccurences(xe, _) < 2)) {
                xe = e.util.varReplace(xe, _, Pe);
                var Ge = Pe;
              } else {
                var Ge = _;
                n += " var " + _ + " = " + Pe + "; ";
              }
              if (Zt) n += " " + xe + " ";
              else {
                if (ge && ge[D]) {
                  (n += " if ( " + Ge + " === undefined "),
                    Z &&
                      (n +=
                        " || ! Object.prototype.hasOwnProperty.call(" +
                        f +
                        ", '" +
                        e.util.escapeQuotes(D) +
                        "') "),
                    (n += ") { " + g + " = false; ");
                  var G = e.errorPath,
                    fe = c,
                    We = e.util.escapeQuotes(D);
                  e.opts._errorDataPathProperty &&
                    (e.errorPath = e.util.getPath(G, D, e.opts.jsonPointers)),
                    (c = e.errSchemaPath + "/required");
                  var le = le || [];
                  le.push(n),
                    (n = ""),
                    e.createErrors !== !1
                      ? ((n +=
                          " { keyword: 'required' , dataPath: (dataPath || '') + " +
                          e.errorPath +
                          " , schemaPath: " +
                          e.util.toQuotedString(c) +
                          " , params: { missingProperty: '" +
                          We +
                          "' } "),
                        e.opts.messages !== !1 &&
                          ((n += " , message: '"),
                          e.opts._errorDataPathProperty
                            ? (n += "is a required property")
                            : (n +=
                                "should have required property \\'" +
                                We +
                                "\\'"),
                          (n += "' ")),
                        e.opts.verbose &&
                          (n +=
                            " , schema: validate.schema" +
                            l +
                            " , parentSchema: validate.schema" +
                            e.schemaPath +
                            " , data: " +
                            f +
                            " "),
                        (n += " } "))
                      : (n += " {} ");
                  var ve = n;
                  (n = le.pop()),
                    !e.compositeRule && u
                      ? e.async
                        ? (n += " throw new ValidationError([" + ve + "]); ")
                        : (n +=
                            " validate.errors = [" + ve + "]; return false; ")
                      : (n +=
                          " var err = " +
                          ve +
                          ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
                    (c = fe),
                    (e.errorPath = G),
                    (n += " } else { ");
                } else
                  u
                    ? ((n += " if ( " + Ge + " === undefined "),
                      Z &&
                        (n +=
                          " || ! Object.prototype.hasOwnProperty.call(" +
                          f +
                          ", '" +
                          e.util.escapeQuotes(D) +
                          "') "),
                      (n += ") { " + g + " = true; } else { "))
                    : ((n += " if (" + Ge + " !== undefined "),
                      Z &&
                        (n +=
                          " &&   Object.prototype.hasOwnProperty.call(" +
                          f +
                          ", '" +
                          e.util.escapeQuotes(D) +
                          "') "),
                      (n += " ) { "));
                n += " " + xe + " } ";
              }
            }
            u && ((n += " if (" + g + ") { "), (p += "}"));
          }
      }
      if (x.length) {
        var tt = x;
        if (tt)
          for (var b, gt = -1, Ht = tt.length - 1; gt < Ht; ) {
            b = tt[(gt += 1)];
            var we = P[b];
            if (
              e.opts.strictKeywords
                ? (typeof we == "object" && Object.keys(we).length > 0) ||
                  we === !1
                : e.util.schemaHasRules(we, e.RULES.all)
            ) {
              (d.schema = we),
                (d.schemaPath =
                  e.schemaPath + ".patternProperties" + e.util.getProperty(b)),
                (d.errSchemaPath =
                  e.errSchemaPath +
                  "/patternProperties/" +
                  e.util.escapeFragment(b)),
                Z
                  ? (n +=
                      " " +
                      w +
                      " = " +
                      w +
                      " || Object.keys(" +
                      f +
                      "); for (var " +
                      h +
                      "=0; " +
                      h +
                      "<" +
                      w +
                      ".length; " +
                      h +
                      "++) { var " +
                      m +
                      " = " +
                      w +
                      "[" +
                      h +
                      "]; ")
                  : (n += " for (var " + m + " in " + f + ") { "),
                (n += " if (" + e.usePattern(b) + ".test(" + m + ")) { "),
                (d.errorPath = e.util.getPathExpr(
                  e.errorPath,
                  m,
                  e.opts.jsonPointers
                ));
              var Pe = f + "[" + m + "]";
              d.dataPathArr[y] = m;
              var xe = e.validate(d);
              (d.baseId = te),
                e.util.varOccurences(xe, _) < 2
                  ? (n += " " + e.util.varReplace(xe, _, Pe) + " ")
                  : (n += " var " + _ + " = " + Pe + "; " + xe + " "),
                u && (n += " if (!" + g + ") break; "),
                (n += " } "),
                u && (n += " else " + g + " = true; "),
                (n += " }  "),
                u && ((n += " if (" + g + ") { "), (p += "}"));
            }
          }
      }
      return u && (n += " " + p + " if (" + v + " == errors) {"), n;
    },
    MP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "errs__" + s,
        d = e.util.copy(e),
        p = "";
      d.level++;
      var g = "valid" + d.level;
      if (
        ((n += "var " + v + " = errors;"),
        e.opts.strictKeywords
          ? (typeof i == "object" && Object.keys(i).length > 0) || i === !1
          : e.util.schemaHasRules(i, e.RULES.all))
      ) {
        (d.schema = i), (d.schemaPath = l), (d.errSchemaPath = c);
        var m = "key" + s,
          h = "idx" + s,
          y = "i" + s,
          _ = "' + " + m + " + '",
          w = (d.dataLevel = e.dataLevel + 1),
          E = "data" + w,
          P = "dataProperties" + s,
          x = e.opts.ownProperties,
          A = e.baseId;
        x && (n += " var " + P + " = undefined; "),
          x
            ? (n +=
                " " +
                P +
                " = " +
                P +
                " || Object.keys(" +
                f +
                "); for (var " +
                h +
                "=0; " +
                h +
                "<" +
                P +
                ".length; " +
                h +
                "++) { var " +
                m +
                " = " +
                P +
                "[" +
                h +
                "]; ")
            : (n += " for (var " + m + " in " + f + ") { "),
          (n += " var startErrs" + s + " = errors; ");
        var M = m,
          H = e.compositeRule;
        e.compositeRule = d.compositeRule = !0;
        var V = e.validate(d);
        (d.baseId = A),
          e.util.varOccurences(V, E) < 2
            ? (n += " " + e.util.varReplace(V, E, M) + " ")
            : (n += " var " + E + " = " + M + "; " + V + " "),
          (e.compositeRule = d.compositeRule = H),
          (n +=
            " if (!" +
            g +
            ") { for (var " +
            y +
            "=startErrs" +
            s +
            "; " +
            y +
            "<errors; " +
            y +
            "++) { vErrors[" +
            y +
            "].propertyName = " +
            m +
            "; }   var err =   "),
          e.createErrors !== !1
            ? ((n +=
                " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " +
                e.errorPath +
                " , schemaPath: " +
                e.util.toQuotedString(c) +
                " , params: { propertyName: '" +
                _ +
                "' } "),
              e.opts.messages !== !1 &&
                (n +=
                  " , message: 'property name \\'" + _ + "\\' is invalid' "),
              e.opts.verbose &&
                (n +=
                  " , schema: validate.schema" +
                  l +
                  " , parentSchema: validate.schema" +
                  e.schemaPath +
                  " , data: " +
                  f +
                  " "),
              (n += " } "))
            : (n += " {} "),
          (n +=
            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
          !e.compositeRule &&
            u &&
            (e.async
              ? (n += " throw new ValidationError(vErrors); ")
              : (n += " validate.errors = vErrors; return false; ")),
          u && (n += " break; "),
          (n += " } }");
      }
      return u && (n += " " + p + " if (" + v + " == errors) {"), n;
    },
    jP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "valid" + s,
        d = e.opts.$data && i && i.$data;
      d &&
        (n +=
          " var schema" +
          s +
          " = " +
          e.util.getData(i.$data, o, e.dataPathArr) +
          "; ");
      var p = "schema" + s;
      if (!d)
        if (
          i.length < e.opts.loopRequired &&
          e.schema.properties &&
          Object.keys(e.schema.properties).length
        ) {
          var g = [],
            m = i;
          if (m)
            for (var h, y = -1, _ = m.length - 1; y < _; ) {
              h = m[(y += 1)];
              var w = e.schema.properties[h];
              (w &&
                (e.opts.strictKeywords
                  ? (typeof w == "object" && Object.keys(w).length > 0) ||
                    w === !1
                  : e.util.schemaHasRules(w, e.RULES.all))) ||
                (g[g.length] = h);
            }
        } else var g = i;
      if (d || g.length) {
        var E = e.errorPath,
          P = d || g.length >= e.opts.loopRequired,
          x = e.opts.ownProperties;
        if (u)
          if (((n += " var missing" + s + "; "), P)) {
            d || (n += " var " + p + " = validate.schema" + l + "; ");
            var A = "i" + s,
              M = "schema" + s + "[" + A + "]",
              H = "' + " + M + " + '";
            e.opts._errorDataPathProperty &&
              (e.errorPath = e.util.getPathExpr(E, M, e.opts.jsonPointers)),
              (n += " var " + v + " = true; "),
              d &&
                (n +=
                  " if (schema" +
                  s +
                  " === undefined) " +
                  v +
                  " = true; else if (!Array.isArray(schema" +
                  s +
                  ")) " +
                  v +
                  " = false; else {"),
              (n +=
                " for (var " +
                A +
                " = 0; " +
                A +
                " < " +
                p +
                ".length; " +
                A +
                "++) { " +
                v +
                " = " +
                f +
                "[" +
                p +
                "[" +
                A +
                "]] !== undefined "),
              x &&
                (n +=
                  " &&   Object.prototype.hasOwnProperty.call(" +
                  f +
                  ", " +
                  p +
                  "[" +
                  A +
                  "]) "),
              (n += "; if (!" + v + ") break; } "),
              d && (n += "  }  "),
              (n += "  if (!" + v + ") {   ");
            var V = V || [];
            V.push(n),
              (n = ""),
              e.createErrors !== !1
                ? ((n +=
                    " { keyword: 'required' , dataPath: (dataPath || '') + " +
                    e.errorPath +
                    " , schemaPath: " +
                    e.util.toQuotedString(c) +
                    " , params: { missingProperty: '" +
                    H +
                    "' } "),
                  e.opts.messages !== !1 &&
                    ((n += " , message: '"),
                    e.opts._errorDataPathProperty
                      ? (n += "is a required property")
                      : (n += "should have required property \\'" + H + "\\'"),
                    (n += "' ")),
                  e.opts.verbose &&
                    (n +=
                      " , schema: validate.schema" +
                      l +
                      " , parentSchema: validate.schema" +
                      e.schemaPath +
                      " , data: " +
                      f +
                      " "),
                  (n += " } "))
                : (n += " {} ");
            var J = n;
            (n = V.pop()),
              !e.compositeRule && u
                ? e.async
                  ? (n += " throw new ValidationError([" + J + "]); ")
                  : (n += " validate.errors = [" + J + "]; return false; ")
                : (n +=
                    " var err = " +
                    J +
                    ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
              (n += " } else { ");
          } else {
            n += " if ( ";
            var z = g;
            if (z)
              for (var Z, A = -1, te = z.length - 1; A < te; ) {
                (Z = z[(A += 1)]), A && (n += " || ");
                var me = e.util.getProperty(Z),
                  ge = f + me;
                (n += " ( ( " + ge + " === undefined "),
                  x &&
                    (n +=
                      " || ! Object.prototype.hasOwnProperty.call(" +
                      f +
                      ", '" +
                      e.util.escapeQuotes(Z) +
                      "') "),
                  (n +=
                    ") && (missing" +
                    s +
                    " = " +
                    e.util.toQuotedString(e.opts.jsonPointers ? Z : me) +
                    ") ) ");
              }
            n += ") {  ";
            var M = "missing" + s,
              H = "' + " + M + " + '";
            e.opts._errorDataPathProperty &&
              (e.errorPath = e.opts.jsonPointers
                ? e.util.getPathExpr(E, M, !0)
                : E + " + " + M);
            var V = V || [];
            V.push(n),
              (n = ""),
              e.createErrors !== !1
                ? ((n +=
                    " { keyword: 'required' , dataPath: (dataPath || '') + " +
                    e.errorPath +
                    " , schemaPath: " +
                    e.util.toQuotedString(c) +
                    " , params: { missingProperty: '" +
                    H +
                    "' } "),
                  e.opts.messages !== !1 &&
                    ((n += " , message: '"),
                    e.opts._errorDataPathProperty
                      ? (n += "is a required property")
                      : (n += "should have required property \\'" + H + "\\'"),
                    (n += "' ")),
                  e.opts.verbose &&
                    (n +=
                      " , schema: validate.schema" +
                      l +
                      " , parentSchema: validate.schema" +
                      e.schemaPath +
                      " , data: " +
                      f +
                      " "),
                  (n += " } "))
                : (n += " {} ");
            var J = n;
            (n = V.pop()),
              !e.compositeRule && u
                ? e.async
                  ? (n += " throw new ValidationError([" + J + "]); ")
                  : (n += " validate.errors = [" + J + "]; return false; ")
                : (n +=
                    " var err = " +
                    J +
                    ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
              (n += " } else { ");
          }
        else if (P) {
          d || (n += " var " + p + " = validate.schema" + l + "; ");
          var A = "i" + s,
            M = "schema" + s + "[" + A + "]",
            H = "' + " + M + " + '";
          e.opts._errorDataPathProperty &&
            (e.errorPath = e.util.getPathExpr(E, M, e.opts.jsonPointers)),
            d &&
              ((n +=
                " if (" + p + " && !Array.isArray(" + p + ")) {  var err =   "),
              e.createErrors !== !1
                ? ((n +=
                    " { keyword: 'required' , dataPath: (dataPath || '') + " +
                    e.errorPath +
                    " , schemaPath: " +
                    e.util.toQuotedString(c) +
                    " , params: { missingProperty: '" +
                    H +
                    "' } "),
                  e.opts.messages !== !1 &&
                    ((n += " , message: '"),
                    e.opts._errorDataPathProperty
                      ? (n += "is a required property")
                      : (n += "should have required property \\'" + H + "\\'"),
                    (n += "' ")),
                  e.opts.verbose &&
                    (n +=
                      " , schema: validate.schema" +
                      l +
                      " , parentSchema: validate.schema" +
                      e.schemaPath +
                      " , data: " +
                      f +
                      " "),
                  (n += " } "))
                : (n += " {} "),
              (n +=
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" +
                p +
                " !== undefined) { ")),
            (n +=
              " for (var " +
              A +
              " = 0; " +
              A +
              " < " +
              p +
              ".length; " +
              A +
              "++) { if (" +
              f +
              "[" +
              p +
              "[" +
              A +
              "]] === undefined "),
            x &&
              (n +=
                " || ! Object.prototype.hasOwnProperty.call(" +
                f +
                ", " +
                p +
                "[" +
                A +
                "]) "),
            (n += ") {  var err =   "),
            e.createErrors !== !1
              ? ((n +=
                  " { keyword: 'required' , dataPath: (dataPath || '') + " +
                  e.errorPath +
                  " , schemaPath: " +
                  e.util.toQuotedString(c) +
                  " , params: { missingProperty: '" +
                  H +
                  "' } "),
                e.opts.messages !== !1 &&
                  ((n += " , message: '"),
                  e.opts._errorDataPathProperty
                    ? (n += "is a required property")
                    : (n += "should have required property \\'" + H + "\\'"),
                  (n += "' ")),
                e.opts.verbose &&
                  (n +=
                    " , schema: validate.schema" +
                    l +
                    " , parentSchema: validate.schema" +
                    e.schemaPath +
                    " , data: " +
                    f +
                    " "),
                (n += " } "))
              : (n += " {} "),
            (n +=
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } "),
            d && (n += "  }  ");
        } else {
          var N = g;
          if (N)
            for (var Z, se = -1, D = N.length - 1; se < D; ) {
              Z = N[(se += 1)];
              var me = e.util.getProperty(Z),
                H = e.util.escapeQuotes(Z),
                ge = f + me;
              e.opts._errorDataPathProperty &&
                (e.errorPath = e.util.getPath(E, Z, e.opts.jsonPointers)),
                (n += " if ( " + ge + " === undefined "),
                x &&
                  (n +=
                    " || ! Object.prototype.hasOwnProperty.call(" +
                    f +
                    ", '" +
                    e.util.escapeQuotes(Z) +
                    "') "),
                (n += ") {  var err =   "),
                e.createErrors !== !1
                  ? ((n +=
                      " { keyword: 'required' , dataPath: (dataPath || '') + " +
                      e.errorPath +
                      " , schemaPath: " +
                      e.util.toQuotedString(c) +
                      " , params: { missingProperty: '" +
                      H +
                      "' } "),
                    e.opts.messages !== !1 &&
                      ((n += " , message: '"),
                      e.opts._errorDataPathProperty
                        ? (n += "is a required property")
                        : (n +=
                            "should have required property \\'" + H + "\\'"),
                      (n += "' ")),
                    e.opts.verbose &&
                      (n +=
                        " , schema: validate.schema" +
                        l +
                        " , parentSchema: validate.schema" +
                        e.schemaPath +
                        " , data: " +
                        f +
                        " "),
                    (n += " } "))
                  : (n += " {} "),
                (n +=
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ");
            }
        }
        e.errorPath = E;
      } else u && (n += " if (true) {");
      return n;
    },
    DP = function (e, r, a) {
      var n = " ",
        s = e.level,
        o = e.dataLevel,
        i = e.schema[r],
        l = e.schemaPath + e.util.getProperty(r),
        c = e.errSchemaPath + "/" + r,
        u = !e.opts.allErrors,
        f = "data" + (o || ""),
        v = "valid" + s,
        d = e.opts.$data && i && i.$data,
        p;
      if (
        (d
          ? ((n +=
              " var schema" +
              s +
              " = " +
              e.util.getData(i.$data, o, e.dataPathArr) +
              "; "),
            (p = "schema" + s))
          : (p = i),
        (i || d) && e.opts.uniqueItems !== !1)
      ) {
        d &&
          (n +=
            " var " +
            v +
            "; if (" +
            p +
            " === false || " +
            p +
            " === undefined) " +
            v +
            " = true; else if (typeof " +
            p +
            " != 'boolean') " +
            v +
            " = false; else { "),
          (n +=
            " var i = " + f + ".length , " + v + " = true , j; if (i > 1) { ");
        var g = e.schema.items && e.schema.items.type,
          m = Array.isArray(g);
        if (
          !g ||
          g == "object" ||
          g == "array" ||
          (m && (g.indexOf("object") >= 0 || g.indexOf("array") >= 0))
        )
          n +=
            " outer: for (;i--;) { for (j = i; j--;) { if (equal(" +
            f +
            "[i], " +
            f +
            "[j])) { " +
            v +
            " = false; break outer; } } } ";
        else {
          n +=
            " var itemIndices = {}, item; for (;i--;) { var item = " +
            f +
            "[i]; ";
          var h = "checkDataType" + (m ? "s" : "");
          (n +=
            " if (" +
            e.util[h](g, "item", e.opts.strictNumbers, !0) +
            ") continue; "),
            m && (n += ` if (typeof item == 'string') item = '"' + item; `),
            (n +=
              " if (typeof itemIndices[item] == 'number') { " +
              v +
              " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ");
        }
        (n += " } "), d && (n += "  }  "), (n += " if (!" + v + ") {   ");
        var y = y || [];
        y.push(n),
          (n = ""),
          e.createErrors !== !1
            ? ((n +=
                " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " +
                e.errorPath +
                " , schemaPath: " +
                e.util.toQuotedString(c) +
                " , params: { i: i, j: j } "),
              e.opts.messages !== !1 &&
                (n +=
                  " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "),
              e.opts.verbose &&
                ((n += " , schema:  "),
                d ? (n += "validate.schema" + l) : (n += "" + i),
                (n +=
                  "         , parentSchema: validate.schema" +
                  e.schemaPath +
                  " , data: " +
                  f +
                  " ")),
              (n += " } "))
            : (n += " {} ");
        var _ = n;
        (n = y.pop()),
          !e.compositeRule && u
            ? e.async
              ? (n += " throw new ValidationError([" + _ + "]); ")
              : (n += " validate.errors = [" + _ + "]; return false; ")
            : (n +=
                " var err = " +
                _ +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
          (n += " } "),
          u && (n += " else { ");
      } else u && (n += " if (true) { ");
      return n;
    },
    LP = {
      $ref: _P,
      allOf: wP,
      anyOf: bP,
      $comment: EP,
      const: SP,
      contains: $P,
      dependencies: PP,
      enum: TP,
      format: xP,
      if: IP,
      items: kP,
      maximum: Xh,
      minimum: Xh,
      maxItems: em,
      minItems: em,
      maxLength: tm,
      minLength: tm,
      maxProperties: rm,
      minProperties: rm,
      multipleOf: CP,
      not: RP,
      oneOf: OP,
      pattern: AP,
      properties: NP,
      propertyNames: MP,
      required: jP,
      uniqueItems: DP,
      validate: Lh,
    },
    nm = LP,
    uu = Sa.toHash,
    zP = function () {
      var e = [
          {
            type: "number",
            rules: [
              { maximum: ["exclusiveMaximum"] },
              { minimum: ["exclusiveMinimum"] },
              "multipleOf",
              "format",
            ],
          },
          {
            type: "string",
            rules: ["maxLength", "minLength", "pattern", "format"],
          },
          {
            type: "array",
            rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"],
          },
          {
            type: "object",
            rules: [
              "maxProperties",
              "minProperties",
              "required",
              "dependencies",
              "propertyNames",
              { properties: ["additionalProperties", "patternProperties"] },
            ],
          },
          {
            rules: [
              "$ref",
              "const",
              "enum",
              "not",
              "anyOf",
              "oneOf",
              "allOf",
              "if",
            ],
          },
        ],
        r = ["type", "$comment"],
        a = [
          "$schema",
          "$id",
          "id",
          "$data",
          "$async",
          "title",
          "description",
          "default",
          "definitions",
          "examples",
          "readOnly",
          "writeOnly",
          "contentMediaType",
          "contentEncoding",
          "additionalItems",
          "then",
          "else",
        ],
        n = [
          "number",
          "integer",
          "string",
          "array",
          "object",
          "boolean",
          "null",
        ];
      return (
        (e.all = uu(r)),
        (e.types = uu(n)),
        e.forEach(function (s) {
          (s.rules = s.rules.map(function (o) {
            var i;
            if (typeof o == "object") {
              var l = Object.keys(o)[0];
              (i = o[l]),
                (o = l),
                i.forEach(function (u) {
                  r.push(u), (e.all[u] = !0);
                });
            }
            r.push(o);
            var c = (e.all[o] = { keyword: o, code: nm[o], implements: i });
            return c;
          })),
            (e.all.$comment = { keyword: "$comment", code: nm.$comment }),
            s.type && (e.types[s.type] = s);
        }),
        (e.keywords = uu(r.concat(a))),
        (e.custom = {}),
        e
      );
    },
    am = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum",
      "maxLength",
      "minLength",
      "pattern",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "maxProperties",
      "minProperties",
      "required",
      "additionalProperties",
      "enum",
      "format",
      "const",
    ],
    qP = function (t, e) {
      for (var r = 0; r < e.length; r++) {
        t = JSON.parse(JSON.stringify(t));
        var a = e[r].split("/"),
          n = t,
          s;
        for (s = 1; s < a.length; s++) n = n[a[s]];
        for (s = 0; s < am.length; s++) {
          var o = am[s],
            i = n[o];
          i &&
            (n[o] = {
              anyOf: [
                i,
                {
                  $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
                },
              ],
            });
        }
      }
      return t;
    },
    UP = iu.MissingRef,
    FP = sm;
  function sm(t, e, r) {
    var a = this;
    if (typeof this._opts.loadSchema != "function")
      throw new Error("options.loadSchema should be a function");
    typeof e == "function" && ((r = e), (e = void 0));
    var n = s(t).then(function () {
      var i = a._addSchema(t, void 0, e);
      return i.validate || o(i);
    });
    return (
      r &&
        n.then(function (i) {
          r(null, i);
        }, r),
      n
    );
    function s(i) {
      var l = i.$schema;
      return l && !a.getSchema(l)
        ? sm.call(a, { $ref: l }, !0)
        : Promise.resolve();
    }
    function o(i) {
      try {
        return a._compile(i);
      } catch (c) {
        if (c instanceof UP) return l(c);
        throw c;
      }
      function l(c) {
        var u = c.missingSchema;
        if (d(u))
          throw new Error(
            "Schema " +
              u +
              " is loaded but " +
              c.missingRef +
              " cannot be resolved"
          );
        var f = a._loadingSchemas[u];
        return (
          f ||
            ((f = a._loadingSchemas[u] = a._opts.loadSchema(u)), f.then(v, v)),
          f
            .then(function (p) {
              if (!d(u))
                return s(p).then(function () {
                  d(u) || a.addSchema(p, u, void 0, e);
                });
            })
            .then(function () {
              return o(i);
            })
        );
        function v() {
          delete a._loadingSchemas[u];
        }
        function d(p) {
          return a._refs[p] || a._schemas[p];
        }
      }
    }
  }
  var VP = function (e, r, a) {
    var n = " ",
      s = e.level,
      o = e.dataLevel,
      i = e.schema[r],
      l = e.schemaPath + e.util.getProperty(r),
      c = e.errSchemaPath + "/" + r,
      u = !e.opts.allErrors,
      f,
      v = "data" + (o || ""),
      d = "valid" + s,
      p = "errs__" + s,
      g = e.opts.$data && i && i.$data,
      m;
    g
      ? ((n +=
          " var schema" +
          s +
          " = " +
          e.util.getData(i.$data, o, e.dataPathArr) +
          "; "),
        (m = "schema" + s))
      : (m = i);
    var h = this,
      y = "definition" + s,
      _ = h.definition,
      w = "",
      E,
      P,
      x,
      A,
      M;
    if (g && _.$data) {
      M = "keywordValidate" + s;
      var H = _.validateSchema;
      n +=
        " var " +
        y +
        " = RULES.custom['" +
        r +
        "'].definition; var " +
        M +
        " = " +
        y +
        ".validate;";
    } else {
      if (((A = e.useCustomRule(h, i, e.schema, e)), !A)) return;
      (m = "validate.schema" + l),
        (M = A.code),
        (E = _.compile),
        (P = _.inline),
        (x = _.macro);
    }
    var V = M + ".errors",
      J = "i" + s,
      z = "ruleErr" + s,
      Z = _.async;
    if (Z && !e.async) throw new Error("async keyword in sync schema");
    if (
      (P || x || (n += "" + V + " = null;"),
      (n += "var " + p + " = errors;var " + d + ";"),
      g &&
        _.$data &&
        ((w += "}"),
        (n += " if (" + m + " === undefined) { " + d + " = true; } else { "),
        H &&
          ((w += "}"),
          (n +=
            " " +
            d +
            " = " +
            y +
            ".validateSchema(" +
            m +
            "); if (" +
            d +
            ") { "))),
      P)
    )
      _.statements
        ? (n += " " + A.validate + " ")
        : (n += " " + d + " = " + A.validate + "; ");
    else if (x) {
      var te = e.util.copy(e),
        w = "";
      te.level++;
      var me = "valid" + te.level;
      (te.schema = A.validate), (te.schemaPath = "");
      var ge = e.compositeRule;
      e.compositeRule = te.compositeRule = !0;
      var N = e.validate(te).replace(/validate\.schema/g, M);
      (e.compositeRule = te.compositeRule = ge), (n += " " + N);
    } else {
      var se = se || [];
      se.push(n),
        (n = ""),
        (n += "  " + M + ".call( "),
        e.opts.passContext ? (n += "this") : (n += "self"),
        E || _.schema === !1
          ? (n += " , " + v + " ")
          : (n +=
              " , " +
              m +
              " , " +
              v +
              " , validate.schema" +
              e.schemaPath +
              " "),
        (n += " , (dataPath || '')"),
        e.errorPath != '""' && (n += " + " + e.errorPath);
      var D = o ? "data" + (o - 1 || "") : "parentData",
        k = o ? e.dataPathArr[o] : "parentDataProperty";
      n += " , " + D + " , " + k + " , rootData )  ";
      var L = n;
      (n = se.pop()),
        _.errors === !1
          ? ((n += " " + d + " = "), Z && (n += "await "), (n += "" + L + "; "))
          : Z
          ? ((V = "customErrors" + s),
            (n +=
              " var " +
              V +
              " = null; try { " +
              d +
              " = await " +
              L +
              "; } catch (e) { " +
              d +
              " = false; if (e instanceof ValidationError) " +
              V +
              " = e.errors; else throw e; } "))
          : (n += " " + V + " = null; " + d + " = " + L + "; ");
    }
    if (
      (_.modifying &&
        (n += " if (" + D + ") " + v + " = " + D + "[" + k + "];"),
      (n += "" + w),
      _.valid)
    )
      u && (n += " if (true) { ");
    else {
      (n += " if ( "),
        _.valid === void 0
          ? ((n += " !"), x ? (n += "" + me) : (n += "" + d))
          : (n += " " + !_.valid + " "),
        (n += ") { "),
        (f = h.keyword);
      var se = se || [];
      se.push(n), (n = "");
      var se = se || [];
      se.push(n),
        (n = ""),
        e.createErrors !== !1
          ? ((n +=
              " { keyword: '" +
              (f || "custom") +
              "' , dataPath: (dataPath || '') + " +
              e.errorPath +
              " , schemaPath: " +
              e.util.toQuotedString(c) +
              " , params: { keyword: '" +
              h.keyword +
              "' } "),
            e.opts.messages !== !1 &&
              (n +=
                ` , message: 'should pass "` +
                h.keyword +
                `" keyword validation' `),
            e.opts.verbose &&
              (n +=
                " , schema: validate.schema" +
                l +
                " , parentSchema: validate.schema" +
                e.schemaPath +
                " , data: " +
                v +
                " "),
            (n += " } "))
          : (n += " {} ");
      var R = n;
      (n = se.pop()),
        !e.compositeRule && u
          ? e.async
            ? (n += " throw new ValidationError([" + R + "]); ")
            : (n += " validate.errors = [" + R + "]; return false; ")
          : (n +=
              " var err = " +
              R +
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ");
      var b = n;
      (n = se.pop()),
        P
          ? _.errors
            ? _.errors != "full" &&
              ((n +=
                "  for (var " +
                J +
                "=" +
                p +
                "; " +
                J +
                "<errors; " +
                J +
                "++) { var " +
                z +
                " = vErrors[" +
                J +
                "]; if (" +
                z +
                ".dataPath === undefined) " +
                z +
                ".dataPath = (dataPath || '') + " +
                e.errorPath +
                "; if (" +
                z +
                ".schemaPath === undefined) { " +
                z +
                '.schemaPath = "' +
                c +
                '"; } '),
              e.opts.verbose &&
                (n +=
                  " " +
                  z +
                  ".schema = " +
                  m +
                  "; " +
                  z +
                  ".data = " +
                  v +
                  "; "),
              (n += " } "))
            : _.errors === !1
            ? (n += " " + b + " ")
            : ((n +=
                " if (" +
                p +
                " == errors) { " +
                b +
                " } else {  for (var " +
                J +
                "=" +
                p +
                "; " +
                J +
                "<errors; " +
                J +
                "++) { var " +
                z +
                " = vErrors[" +
                J +
                "]; if (" +
                z +
                ".dataPath === undefined) " +
                z +
                ".dataPath = (dataPath || '') + " +
                e.errorPath +
                "; if (" +
                z +
                ".schemaPath === undefined) { " +
                z +
                '.schemaPath = "' +
                c +
                '"; } '),
              e.opts.verbose &&
                (n +=
                  " " +
                  z +
                  ".schema = " +
                  m +
                  "; " +
                  z +
                  ".data = " +
                  v +
                  "; "),
              (n += " } } "))
          : x
          ? ((n += "   var err =   "),
            e.createErrors !== !1
              ? ((n +=
                  " { keyword: '" +
                  (f || "custom") +
                  "' , dataPath: (dataPath || '') + " +
                  e.errorPath +
                  " , schemaPath: " +
                  e.util.toQuotedString(c) +
                  " , params: { keyword: '" +
                  h.keyword +
                  "' } "),
                e.opts.messages !== !1 &&
                  (n +=
                    ` , message: 'should pass "` +
                    h.keyword +
                    `" keyword validation' `),
                e.opts.verbose &&
                  (n +=
                    " , schema: validate.schema" +
                    l +
                    " , parentSchema: validate.schema" +
                    e.schemaPath +
                    " , data: " +
                    v +
                    " "),
                (n += " } "))
              : (n += " {} "),
            (n +=
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "),
            !e.compositeRule &&
              u &&
              (e.async
                ? (n += " throw new ValidationError(vErrors); ")
                : (n += " validate.errors = vErrors; return false; ")))
          : _.errors === !1
          ? (n += " " + b + " ")
          : ((n +=
              " if (Array.isArray(" +
              V +
              ")) { if (vErrors === null) vErrors = " +
              V +
              "; else vErrors = vErrors.concat(" +
              V +
              "); errors = vErrors.length;  for (var " +
              J +
              "=" +
              p +
              "; " +
              J +
              "<errors; " +
              J +
              "++) { var " +
              z +
              " = vErrors[" +
              J +
              "]; if (" +
              z +
              ".dataPath === undefined) " +
              z +
              ".dataPath = (dataPath || '') + " +
              e.errorPath +
              ";  " +
              z +
              '.schemaPath = "' +
              c +
              '";  '),
            e.opts.verbose &&
              (n +=
                " " + z + ".schema = " + m + "; " + z + ".data = " + v + "; "),
            (n += " } } else { " + b + " } ")),
        (n += " } "),
        u && (n += " else { ");
    }
    return n;
  };
  const om = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
      nonNegativeInteger: { type: "integer", minimum: 0 },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
      },
      simpleTypes: {
        enum: [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string",
        ],
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: !0,
        default: [],
      },
    },
    type: ["object", "boolean"],
    properties: {
      $id: { type: "string", format: "uri-reference" },
      $schema: { type: "string", format: "uri" },
      $ref: { type: "string", format: "uri-reference" },
      $comment: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      default: !0,
      readOnly: { type: "boolean", default: !1 },
      examples: { type: "array", items: !0 },
      multipleOf: { type: "number", exclusiveMinimum: 0 },
      maximum: { type: "number" },
      exclusiveMaximum: { type: "number" },
      minimum: { type: "number" },
      exclusiveMinimum: { type: "number" },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: { type: "string", format: "regex" },
      additionalItems: { $ref: "#" },
      items: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
        default: !0,
      },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: { type: "boolean", default: !1 },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {},
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {},
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        propertyNames: { format: "regex" },
        default: {},
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
        },
      },
      propertyNames: { $ref: "#" },
      const: !0,
      enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: !0,
          },
        ],
      },
      format: { type: "string" },
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      if: { $ref: "#" },
      then: { $ref: "#" },
      else: { $ref: "#" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" },
    },
    default: !0,
  };
  var im = om,
    ZP = {
      $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
      definitions: { simpleTypes: im.definitions.simpleTypes },
      type: "object",
      dependencies: {
        schema: ["validate"],
        $data: ["validate"],
        statements: ["inline"],
        valid: { not: { required: ["macro"] } },
      },
      properties: {
        type: im.properties.type,
        schema: { type: "boolean" },
        statements: { type: "boolean" },
        dependencies: { type: "array", items: { type: "string" } },
        metaSchema: { type: "object" },
        modifying: { type: "boolean" },
        valid: { type: "boolean" },
        $data: { type: "boolean" },
        async: { type: "boolean" },
        errors: { anyOf: [{ type: "boolean" }, { const: "full" }] },
      },
    },
    HP = /^[a-z_$][a-z0-9_$-]*$/i,
    BP = VP,
    JP = ZP,
    KP = { add: GP, get: WP, remove: QP, validate: du };
  function GP(t, e) {
    var r = this.RULES;
    if (r.keywords[t]) throw new Error("Keyword " + t + " is already defined");
    if (!HP.test(t))
      throw new Error("Keyword " + t + " is not a valid identifier");
    if (e) {
      this.validateKeyword(e, !0);
      var a = e.type;
      if (Array.isArray(a)) for (var n = 0; n < a.length; n++) o(t, a[n], e);
      else o(t, a, e);
      var s = e.metaSchema;
      s &&
        (e.$data &&
          this._opts.$data &&
          (s = {
            anyOf: [
              s,
              {
                $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
              },
            ],
          }),
        (e.validateSchema = this.compile(s, !0)));
    }
    r.keywords[t] = r.all[t] = !0;
    function o(i, l, c) {
      for (var u, f = 0; f < r.length; f++) {
        var v = r[f];
        if (v.type == l) {
          u = v;
          break;
        }
      }
      u || ((u = { type: l, rules: [] }), r.push(u));
      var d = {
        keyword: i,
        definition: c,
        custom: !0,
        code: BP,
        implements: c.implements,
      };
      u.rules.push(d), (r.custom[i] = d);
    }
    return this;
  }
  function WP(t) {
    var e = this.RULES.custom[t];
    return e ? e.definition : this.RULES.keywords[t] || !1;
  }
  function QP(t) {
    var e = this.RULES;
    delete e.keywords[t], delete e.all[t], delete e.custom[t];
    for (var r = 0; r < e.length; r++)
      for (var a = e[r].rules, n = 0; n < a.length; n++)
        if (a[n].keyword == t) {
          a.splice(n, 1);
          break;
        }
    return this;
  }
  function du(t, e) {
    du.errors = null;
    var r = (this._validateKeyword =
      this._validateKeyword || this.compile(JP, !0));
    if (r(t)) return !0;
    if (((du.errors = r.errors), e))
      throw new Error(
        "custom keyword definition is invalid: " + this.errorsText(r.errors)
      );
    return !1;
  }
  const YP = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description:
      "Meta-schema for $data reference (JSON Schema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [
          { format: "relative-json-pointer" },
          { format: "json-pointer" },
        ],
      },
    },
    additionalProperties: !1,
  };
  var lm = Y$,
    Un = ru,
    XP = sP,
    cm = Rh,
    eT = Dh,
    tT = fP,
    rT = zP,
    um = qP,
    dm = Sa,
    nT = mt;
  (mt.prototype.validate = sT),
    (mt.prototype.compile = oT),
    (mt.prototype.addSchema = iT),
    (mt.prototype.addMetaSchema = lT),
    (mt.prototype.validateSchema = cT),
    (mt.prototype.getSchema = dT),
    (mt.prototype.removeSchema = pT),
    (mt.prototype.addFormat = bT),
    (mt.prototype.errorsText = wT),
    (mt.prototype._addSchema = hT),
    (mt.prototype._compile = mT),
    (mt.prototype.compileAsync = FP);
  var ui = KP;
  (mt.prototype.addKeyword = ui.add),
    (mt.prototype.getKeyword = ui.get),
    (mt.prototype.removeKeyword = ui.remove),
    (mt.prototype.validateKeyword = ui.validate);
  var fm = iu;
  (mt.ValidationError = fm.Validation),
    (mt.MissingRefError = fm.MissingRef),
    (mt.$dataMetaSchema = um);
  var di = "http://json-schema.org/draft-07/schema",
    pm = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"],
    aT = ["/properties"];
  function mt(t) {
    if (!(this instanceof mt)) return new mt(t);
    (t = this._opts = dm.copy(t) || {}),
      xT(this),
      (this._schemas = {}),
      (this._refs = {}),
      (this._fragments = {}),
      (this._formats = tT(t.format)),
      (this._cache = t.cache || new XP()),
      (this._loadingSchemas = {}),
      (this._compilations = []),
      (this.RULES = rT()),
      (this._getId = vT(t)),
      (t.loopRequired = t.loopRequired || 1 / 0),
      t.errorDataPath == "property" && (t._errorDataPathProperty = !0),
      t.serialize === void 0 && (t.serialize = eT),
      (this._metaOpts = TT(this)),
      t.formats && $T(this),
      t.keywords && PT(this),
      ET(this),
      typeof t.meta == "object" && this.addMetaSchema(t.meta),
      t.nullable &&
        this.addKeyword("nullable", { metaSchema: { type: "boolean" } }),
      ST(this);
  }
  function sT(t, e) {
    var r;
    if (typeof t == "string") {
      if (((r = this.getSchema(t)), !r))
        throw new Error('no schema with key or ref "' + t + '"');
    } else {
      var a = this._addSchema(t);
      r = a.validate || this._compile(a);
    }
    var n = r(e);
    return r.$async !== !0 && (this.errors = r.errors), n;
  }
  function oT(t, e) {
    var r = this._addSchema(t, void 0, e);
    return r.validate || this._compile(r);
  }
  function iT(t, e, r, a) {
    if (Array.isArray(t)) {
      for (var n = 0; n < t.length; n++) this.addSchema(t[n], void 0, r, a);
      return this;
    }
    var s = this._getId(t);
    if (s !== void 0 && typeof s != "string")
      throw new Error("schema id must be string");
    return (
      (e = Un.normalizeId(e || s)),
      mm(this, e),
      (this._schemas[e] = this._addSchema(t, r, a, !0)),
      this
    );
  }
  function lT(t, e, r) {
    return this.addSchema(t, e, r, !0), this;
  }
  function cT(t, e) {
    var r = t.$schema;
    if (r !== void 0 && typeof r != "string")
      throw new Error("$schema must be a string");
    if (((r = r || this._opts.defaultMeta || uT(this)), !r))
      return (
        this.logger.warn("meta-schema not available"), (this.errors = null), !0
      );
    var a = this.validate(r, t);
    if (!a && e) {
      var n = "schema is invalid: " + this.errorsText();
      if (this._opts.validateSchema == "log") this.logger.error(n);
      else throw new Error(n);
    }
    return a;
  }
  function uT(t) {
    var e = t._opts.meta;
    return (
      (t._opts.defaultMeta =
        typeof e == "object"
          ? t._getId(e) || e
          : t.getSchema(di)
          ? di
          : void 0),
      t._opts.defaultMeta
    );
  }
  function dT(t) {
    var e = hm(this, t);
    switch (typeof e) {
      case "object":
        return e.validate || this._compile(e);
      case "string":
        return this.getSchema(e);
      case "undefined":
        return fT(this, t);
    }
  }
  function fT(t, e) {
    var r = Un.schema.call(t, { schema: {} }, e);
    if (r) {
      var a = r.schema,
        n = r.root,
        s = r.baseId,
        o = lm.call(t, a, n, void 0, s);
      return (
        (t._fragments[e] = new cm({
          ref: e,
          fragment: !0,
          schema: a,
          root: n,
          baseId: s,
          validate: o,
        })),
        o
      );
    }
  }
  function hm(t, e) {
    return (
      (e = Un.normalizeId(e)), t._schemas[e] || t._refs[e] || t._fragments[e]
    );
  }
  function pT(t) {
    if (t instanceof RegExp)
      return fi(this, this._schemas, t), fi(this, this._refs, t), this;
    switch (typeof t) {
      case "undefined":
        return (
          fi(this, this._schemas),
          fi(this, this._refs),
          this._cache.clear(),
          this
        );
      case "string":
        var e = hm(this, t);
        return (
          e && this._cache.del(e.cacheKey),
          delete this._schemas[t],
          delete this._refs[t],
          this
        );
      case "object":
        var r = this._opts.serialize,
          a = r ? r(t) : t;
        this._cache.del(a);
        var n = this._getId(t);
        n &&
          ((n = Un.normalizeId(n)),
          delete this._schemas[n],
          delete this._refs[n]);
    }
    return this;
  }
  function fi(t, e, r) {
    for (var a in e) {
      var n = e[a];
      !n.meta && (!r || r.test(a)) && (t._cache.del(n.cacheKey), delete e[a]);
    }
  }
  function hT(t, e, r, a) {
    if (typeof t != "object" && typeof t != "boolean")
      throw new Error("schema should be object or boolean");
    var n = this._opts.serialize,
      s = n ? n(t) : t,
      o = this._cache.get(s);
    if (o) return o;
    a = a || this._opts.addUsedSchema !== !1;
    var i = Un.normalizeId(this._getId(t));
    i && a && mm(this, i);
    var l = this._opts.validateSchema !== !1 && !e,
      c;
    l &&
      !(c = i && i == Un.normalizeId(t.$schema)) &&
      this.validateSchema(t, !0);
    var u = Un.ids.call(this, t),
      f = new cm({ id: i, schema: t, localRefs: u, cacheKey: s, meta: r });
    return (
      i[0] != "#" && a && (this._refs[i] = f),
      this._cache.put(s, f),
      l && c && this.validateSchema(t, !0),
      f
    );
  }
  function mT(t, e) {
    if (t.compiling)
      return (
        (t.validate = n),
        (n.schema = t.schema),
        (n.errors = null),
        (n.root = e || n),
        t.schema.$async === !0 && (n.$async = !0),
        n
      );
    t.compiling = !0;
    var r;
    t.meta && ((r = this._opts), (this._opts = this._metaOpts));
    var a;
    try {
      a = lm.call(this, t.schema, e, t.localRefs);
    } catch (s) {
      throw (delete t.validate, s);
    } finally {
      (t.compiling = !1), t.meta && (this._opts = r);
    }
    return (
      (t.validate = a),
      (t.refs = a.refs),
      (t.refVal = a.refVal),
      (t.root = a.root),
      a
    );
    function n() {
      var s = t.validate,
        o = s.apply(this, arguments);
      return (n.errors = s.errors), o;
    }
  }
  function vT(t) {
    switch (t.schemaId) {
      case "auto":
        return _T;
      case "id":
        return gT;
      default:
        return yT;
    }
  }
  function gT(t) {
    return t.$id && this.logger.warn("schema $id ignored", t.$id), t.id;
  }
  function yT(t) {
    return t.id && this.logger.warn("schema id ignored", t.id), t.$id;
  }
  function _T(t) {
    if (t.$id && t.id && t.$id != t.id)
      throw new Error("schema $id is different from id");
    return t.$id || t.id;
  }
  function wT(t, e) {
    if (((t = t || this.errors), !t)) return "No errors";
    e = e || {};
    for (
      var r = e.separator === void 0 ? ", " : e.separator,
        a = e.dataVar === void 0 ? "data" : e.dataVar,
        n = "",
        s = 0;
      s < t.length;
      s++
    ) {
      var o = t[s];
      o && (n += a + o.dataPath + " " + o.message + r);
    }
    return n.slice(0, -r.length);
  }
  function bT(t, e) {
    return (
      typeof e == "string" && (e = new RegExp(e)), (this._formats[t] = e), this
    );
  }
  function ET(t) {
    var e;
    if (
      (t._opts.$data && ((e = YP), t.addMetaSchema(e, e.$id, !0)),
      t._opts.meta !== !1)
    ) {
      var r = om;
      t._opts.$data && (r = um(r, aT)),
        t.addMetaSchema(r, di, !0),
        (t._refs["http://json-schema.org/schema"] = di);
    }
  }
  function ST(t) {
    var e = t._opts.schemas;
    if (e)
      if (Array.isArray(e)) t.addSchema(e);
      else for (var r in e) t.addSchema(e[r], r);
  }
  function $T(t) {
    for (var e in t._opts.formats) {
      var r = t._opts.formats[e];
      t.addFormat(e, r);
    }
  }
  function PT(t) {
    for (var e in t._opts.keywords) {
      var r = t._opts.keywords[e];
      t.addKeyword(e, r);
    }
  }
  function mm(t, e) {
    if (t._schemas[e] || t._refs[e])
      throw new Error('schema with key or id "' + e + '" already exists');
  }
  function TT(t) {
    for (var e = dm.copy(t._opts), r = 0; r < pm.length; r++) delete e[pm[r]];
    return e;
  }
  function xT(t) {
    var e = t._opts.logger;
    if (e === !1) t.logger = { log: fu, warn: fu, error: fu };
    else {
      if (
        (e === void 0 && (e = console),
        !(typeof e == "object" && e.log && e.warn && e.error))
      )
        throw new Error("logger must implement log, warn and error methods");
      t.logger = e;
    }
  }
  function fu() {}
  const vm = df(nT);
  class pi extends xh {
    constructor(e, r) {
      var a;
      super(r),
        (this._clientInfo = e),
        (this._cachedToolOutputValidators = new Map()),
        (this._capabilities =
          (a = r == null ? void 0 : r.capabilities) !== null && a !== void 0
            ? a
            : {}),
        (this._ajv = new vm());
    }
    registerCapabilities(e) {
      if (this.transport)
        throw new Error(
          "Cannot register capabilities after connecting to transport"
        );
      this._capabilities = Ih(this._capabilities, e);
    }
    assertCapability(e, r) {
      var a;
      if (!(!((a = this._serverCapabilities) === null || a === void 0) && a[e]))
        throw new Error(`Server does not support ${e} (required for ${r})`);
    }
    async connect(e, r) {
      if ((await super.connect(e), e.sessionId === void 0))
        try {
          const a = await this.request(
            {
              method: "initialize",
              params: {
                protocolVersion: bs,
                capabilities: this._capabilities,
                clientInfo: this._clientInfo,
              },
            },
            rh,
            r
          );
          if (a === void 0)
            throw new Error(`Server sent invalid initialize result: ${a}`);
          if (!Bp.includes(a.protocolVersion))
            throw new Error(
              `Server's protocol version is not supported: ${a.protocolVersion}`
            );
          (this._serverCapabilities = a.capabilities),
            (this._serverVersion = a.serverInfo),
            e.setProtocolVersion && e.setProtocolVersion(a.protocolVersion),
            (this._instructions = a.instructions),
            await this.notification({ method: "notifications/initialized" });
        } catch (a) {
          throw (this.close(), a);
        }
    }
    getServerCapabilities() {
      return this._serverCapabilities;
    }
    getServerVersion() {
      return this._serverVersion;
    }
    getInstructions() {
      return this._instructions;
    }
    assertCapabilityForMethod(e) {
      var r, a, n, s, o;
      switch (e) {
        case "logging/setLevel":
          if (
            !(
              !((r = this._serverCapabilities) === null || r === void 0) &&
              r.logging
            )
          )
            throw new Error(
              `Server does not support logging (required for ${e})`
            );
          break;
        case "prompts/get":
        case "prompts/list":
          if (
            !(
              !((a = this._serverCapabilities) === null || a === void 0) &&
              a.prompts
            )
          )
            throw new Error(
              `Server does not support prompts (required for ${e})`
            );
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
        case "resources/subscribe":
        case "resources/unsubscribe":
          if (
            !(
              !((n = this._serverCapabilities) === null || n === void 0) &&
              n.resources
            )
          )
            throw new Error(
              `Server does not support resources (required for ${e})`
            );
          if (
            e === "resources/subscribe" &&
            !this._serverCapabilities.resources.subscribe
          )
            throw new Error(
              `Server does not support resource subscriptions (required for ${e})`
            );
          break;
        case "tools/call":
        case "tools/list":
          if (
            !(
              !((s = this._serverCapabilities) === null || s === void 0) &&
              s.tools
            )
          )
            throw new Error(
              `Server does not support tools (required for ${e})`
            );
          break;
        case "completion/complete":
          if (
            !(
              !((o = this._serverCapabilities) === null || o === void 0) &&
              o.completions
            )
          )
            throw new Error(
              `Server does not support completions (required for ${e})`
            );
          break;
      }
    }
    assertNotificationCapability(e) {
      var r;
      switch (e) {
        case "notifications/roots/list_changed":
          if (
            !(
              !((r = this._capabilities.roots) === null || r === void 0) &&
              r.listChanged
            )
          )
            throw new Error(
              `Client does not support roots list changed notifications (required for ${e})`
            );
          break;
      }
    }
    assertRequestHandlerCapability(e) {
      switch (e) {
        case "sampling/createMessage":
          if (!this._capabilities.sampling)
            throw new Error(
              `Client does not support sampling capability (required for ${e})`
            );
          break;
        case "elicitation/create":
          if (!this._capabilities.elicitation)
            throw new Error(
              `Client does not support elicitation capability (required for ${e})`
            );
          break;
        case "roots/list":
          if (!this._capabilities.roots)
            throw new Error(
              `Client does not support roots capability (required for ${e})`
            );
          break;
      }
    }
    async ping(e) {
      return this.request({ method: "ping" }, mn, e);
    }
    async complete(e, r) {
      return this.request({ method: "completion/complete", params: e }, $h, r);
    }
    async setLoggingLevel(e, r) {
      return this.request(
        { method: "logging/setLevel", params: { level: e } },
        mn,
        r
      );
    }
    async getPrompt(e, r) {
      return this.request({ method: "prompts/get", params: e }, vh, r);
    }
    async listPrompts(e, r) {
      return this.request({ method: "prompts/list", params: e }, hh, r);
    }
    async listResources(e, r) {
      return this.request({ method: "resources/list", params: e }, ih, r);
    }
    async listResourceTemplates(e, r) {
      return this.request(
        { method: "resources/templates/list", params: e },
        lh,
        r
      );
    }
    async readResource(e, r) {
      return this.request({ method: "resources/read", params: e }, ch, r);
    }
    async subscribeResource(e, r) {
      return this.request({ method: "resources/subscribe", params: e }, mn, r);
    }
    async unsubscribeResource(e, r) {
      return this.request(
        { method: "resources/unsubscribe", params: e },
        mn,
        r
      );
    }
    async callTool(e, r = Yo, a) {
      const n = await this.request({ method: "tools/call", params: e }, r, a),
        s = this.getToolOutputValidator(e.name);
      if (s) {
        if (!n.structuredContent && !n.isError)
          throw new st(
            rt.InvalidRequest,
            `Tool ${e.name} has an output schema but did not return structured content`
          );
        if (n.structuredContent)
          try {
            if (!s(n.structuredContent))
              throw new st(
                rt.InvalidParams,
                `Structured content does not match the tool's output schema: ${this._ajv.errorsText(
                  s.errors
                )}`
              );
          } catch (o) {
            throw o instanceof st
              ? o
              : new st(
                  rt.InvalidParams,
                  `Failed to validate structured content: ${
                    o instanceof Error ? o.message : String(o)
                  }`
                );
          }
      }
      return n;
    }
    cacheToolOutputSchemas(e) {
      this._cachedToolOutputValidators.clear();
      for (const r of e)
        if (r.outputSchema)
          try {
            const a = this._ajv.compile(r.outputSchema);
            this._cachedToolOutputValidators.set(r.name, a);
          } catch {}
    }
    getToolOutputValidator(e) {
      return this._cachedToolOutputValidators.get(e);
    }
    async listTools(e, r) {
      const a = await this.request({ method: "tools/list", params: e }, yh, r);
      return this.cacheToolOutputSchemas(a.tools), a;
    }
    async sendRootsListChanged() {
      return this.notification({ method: "notifications/roots/list_changed" });
    }
  }
  class gm extends Error {
    constructor(e, r) {
      super(e),
        (this.name = "ParseError"),
        (this.type = r.type),
        (this.field = r.field),
        (this.value = r.value),
        (this.line = r.line);
    }
  }
  function pu(t) {}
  function ym(t) {
    if (typeof t == "function")
      throw new TypeError(
        "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
      );
    const {
      onEvent: e = pu,
      onError: r = pu,
      onRetry: a = pu,
      onComment: n,
    } = t;
    let s = "",
      o = !0,
      i,
      l = "",
      c = "";
    function u(g) {
      const m = o ? g.replace(/^\xEF\xBB\xBF/, "") : g,
        [h, y] = IT(`${s}${m}`);
      for (const _ of h) f(_);
      (s = y), (o = !1);
    }
    function f(g) {
      if (g === "") {
        d();
        return;
      }
      if (g.startsWith(":")) {
        n && n(g.slice(g.startsWith(": ") ? 2 : 1));
        return;
      }
      const m = g.indexOf(":");
      if (m !== -1) {
        const h = g.slice(0, m),
          y = g[m + 1] === " " ? 2 : 1,
          _ = g.slice(m + y);
        v(h, _, g);
        return;
      }
      v(g, "", g);
    }
    function v(g, m, h) {
      switch (g) {
        case "event":
          c = m;
          break;
        case "data":
          l = `${l}${m}
`;
          break;
        case "id":
          i = m.includes("\0") ? void 0 : m;
          break;
        case "retry":
          /^\d+$/.test(m)
            ? a(parseInt(m, 10))
            : r(
                new gm(`Invalid \`retry\` value: "${m}"`, {
                  type: "invalid-retry",
                  value: m,
                  line: h,
                })
              );
          break;
        default:
          r(
            new gm(
              `Unknown field "${g.length > 20 ? `${g.slice(0, 20)}…` : g}"`,
              { type: "unknown-field", field: g, value: m, line: h }
            )
          );
          break;
      }
    }
    function d() {
      l.length > 0 &&
        e({
          id: i,
          event: c || void 0,
          data: l.endsWith(`
`)
            ? l.slice(0, -1)
            : l,
        }),
        (i = void 0),
        (l = ""),
        (c = "");
    }
    function p(g = {}) {
      s && g.consume && f(s),
        (o = !0),
        (i = void 0),
        (l = ""),
        (c = ""),
        (s = "");
    }
    return { feed: u, reset: p };
  }
  function IT(t) {
    const e = [];
    let r = "",
      a = 0;
    for (; a < t.length; ) {
      const n = t.indexOf("\r", a),
        s = t.indexOf(
          `
`,
          a
        );
      let o = -1;
      if (
        (n !== -1 && s !== -1
          ? (o = Math.min(n, s))
          : n !== -1
          ? (o = n)
          : s !== -1 && (o = s),
        o === -1)
      ) {
        r = t.slice(a);
        break;
      } else {
        const i = t.slice(a, o);
        e.push(i),
          (a = o + 1),
          t[a - 1] === "\r" &&
            t[a] ===
              `
` &&
            a++;
      }
    }
    return [e, r];
  }
  class _m extends Event {
    constructor(e, r) {
      var a, n;
      super(e),
        (this.code = (a = r == null ? void 0 : r.code) != null ? a : void 0),
        (this.message =
          (n = r == null ? void 0 : r.message) != null ? n : void 0);
    }
    [Symbol.for("nodejs.util.inspect.custom")](e, r, a) {
      return a(wm(this), r);
    }
    [Symbol.for("Deno.customInspect")](e, r) {
      return e(wm(this), r);
    }
  }
  function kT(t) {
    const e = globalThis.DOMException;
    return typeof e == "function"
      ? new e(t, "SyntaxError")
      : new SyntaxError(t);
  }
  function hu(t) {
    return t instanceof Error
      ? "errors" in t && Array.isArray(t.errors)
        ? t.errors.map(hu).join(", ")
        : "cause" in t && t.cause instanceof Error
        ? `${t}: ${hu(t.cause)}`
        : t.message
      : `${t}`;
  }
  function wm(t) {
    return {
      type: t.type,
      message: t.message,
      code: t.code,
      defaultPrevented: t.defaultPrevented,
      cancelable: t.cancelable,
      timeStamp: t.timeStamp,
    };
  }
  var bm = (t) => {
      throw TypeError(t);
    },
    mu = (t, e, r) => e.has(t) || bm("Cannot " + r),
    je = (t, e, r) => (
      mu(t, e, "read from private field"), r ? r.call(t) : e.get(t)
    ),
    xt = (t, e, r) =>
      e.has(t)
        ? bm("Cannot add the same private member more than once")
        : e instanceof WeakSet
        ? e.add(t)
        : e.set(t, r),
    ct = (t, e, r, a) => (mu(t, e, "write to private field"), e.set(t, r), r),
    nn = (t, e, r) => (mu(t, e, "access private method"), r),
    Wt,
    Fn,
    $a,
    hi,
    mi,
    Ts,
    Pa,
    xs,
    _n,
    Ta,
    xa,
    Ia,
    Is,
    Er,
    vu,
    gu,
    yu,
    Em,
    _u,
    wu,
    ks,
    bu,
    Eu;
  class vi extends EventTarget {
    constructor(e, r) {
      var a, n;
      super(),
        xt(this, Er),
        (this.CONNECTING = 0),
        (this.OPEN = 1),
        (this.CLOSED = 2),
        xt(this, Wt),
        xt(this, Fn),
        xt(this, $a),
        xt(this, hi),
        xt(this, mi),
        xt(this, Ts),
        xt(this, Pa),
        xt(this, xs, null),
        xt(this, _n),
        xt(this, Ta),
        xt(this, xa, null),
        xt(this, Ia, null),
        xt(this, Is, null),
        xt(this, gu, async (s) => {
          var o;
          je(this, Ta).reset();
          const { body: i, redirected: l, status: c, headers: u } = s;
          if (c === 204) {
            nn(this, Er, ks).call(
              this,
              "Server sent HTTP 204, not reconnecting",
              204
            ),
              this.close();
            return;
          }
          if (
            (l ? ct(this, $a, new URL(s.url)) : ct(this, $a, void 0), c !== 200)
          ) {
            nn(this, Er, ks).call(this, `Non-200 status code (${c})`, c);
            return;
          }
          if (!(u.get("content-type") || "").startsWith("text/event-stream")) {
            nn(this, Er, ks).call(
              this,
              'Invalid content type, expected "text/event-stream"',
              c
            );
            return;
          }
          if (je(this, Wt) === this.CLOSED) return;
          ct(this, Wt, this.OPEN);
          const f = new Event("open");
          if (
            ((o = je(this, Is)) == null || o.call(this, f),
            this.dispatchEvent(f),
            typeof i != "object" || !i || !("getReader" in i))
          ) {
            nn(this, Er, ks).call(
              this,
              "Invalid response body, expected a web ReadableStream",
              c
            ),
              this.close();
            return;
          }
          const v = new TextDecoder(),
            d = i.getReader();
          let p = !0;
          do {
            const { done: g, value: m } = await d.read();
            m && je(this, Ta).feed(v.decode(m, { stream: !g })),
              g &&
                ((p = !1), je(this, Ta).reset(), nn(this, Er, bu).call(this));
          } while (p);
        }),
        xt(this, yu, (s) => {
          ct(this, _n, void 0),
            !(s.name === "AbortError" || s.type === "aborted") &&
              nn(this, Er, bu).call(this, hu(s));
        }),
        xt(this, _u, (s) => {
          typeof s.id == "string" && ct(this, xs, s.id);
          const o = new MessageEvent(s.event || "message", {
            data: s.data,
            origin: je(this, $a) ? je(this, $a).origin : je(this, Fn).origin,
            lastEventId: s.id || "",
          });
          je(this, Ia) &&
            (!s.event || s.event === "message") &&
            je(this, Ia).call(this, o),
            this.dispatchEvent(o);
        }),
        xt(this, wu, (s) => {
          ct(this, Ts, s);
        }),
        xt(this, Eu, () => {
          ct(this, Pa, void 0),
            je(this, Wt) === this.CONNECTING && nn(this, Er, vu).call(this);
        });
      try {
        if (e instanceof URL) ct(this, Fn, e);
        else if (typeof e == "string") ct(this, Fn, new URL(e, CT()));
        else throw new Error("Invalid URL");
      } catch {
        throw kT("An invalid or illegal string was specified");
      }
      ct(this, Ta, ym({ onEvent: je(this, _u), onRetry: je(this, wu) })),
        ct(this, Wt, this.CONNECTING),
        ct(this, Ts, 3e3),
        ct(
          this,
          mi,
          (a = r == null ? void 0 : r.fetch) != null ? a : globalThis.fetch
        ),
        ct(
          this,
          hi,
          (n = r == null ? void 0 : r.withCredentials) != null ? n : !1
        ),
        nn(this, Er, vu).call(this);
    }
    get readyState() {
      return je(this, Wt);
    }
    get url() {
      return je(this, Fn).href;
    }
    get withCredentials() {
      return je(this, hi);
    }
    get onerror() {
      return je(this, xa);
    }
    set onerror(e) {
      ct(this, xa, e);
    }
    get onmessage() {
      return je(this, Ia);
    }
    set onmessage(e) {
      ct(this, Ia, e);
    }
    get onopen() {
      return je(this, Is);
    }
    set onopen(e) {
      ct(this, Is, e);
    }
    addEventListener(e, r, a) {
      const n = r;
      super.addEventListener(e, n, a);
    }
    removeEventListener(e, r, a) {
      const n = r;
      super.removeEventListener(e, n, a);
    }
    close() {
      je(this, Pa) && clearTimeout(je(this, Pa)),
        je(this, Wt) !== this.CLOSED &&
          (je(this, _n) && je(this, _n).abort(),
          ct(this, Wt, this.CLOSED),
          ct(this, _n, void 0));
    }
  }
  (Wt = new WeakMap()),
    (Fn = new WeakMap()),
    ($a = new WeakMap()),
    (hi = new WeakMap()),
    (mi = new WeakMap()),
    (Ts = new WeakMap()),
    (Pa = new WeakMap()),
    (xs = new WeakMap()),
    (_n = new WeakMap()),
    (Ta = new WeakMap()),
    (xa = new WeakMap()),
    (Ia = new WeakMap()),
    (Is = new WeakMap()),
    (Er = new WeakSet()),
    (vu = function () {
      ct(this, Wt, this.CONNECTING),
        ct(this, _n, new AbortController()),
        je(this, mi)(je(this, Fn), nn(this, Er, Em).call(this))
          .then(je(this, gu))
          .catch(je(this, yu));
    }),
    (gu = new WeakMap()),
    (yu = new WeakMap()),
    (Em = function () {
      var t;
      const e = {
        mode: "cors",
        redirect: "follow",
        headers: {
          Accept: "text/event-stream",
          ...(je(this, xs) ? { "Last-Event-ID": je(this, xs) } : void 0),
        },
        cache: "no-store",
        signal: (t = je(this, _n)) == null ? void 0 : t.signal,
      };
      return (
        "window" in globalThis &&
          (e.credentials = this.withCredentials ? "include" : "same-origin"),
        e
      );
    }),
    (_u = new WeakMap()),
    (wu = new WeakMap()),
    (ks = function (t, e) {
      var r;
      je(this, Wt) !== this.CLOSED && ct(this, Wt, this.CLOSED);
      const a = new _m("error", { code: e, message: t });
      (r = je(this, xa)) == null || r.call(this, a), this.dispatchEvent(a);
    }),
    (bu = function (t, e) {
      var r;
      if (je(this, Wt) === this.CLOSED) return;
      ct(this, Wt, this.CONNECTING);
      const a = new _m("error", { code: e, message: t });
      (r = je(this, xa)) == null || r.call(this, a),
        this.dispatchEvent(a),
        ct(this, Pa, setTimeout(je(this, Eu), je(this, Ts)));
    }),
    (Eu = new WeakMap()),
    (vi.CONNECTING = 0),
    (vi.OPEN = 1),
    (vi.CLOSED = 2);
  function CT() {
    const t = "document" in globalThis ? globalThis.document : void 0;
    return t &&
      typeof t == "object" &&
      "baseURI" in t &&
      typeof t.baseURI == "string"
      ? t.baseURI
      : void 0;
  }
  let Su;
  Su = globalThis.crypto;
  async function RT(t) {
    return (await Su).getRandomValues(new Uint8Array(t));
  }
  async function OT(t) {
    const e =
      "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
    let r = "";
    const a = await RT(t);
    for (let n = 0; n < t; n++) {
      const s = a[n] % e.length;
      r += e[s];
    }
    return r;
  }
  async function AT(t) {
    return await OT(t);
  }
  async function NT(t) {
    const e = await (
      await Su
    ).subtle.digest("SHA-256", new TextEncoder().encode(t));
    return btoa(String.fromCharCode(...new Uint8Array(e)))
      .replace(/\//g, "_")
      .replace(/\+/g, "-")
      .replace(/=/g, "");
  }
  async function MT(t) {
    if ((t || (t = 43), t < 43 || t > 128))
      throw `Expected a length between 43 and 128. Received ${t}.`;
    const e = await AT(t),
      r = await NT(e);
    return { code_verifier: e, code_challenge: r };
  }
  const jT = re({
      resource: j().url(),
      authorization_servers: ue(j().url()).optional(),
      jwks_uri: j().url().optional(),
      scopes_supported: ue(j()).optional(),
      bearer_methods_supported: ue(j()).optional(),
      resource_signing_alg_values_supported: ue(j()).optional(),
      resource_name: j().optional(),
      resource_documentation: j().optional(),
      resource_policy_uri: j().url().optional(),
      resource_tos_uri: j().url().optional(),
      tls_client_certificate_bound_access_tokens: _t().optional(),
      authorization_details_types_supported: ue(j()).optional(),
      dpop_signing_alg_values_supported: ue(j()).optional(),
      dpop_bound_access_tokens_required: _t().optional(),
    }).passthrough(),
    Sm = re({
      issuer: j(),
      authorization_endpoint: j(),
      token_endpoint: j(),
      registration_endpoint: j().optional(),
      scopes_supported: ue(j()).optional(),
      response_types_supported: ue(j()),
      response_modes_supported: ue(j()).optional(),
      grant_types_supported: ue(j()).optional(),
      token_endpoint_auth_methods_supported: ue(j()).optional(),
      token_endpoint_auth_signing_alg_values_supported: ue(j()).optional(),
      service_documentation: j().optional(),
      revocation_endpoint: j().optional(),
      revocation_endpoint_auth_methods_supported: ue(j()).optional(),
      revocation_endpoint_auth_signing_alg_values_supported: ue(j()).optional(),
      introspection_endpoint: j().optional(),
      introspection_endpoint_auth_methods_supported: ue(j()).optional(),
      introspection_endpoint_auth_signing_alg_values_supported: ue(
        j()
      ).optional(),
      code_challenge_methods_supported: ue(j()).optional(),
    }).passthrough(),
    DT = re({
      issuer: j(),
      authorization_endpoint: j(),
      token_endpoint: j(),
      userinfo_endpoint: j().optional(),
      jwks_uri: j(),
      registration_endpoint: j().optional(),
      scopes_supported: ue(j()).optional(),
      response_types_supported: ue(j()),
      response_modes_supported: ue(j()).optional(),
      grant_types_supported: ue(j()).optional(),
      acr_values_supported: ue(j()).optional(),
      subject_types_supported: ue(j()),
      id_token_signing_alg_values_supported: ue(j()),
      id_token_encryption_alg_values_supported: ue(j()).optional(),
      id_token_encryption_enc_values_supported: ue(j()).optional(),
      userinfo_signing_alg_values_supported: ue(j()).optional(),
      userinfo_encryption_alg_values_supported: ue(j()).optional(),
      userinfo_encryption_enc_values_supported: ue(j()).optional(),
      request_object_signing_alg_values_supported: ue(j()).optional(),
      request_object_encryption_alg_values_supported: ue(j()).optional(),
      request_object_encryption_enc_values_supported: ue(j()).optional(),
      token_endpoint_auth_methods_supported: ue(j()).optional(),
      token_endpoint_auth_signing_alg_values_supported: ue(j()).optional(),
      display_values_supported: ue(j()).optional(),
      claim_types_supported: ue(j()).optional(),
      claims_supported: ue(j()).optional(),
      service_documentation: j().optional(),
      claims_locales_supported: ue(j()).optional(),
      ui_locales_supported: ue(j()).optional(),
      claims_parameter_supported: _t().optional(),
      request_parameter_supported: _t().optional(),
      request_uri_parameter_supported: _t().optional(),
      require_request_uri_registration: _t().optional(),
      op_policy_uri: j().optional(),
      op_tos_uri: j().optional(),
    })
      .passthrough()
      .merge(Sm.pick({ code_challenge_methods_supported: !0 })),
    $m = re({
      access_token: j(),
      id_token: j().optional(),
      token_type: j(),
      expires_in: St().optional(),
      scope: j().optional(),
      refresh_token: j().optional(),
    }).strip(),
    LT = re({
      error: j(),
      error_description: j().optional(),
      error_uri: j().optional(),
    }),
    zT = re({
      redirect_uris: ue(j()).refine((t) => t.every((e) => URL.canParse(e)), {
        message: "redirect_uris must contain valid URLs",
      }),
      token_endpoint_auth_method: j().optional(),
      grant_types: ue(j()).optional(),
      response_types: ue(j()).optional(),
      client_name: j().optional(),
      client_uri: j().optional(),
      logo_uri: j().optional(),
      scope: j().optional(),
      contacts: ue(j()).optional(),
      tos_uri: j().optional(),
      policy_uri: j().optional(),
      jwks_uri: j().optional(),
      jwks: Vp().optional(),
      software_id: j().optional(),
      software_version: j().optional(),
      software_statement: j().optional(),
    }).strip(),
    qT = re({
      client_id: j(),
      client_secret: j().optional(),
      client_id_issued_at: St().optional(),
      client_secret_expires_at: St().optional(),
    }).strip(),
    UT = zT.merge(qT);
  re({ error: j(), error_description: j().optional() }).strip(),
    re({ token: j(), token_type_hint: j().optional() }).strip();
  function FT(t) {
    const e = typeof t == "string" ? new URL(t) : new URL(t.href);
    return (e.hash = ""), e;
  }
  function VT({ requestedResource: t, configuredResource: e }) {
    const r = typeof t == "string" ? new URL(t) : new URL(t.href),
      a = typeof e == "string" ? new URL(e) : new URL(e.href);
    if (r.origin !== a.origin || r.pathname.length < a.pathname.length)
      return !1;
    const n = r.pathname.endsWith("/") ? r.pathname : r.pathname + "/",
      s = a.pathname.endsWith("/") ? a.pathname : a.pathname + "/";
    return n.startsWith(s);
  }
  class At extends Error {
    constructor(e, r) {
      super(e), (this.errorUri = r), (this.name = this.constructor.name);
    }
    toResponseObject() {
      const e = { error: this.errorCode, error_description: this.message };
      return this.errorUri && (e.error_uri = this.errorUri), e;
    }
    get errorCode() {
      return this.constructor.errorCode;
    }
  }
  class $u extends At {}
  $u.errorCode = "invalid_request";
  class gi extends At {}
  gi.errorCode = "invalid_client";
  class yi extends At {}
  yi.errorCode = "invalid_grant";
  class _i extends At {}
  _i.errorCode = "unauthorized_client";
  class Pu extends At {}
  Pu.errorCode = "unsupported_grant_type";
  class Tu extends At {}
  Tu.errorCode = "invalid_scope";
  class xu extends At {}
  xu.errorCode = "access_denied";
  class ka extends At {}
  ka.errorCode = "server_error";
  class Iu extends At {}
  Iu.errorCode = "temporarily_unavailable";
  class ku extends At {}
  ku.errorCode = "unsupported_response_type";
  class Cu extends At {}
  Cu.errorCode = "unsupported_token_type";
  class Ru extends At {}
  Ru.errorCode = "invalid_token";
  class Ou extends At {}
  Ou.errorCode = "method_not_allowed";
  class Au extends At {}
  Au.errorCode = "too_many_requests";
  class Nu extends At {}
  Nu.errorCode = "invalid_client_metadata";
  class Mu extends At {}
  Mu.errorCode = "insufficient_scope";
  const ZT = {
    [$u.errorCode]: $u,
    [gi.errorCode]: gi,
    [yi.errorCode]: yi,
    [_i.errorCode]: _i,
    [Pu.errorCode]: Pu,
    [Tu.errorCode]: Tu,
    [xu.errorCode]: xu,
    [ka.errorCode]: ka,
    [Iu.errorCode]: Iu,
    [ku.errorCode]: ku,
    [Cu.errorCode]: Cu,
    [Ru.errorCode]: Ru,
    [Ou.errorCode]: Ou,
    [Au.errorCode]: Au,
    [Nu.errorCode]: Nu,
    [Mu.errorCode]: Mu,
  };
  class Sr extends Error {
    constructor(e) {
      super(e ?? "Unauthorized");
    }
  }
  function Pm(t, e) {
    const r = t.client_secret !== void 0;
    return e.length === 0
      ? r
        ? "client_secret_post"
        : "none"
      : r && e.includes("client_secret_basic")
      ? "client_secret_basic"
      : r && e.includes("client_secret_post")
      ? "client_secret_post"
      : e.includes("none")
      ? "none"
      : r
      ? "client_secret_post"
      : "none";
  }
  function Tm(t, e, r, a) {
    const { client_id: n, client_secret: s } = e;
    switch (t) {
      case "client_secret_basic":
        HT(n, s, r);
        return;
      case "client_secret_post":
        BT(n, s, a);
        return;
      case "none":
        JT(n, a);
        return;
      default:
        throw new Error(`Unsupported client authentication method: ${t}`);
    }
  }
  function HT(t, e, r) {
    if (!e)
      throw new Error(
        "client_secret_basic authentication requires a client_secret"
      );
    const a = btoa(`${t}:${e}`);
    r.set("Authorization", `Basic ${a}`);
  }
  function BT(t, e, r) {
    r.set("client_id", t), e && r.set("client_secret", e);
  }
  function JT(t, e) {
    e.set("client_id", t);
  }
  async function ju(t) {
    const e = t instanceof Response ? t.status : void 0,
      r = t instanceof Response ? await t.text() : t;
    try {
      const a = LT.parse(JSON.parse(r)),
        { error: n, error_description: s, error_uri: o } = a,
        i = ZT[n] || ka;
      return new i(s || "", o);
    } catch (a) {
      const n = `${
        e ? `HTTP ${e}: ` : ""
      }Invalid OAuth error response: ${a}. Raw body: ${r}`;
      return new ka(n);
    }
  }
  async function Ca(t, e) {
    var r, a;
    try {
      return await Du(t, e);
    } catch (n) {
      if (n instanceof gi || n instanceof _i)
        return (
          await ((r = t.invalidateCredentials) === null || r === void 0
            ? void 0
            : r.call(t, "all")),
          await Du(t, e)
        );
      if (n instanceof yi)
        return (
          await ((a = t.invalidateCredentials) === null || a === void 0
            ? void 0
            : a.call(t, "tokens")),
          await Du(t, e)
        );
      throw n;
    }
  }
  async function Du(
    t,
    {
      serverUrl: e,
      authorizationCode: r,
      scope: a,
      resourceMetadataUrl: n,
      fetchFn: s,
    }
  ) {
    let o, i;
    try {
      (o = await GT(e, { resourceMetadataUrl: n }, s)),
        o.authorization_servers &&
          o.authorization_servers.length > 0 &&
          (i = o.authorization_servers[0]);
    } catch {}
    i || (i = e);
    const l = await KT(e, t, o),
      c = await ex(i, { fetchFn: s });
    let u = await Promise.resolve(t.clientInformation());
    if (!u) {
      if (r !== void 0)
        throw new Error(
          "Existing OAuth client information is required when exchanging an authorization code"
        );
      if (!t.saveClientInformation)
        throw new Error(
          "OAuth client information must be saveable for dynamic registration"
        );
      const g = await ax(i, { metadata: c, clientMetadata: t.clientMetadata });
      await t.saveClientInformation(g), (u = g);
    }
    if (r !== void 0) {
      const g = await t.codeVerifier(),
        m = await rx(i, {
          metadata: c,
          clientInformation: u,
          authorizationCode: r,
          codeVerifier: g,
          redirectUri: t.redirectUrl,
          resource: l,
          addClientAuthentication: t.addClientAuthentication,
          fetchFn: s,
        });
      return await t.saveTokens(m), "AUTHORIZED";
    }
    const f = await t.tokens();
    if (f != null && f.refresh_token)
      try {
        const g = await nx(i, {
          metadata: c,
          clientInformation: u,
          refreshToken: f.refresh_token,
          resource: l,
          addClientAuthentication: t.addClientAuthentication,
        });
        return await t.saveTokens(g), "AUTHORIZED";
      } catch (g) {
        if (!(!(g instanceof At) || g instanceof ka)) throw g;
      }
    const v = t.state ? await t.state() : void 0,
      { authorizationUrl: d, codeVerifier: p } = await tx(i, {
        metadata: c,
        clientInformation: u,
        state: v,
        redirectUrl: t.redirectUrl,
        scope: a || t.clientMetadata.scope,
        resource: l,
      });
    return (
      await t.saveCodeVerifier(p),
      await t.redirectToAuthorization(d),
      "REDIRECT"
    );
  }
  async function KT(t, e, r) {
    const a = FT(t);
    if (e.validateResourceURL)
      return await e.validateResourceURL(a, r == null ? void 0 : r.resource);
    if (r) {
      if (!VT({ requestedResource: a, configuredResource: r.resource }))
        throw new Error(
          `Protected resource ${r.resource} does not match expected ${a} (or origin)`
        );
      return new URL(r.resource);
    }
  }
  function Lu(t) {
    const e = t.headers.get("WWW-Authenticate");
    if (!e) return;
    const [r, a] = e.split(" ");
    if (r.toLowerCase() !== "bearer" || !a) return;
    const s = /resource_metadata="([^"]*)"/.exec(e);
    if (s)
      try {
        return new URL(s[1]);
      } catch {
        return;
      }
  }
  async function GT(t, e, r = fetch) {
    const a = await YT(t, "oauth-protected-resource", r, {
      protocolVersion: e == null ? void 0 : e.protocolVersion,
      metadataUrl: e == null ? void 0 : e.resourceMetadataUrl,
    });
    if (!a || a.status === 404)
      throw new Error(
        "Resource server does not implement OAuth 2.0 Protected Resource Metadata."
      );
    if (!a.ok)
      throw new Error(
        `HTTP ${a.status} trying to load well-known OAuth protected resource metadata.`
      );
    return jT.parse(await a.json());
  }
  async function zu(t, e, r = fetch) {
    try {
      return await r(t, { headers: e });
    } catch (a) {
      if (a instanceof TypeError) return e ? zu(t, void 0, r) : void 0;
      throw a;
    }
  }
  function WT(t, e = "", r = {}) {
    return (
      e.endsWith("/") && (e = e.slice(0, -1)),
      r.prependPathname ? `${e}/.well-known/${t}` : `/.well-known/${t}${e}`
    );
  }
  async function xm(t, e, r = fetch) {
    return await zu(t, { "MCP-Protocol-Version": e }, r);
  }
  function QT(t, e) {
    return !t || (t.status === 404 && e !== "/");
  }
  async function YT(t, e, r, a) {
    var n, s;
    const o = new URL(t),
      i =
        (n = a == null ? void 0 : a.protocolVersion) !== null && n !== void 0
          ? n
          : bs;
    let l;
    if (a != null && a.metadataUrl) l = new URL(a.metadataUrl);
    else {
      const u = WT(e, o.pathname);
      (l = new URL(
        u,
        (s = a == null ? void 0 : a.metadataServerUrl) !== null && s !== void 0
          ? s
          : o
      )),
        (l.search = o.search);
    }
    let c = await xm(l, i, r);
    if (!(a != null && a.metadataUrl) && QT(c, o.pathname)) {
      const u = new URL(`/.well-known/${e}`, o);
      c = await xm(u, i, r);
    }
    return c;
  }
  function XT(t) {
    const e = typeof t == "string" ? new URL(t) : t,
      r = e.pathname !== "/",
      a = [];
    if (!r)
      return (
        a.push({
          url: new URL("/.well-known/oauth-authorization-server", e.origin),
          type: "oauth",
        }),
        a.push({
          url: new URL("/.well-known/openid-configuration", e.origin),
          type: "oidc",
        }),
        a
      );
    let n = e.pathname;
    return (
      n.endsWith("/") && (n = n.slice(0, -1)),
      a.push({
        url: new URL(`/.well-known/oauth-authorization-server${n}`, e.origin),
        type: "oauth",
      }),
      a.push({
        url: new URL("/.well-known/oauth-authorization-server", e.origin),
        type: "oauth",
      }),
      a.push({
        url: new URL(`/.well-known/openid-configuration${n}`, e.origin),
        type: "oidc",
      }),
      a.push({
        url: new URL(`${n}/.well-known/openid-configuration`, e.origin),
        type: "oidc",
      }),
      a
    );
  }
  async function ex(t, { fetchFn: e = fetch, protocolVersion: r = bs } = {}) {
    var a;
    const n = { "MCP-Protocol-Version": r },
      s = XT(t);
    for (const { url: o, type: i } of s) {
      const l = await zu(o, n, e);
      if (!l)
        throw new Error(
          `CORS error trying to load ${
            i === "oauth" ? "OAuth" : "OpenID provider"
          } metadata from ${o}`
        );
      if (!l.ok) {
        if (l.status >= 400 && l.status < 500) continue;
        throw new Error(
          `HTTP ${l.status} trying to load ${
            i === "oauth" ? "OAuth" : "OpenID provider"
          } metadata from ${o}`
        );
      }
      if (i === "oauth") return Sm.parse(await l.json());
      {
        const c = DT.parse(await l.json());
        if (
          !(
            !(
              (a = c.code_challenge_methods_supported) === null || a === void 0
            ) && a.includes("S256")
          )
        )
          throw new Error(
            `Incompatible OIDC provider at ${o}: does not support S256 code challenge method required by MCP specification`
          );
        return c;
      }
    }
  }
  async function tx(
    t,
    {
      metadata: e,
      clientInformation: r,
      redirectUrl: a,
      scope: n,
      state: s,
      resource: o,
    }
  ) {
    const i = "code",
      l = "S256";
    let c;
    if (e) {
      if (
        ((c = new URL(e.authorization_endpoint)),
        !e.response_types_supported.includes(i))
      )
        throw new Error(
          `Incompatible auth server: does not support response type ${i}`
        );
      if (
        !e.code_challenge_methods_supported ||
        !e.code_challenge_methods_supported.includes(l)
      )
        throw new Error(
          `Incompatible auth server: does not support code challenge method ${l}`
        );
    } else c = new URL("/authorize", t);
    const u = await MT(),
      f = u.code_verifier,
      v = u.code_challenge;
    return (
      c.searchParams.set("response_type", i),
      c.searchParams.set("client_id", r.client_id),
      c.searchParams.set("code_challenge", v),
      c.searchParams.set("code_challenge_method", l),
      c.searchParams.set("redirect_uri", String(a)),
      s && c.searchParams.set("state", s),
      n && c.searchParams.set("scope", n),
      n != null &&
        n.includes("offline_access") &&
        c.searchParams.append("prompt", "consent"),
      o && c.searchParams.set("resource", o.href),
      { authorizationUrl: c, codeVerifier: f }
    );
  }
  async function rx(
    t,
    {
      metadata: e,
      clientInformation: r,
      authorizationCode: a,
      codeVerifier: n,
      redirectUri: s,
      resource: o,
      addClientAuthentication: i,
      fetchFn: l,
    }
  ) {
    var c;
    const u = "authorization_code",
      f =
        e != null && e.token_endpoint
          ? new URL(e.token_endpoint)
          : new URL("/token", t);
    if (
      e != null &&
      e.grant_types_supported &&
      !e.grant_types_supported.includes(u)
    )
      throw new Error(
        `Incompatible auth server: does not support grant type ${u}`
      );
    const v = new Headers({
        "Content-Type": "application/x-www-form-urlencoded",
        Accept: "application/json",
      }),
      d = new URLSearchParams({
        grant_type: u,
        code: a,
        code_verifier: n,
        redirect_uri: String(s),
      });
    if (i) i(v, d, t, e);
    else {
      const g =
          (c = e == null ? void 0 : e.token_endpoint_auth_methods_supported) !==
            null && c !== void 0
            ? c
            : [],
        m = Pm(r, g);
      Tm(m, r, v, d);
    }
    o && d.set("resource", o.href);
    const p = await (l ?? fetch)(f, { method: "POST", headers: v, body: d });
    if (!p.ok) throw await ju(p);
    return $m.parse(await p.json());
  }
  async function nx(
    t,
    {
      metadata: e,
      clientInformation: r,
      refreshToken: a,
      resource: n,
      addClientAuthentication: s,
      fetchFn: o,
    }
  ) {
    var i;
    const l = "refresh_token";
    let c;
    if (e) {
      if (
        ((c = new URL(e.token_endpoint)),
        e.grant_types_supported && !e.grant_types_supported.includes(l))
      )
        throw new Error(
          `Incompatible auth server: does not support grant type ${l}`
        );
    } else c = new URL("/token", t);
    const u = new Headers({
        "Content-Type": "application/x-www-form-urlencoded",
      }),
      f = new URLSearchParams({ grant_type: l, refresh_token: a });
    if (s) s(u, f, t, e);
    else {
      const d =
          (i = e == null ? void 0 : e.token_endpoint_auth_methods_supported) !==
            null && i !== void 0
            ? i
            : [],
        p = Pm(r, d);
      Tm(p, r, u, f);
    }
    n && f.set("resource", n.href);
    const v = await (o ?? fetch)(c, { method: "POST", headers: u, body: f });
    if (!v.ok) throw await ju(v);
    return $m.parse({ refresh_token: a, ...(await v.json()) });
  }
  async function ax(t, { metadata: e, clientMetadata: r, fetchFn: a }) {
    let n;
    if (e) {
      if (!e.registration_endpoint)
        throw new Error(
          "Incompatible auth server: does not support dynamic client registration"
        );
      n = new URL(e.registration_endpoint);
    } else n = new URL("/register", t);
    const s = await (a ?? fetch)(n, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(r),
    });
    if (!s.ok) throw await ju(s);
    return UT.parse(await s.json());
  }
  class sx extends Error {
    constructor(e, r, a) {
      super(`SSE error: ${r}`), (this.code = e), (this.event = a);
    }
  }
  class Ra {
    constructor(e, r) {
      (this._url = e),
        (this._resourceMetadataUrl = void 0),
        (this._eventSourceInit = r == null ? void 0 : r.eventSourceInit),
        (this._requestInit = r == null ? void 0 : r.requestInit),
        (this._authProvider = r == null ? void 0 : r.authProvider),
        (this._fetch = r == null ? void 0 : r.fetch);
    }
    async _authThenStart() {
      var e;
      if (!this._authProvider) throw new Sr("No auth provider");
      let r;
      try {
        r = await Ca(this._authProvider, {
          serverUrl: this._url,
          resourceMetadataUrl: this._resourceMetadataUrl,
          fetchFn: this._fetch,
        });
      } catch (a) {
        throw (
          ((e = this.onerror) === null || e === void 0 || e.call(this, a), a)
        );
      }
      if (r !== "AUTHORIZED") throw new Sr();
      return await this._startOrAuth();
    }
    async _commonHeaders() {
      var e;
      const r = {};
      if (this._authProvider) {
        const a = await this._authProvider.tokens();
        a && (r.Authorization = `Bearer ${a.access_token}`);
      }
      return (
        this._protocolVersion &&
          (r["mcp-protocol-version"] = this._protocolVersion),
        new Headers({
          ...r,
          ...((e = this._requestInit) === null || e === void 0
            ? void 0
            : e.headers),
        })
      );
    }
    _startOrAuth() {
      var e, r, a;
      const n =
        (a =
          (r =
            (e =
              this === null || this === void 0
                ? void 0
                : this._eventSourceInit) === null || e === void 0
              ? void 0
              : e.fetch) !== null && r !== void 0
            ? r
            : this._fetch) !== null && a !== void 0
          ? a
          : fetch;
      return new Promise((s, o) => {
        (this._eventSource = new vi(this._url.href, {
          ...this._eventSourceInit,
          fetch: async (i, l) => {
            const c = await this._commonHeaders();
            c.set("Accept", "text/event-stream");
            const u = await n(i, { ...l, headers: c });
            return (
              u.status === 401 &&
                u.headers.has("www-authenticate") &&
                (this._resourceMetadataUrl = Lu(u)),
              u
            );
          },
        })),
          (this._abortController = new AbortController()),
          (this._eventSource.onerror = (i) => {
            var l;
            if (i.code === 401 && this._authProvider) {
              this._authThenStart().then(s, o);
              return;
            }
            const c = new sx(i.code, i.message, i);
            o(c),
              (l = this.onerror) === null || l === void 0 || l.call(this, c);
          }),
          (this._eventSource.onopen = () => {}),
          this._eventSource.addEventListener("endpoint", (i) => {
            var l;
            const c = i;
            try {
              if (
                ((this._endpoint = new URL(c.data, this._url)),
                this._endpoint.origin !== this._url.origin)
              )
                throw new Error(
                  `Endpoint origin does not match connection origin: ${this._endpoint.origin}`
                );
            } catch (u) {
              o(u),
                (l = this.onerror) === null || l === void 0 || l.call(this, u),
                this.close();
              return;
            }
            s();
          }),
          (this._eventSource.onmessage = (i) => {
            var l, c;
            const u = i;
            let f;
            try {
              f = Ss.parse(JSON.parse(u.data));
            } catch (v) {
              (l = this.onerror) === null || l === void 0 || l.call(this, v);
              return;
            }
            (c = this.onmessage) === null || c === void 0 || c.call(this, f);
          });
      });
    }
    async start() {
      if (this._eventSource)
        throw new Error(
          "SSEClientTransport already started! If using Client class, note that connect() calls start() automatically."
        );
      return await this._startOrAuth();
    }
    async finishAuth(e) {
      if (!this._authProvider) throw new Sr("No auth provider");
      if (
        (await Ca(this._authProvider, {
          serverUrl: this._url,
          authorizationCode: e,
          resourceMetadataUrl: this._resourceMetadataUrl,
          fetchFn: this._fetch,
        })) !== "AUTHORIZED"
      )
        throw new Sr("Failed to authorize");
    }
    async close() {
      var e, r, a;
      (e = this._abortController) === null || e === void 0 || e.abort(),
        (r = this._eventSource) === null || r === void 0 || r.close(),
        (a = this.onclose) === null || a === void 0 || a.call(this);
    }
    async send(e) {
      var r, a, n;
      if (!this._endpoint) throw new Error("Not connected");
      try {
        const s = await this._commonHeaders();
        s.set("content-type", "application/json");
        const o = {
            ...this._requestInit,
            method: "POST",
            headers: s,
            body: JSON.stringify(e),
            signal:
              (r = this._abortController) === null || r === void 0
                ? void 0
                : r.signal,
          },
          i = await ((a = this._fetch) !== null && a !== void 0 ? a : fetch)(
            this._endpoint,
            o
          );
        if (!i.ok) {
          if (i.status === 401 && this._authProvider) {
            if (
              ((this._resourceMetadataUrl = Lu(i)),
              (await Ca(this._authProvider, {
                serverUrl: this._url,
                resourceMetadataUrl: this._resourceMetadataUrl,
                fetchFn: this._fetch,
              })) !== "AUTHORIZED")
            )
              throw new Sr();
            return this.send(e);
          }
          const l = await i.text().catch(() => null);
          throw new Error(`Error POSTing to endpoint (HTTP ${i.status}): ${l}`);
        }
      } catch (s) {
        throw (
          ((n = this.onerror) === null || n === void 0 || n.call(this, s), s)
        );
      }
    }
    setProtocolVersion(e) {
      this._protocolVersion = e;
    }
  }
  class wi extends TransformStream {
    constructor({ onError: e, onRetry: r, onComment: a } = {}) {
      let n;
      super({
        start(s) {
          n = ym({
            onEvent: (o) => {
              s.enqueue(o);
            },
            onError(o) {
              e === "terminate" ? s.error(o) : typeof e == "function" && e(o);
            },
            onRetry: r,
            onComment: a,
          });
        },
        transform(s) {
          n.feed(s);
        },
      });
    }
  }
  const ox = {
    initialReconnectionDelay: 1e3,
    maxReconnectionDelay: 3e4,
    reconnectionDelayGrowFactor: 1.5,
    maxRetries: 2,
  };
  class qu extends Error {
    constructor(e, r) {
      super(`Streamable HTTP error: ${r}`), (this.code = e);
    }
  }
  class Oa {
    constructor(e, r) {
      var a;
      (this._url = e),
        (this._resourceMetadataUrl = void 0),
        (this._requestInit = r == null ? void 0 : r.requestInit),
        (this._authProvider = r == null ? void 0 : r.authProvider),
        (this._fetch = r == null ? void 0 : r.fetch),
        (this._sessionId = r == null ? void 0 : r.sessionId),
        (this._reconnectionOptions =
          (a = r == null ? void 0 : r.reconnectionOptions) !== null &&
          a !== void 0
            ? a
            : ox);
    }
    async _authThenStart() {
      var e;
      if (!this._authProvider) throw new Sr("No auth provider");
      let r;
      try {
        r = await Ca(this._authProvider, {
          serverUrl: this._url,
          resourceMetadataUrl: this._resourceMetadataUrl,
          fetchFn: this._fetch,
        });
      } catch (a) {
        throw (
          ((e = this.onerror) === null || e === void 0 || e.call(this, a), a)
        );
      }
      if (r !== "AUTHORIZED") throw new Sr();
      return await this._startOrAuthSse({ resumptionToken: void 0 });
    }
    async _commonHeaders() {
      var e;
      const r = {};
      if (this._authProvider) {
        const n = await this._authProvider.tokens();
        n && (r.Authorization = `Bearer ${n.access_token}`);
      }
      this._sessionId && (r["mcp-session-id"] = this._sessionId),
        this._protocolVersion &&
          (r["mcp-protocol-version"] = this._protocolVersion);
      const a = this._normalizeHeaders(
        (e = this._requestInit) === null || e === void 0 ? void 0 : e.headers
      );
      return new Headers({ ...r, ...a });
    }
    async _startOrAuthSse(e) {
      var r, a, n;
      const { resumptionToken: s } = e;
      try {
        const o = await this._commonHeaders();
        o.set("Accept", "text/event-stream"), s && o.set("last-event-id", s);
        const i = await ((r = this._fetch) !== null && r !== void 0
          ? r
          : fetch)(this._url, {
          method: "GET",
          headers: o,
          signal:
            (a = this._abortController) === null || a === void 0
              ? void 0
              : a.signal,
        });
        if (!i.ok) {
          if (i.status === 401 && this._authProvider)
            return await this._authThenStart();
          if (i.status === 405) return;
          throw new qu(i.status, `Failed to open SSE stream: ${i.statusText}`);
        }
        this._handleSseStream(i.body, e, !0);
      } catch (o) {
        throw (
          ((n = this.onerror) === null || n === void 0 || n.call(this, o), o)
        );
      }
    }
    _getNextReconnectionDelay(e) {
      const r = this._reconnectionOptions.initialReconnectionDelay,
        a = this._reconnectionOptions.reconnectionDelayGrowFactor,
        n = this._reconnectionOptions.maxReconnectionDelay;
      return Math.min(r * Math.pow(a, e), n);
    }
    _normalizeHeaders(e) {
      return e
        ? e instanceof Headers
          ? Object.fromEntries(e.entries())
          : Array.isArray(e)
          ? Object.fromEntries(e)
          : { ...e }
        : {};
    }
    _scheduleReconnection(e, r = 0) {
      var a;
      const n = this._reconnectionOptions.maxRetries;
      if (n > 0 && r >= n) {
        (a = this.onerror) === null ||
          a === void 0 ||
          a.call(
            this,
            new Error(`Maximum reconnection attempts (${n}) exceeded.`)
          );
        return;
      }
      const s = this._getNextReconnectionDelay(r);
      setTimeout(() => {
        this._startOrAuthSse(e).catch((o) => {
          var i;
          (i = this.onerror) === null ||
            i === void 0 ||
            i.call(
              this,
              new Error(
                `Failed to reconnect SSE stream: ${
                  o instanceof Error ? o.message : String(o)
                }`
              )
            ),
            this._scheduleReconnection(e, r + 1);
        });
      }, s);
    }
    _handleSseStream(e, r, a) {
      if (!e) return;
      const { onresumptiontoken: n, replayMessageId: s } = r;
      let o;
      (async () => {
        var l, c, u, f;
        try {
          const v = e
            .pipeThrough(new TextDecoderStream())
            .pipeThrough(new wi())
            .getReader();
          for (;;) {
            const { value: d, done: p } = await v.read();
            if (p) break;
            if (
              (d.id && ((o = d.id), n == null || n(d.id)),
              !d.event || d.event === "message")
            )
              try {
                const g = Ss.parse(JSON.parse(d.data));
                s !== void 0 && Ic(g) && (g.id = s),
                  (l = this.onmessage) === null ||
                    l === void 0 ||
                    l.call(this, g);
              } catch (g) {
                (c = this.onerror) === null || c === void 0 || c.call(this, g);
              }
          }
        } catch (v) {
          if (
            ((u = this.onerror) === null ||
              u === void 0 ||
              u.call(this, new Error(`SSE stream disconnected: ${v}`)),
            a && this._abortController && !this._abortController.signal.aborted)
          )
            try {
              this._scheduleReconnection(
                {
                  resumptionToken: o,
                  onresumptiontoken: n,
                  replayMessageId: s,
                },
                0
              );
            } catch (d) {
              (f = this.onerror) === null ||
                f === void 0 ||
                f.call(
                  this,
                  new Error(
                    `Failed to reconnect: ${
                      d instanceof Error ? d.message : String(d)
                    }`
                  )
                );
            }
        }
      })();
    }
    async start() {
      if (this._abortController)
        throw new Error(
          "StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically."
        );
      this._abortController = new AbortController();
    }
    async finishAuth(e) {
      if (!this._authProvider) throw new Sr("No auth provider");
      if (
        (await Ca(this._authProvider, {
          serverUrl: this._url,
          authorizationCode: e,
          resourceMetadataUrl: this._resourceMetadataUrl,
          fetchFn: this._fetch,
        })) !== "AUTHORIZED"
      )
        throw new Sr("Failed to authorize");
    }
    async close() {
      var e, r;
      (e = this._abortController) === null || e === void 0 || e.abort(),
        (r = this.onclose) === null || r === void 0 || r.call(this);
    }
    async send(e, r) {
      var a, n, s, o;
      try {
        const { resumptionToken: i, onresumptiontoken: l } = r || {};
        if (i) {
          this._startOrAuthSse({
            resumptionToken: i,
            replayMessageId: Wp(e) ? e.id : void 0,
          }).catch((m) => {
            var h;
            return (h = this.onerror) === null || h === void 0
              ? void 0
              : h.call(this, m);
          });
          return;
        }
        const c = await this._commonHeaders();
        c.set("content-type", "application/json"),
          c.set("accept", "application/json, text/event-stream");
        const u = {
            ...this._requestInit,
            method: "POST",
            headers: c,
            body: JSON.stringify(e),
            signal:
              (a = this._abortController) === null || a === void 0
                ? void 0
                : a.signal,
          },
          f = await ((n = this._fetch) !== null && n !== void 0 ? n : fetch)(
            this._url,
            u
          ),
          v = f.headers.get("mcp-session-id");
        if ((v && (this._sessionId = v), !f.ok)) {
          if (f.status === 401 && this._authProvider) {
            if (
              ((this._resourceMetadataUrl = Lu(f)),
              (await Ca(this._authProvider, {
                serverUrl: this._url,
                resourceMetadataUrl: this._resourceMetadataUrl,
                fetchFn: this._fetch,
              })) !== "AUTHORIZED")
            )
              throw new Sr();
            return this.send(e);
          }
          const m = await f.text().catch(() => null);
          throw new Error(`Error POSTing to endpoint (HTTP ${f.status}): ${m}`);
        }
        if (f.status === 202) {
          WS(e) &&
            this._startOrAuthSse({ resumptionToken: void 0 }).catch((m) => {
              var h;
              return (h = this.onerror) === null || h === void 0
                ? void 0
                : h.call(this, m);
            });
          return;
        }
        const p =
            (Array.isArray(e) ? e : [e]).filter(
              (m) => "method" in m && "id" in m && m.id !== void 0
            ).length > 0,
          g = f.headers.get("content-type");
        if (p)
          if (g != null && g.includes("text/event-stream"))
            this._handleSseStream(f.body, { onresumptiontoken: l }, !1);
          else if (g != null && g.includes("application/json")) {
            const m = await f.json(),
              h = Array.isArray(m) ? m.map((y) => Ss.parse(y)) : [Ss.parse(m)];
            for (const y of h)
              (s = this.onmessage) === null || s === void 0 || s.call(this, y);
          } else throw new qu(-1, `Unexpected content type: ${g}`);
      } catch (i) {
        throw (
          ((o = this.onerror) === null || o === void 0 || o.call(this, i), i)
        );
      }
    }
    get sessionId() {
      return this._sessionId;
    }
    async terminateSession() {
      var e, r, a;
      if (this._sessionId)
        try {
          const n = await this._commonHeaders(),
            s = {
              ...this._requestInit,
              method: "DELETE",
              headers: n,
              signal:
                (e = this._abortController) === null || e === void 0
                  ? void 0
                  : e.signal,
            },
            o = await ((r = this._fetch) !== null && r !== void 0 ? r : fetch)(
              this._url,
              s
            );
          if (!o.ok && o.status !== 405)
            throw new qu(
              o.status,
              `Failed to terminate session: ${o.statusText}`
            );
          this._sessionId = void 0;
        } catch (n) {
          throw (
            ((a = this.onerror) === null || a === void 0 || a.call(this, n), n)
          );
        }
    }
    setProtocolVersion(e) {
      this._protocolVersion = e;
    }
    get protocolVersion() {
      return this._protocolVersion;
    }
  }
  const Uu = kt;
  (function (t, e) {
    const r = kt,
      a = kt,
      n = t();
    for (;;)
      try {
        if (
          (parseInt(r(145)) / 1) * (-parseInt(a(169)) / 2) +
            (-parseInt(r(143)) / 3) * (-parseInt(r(176)) / 4) +
            (-parseInt(r(134)) / 5) * (-parseInt(a(154)) / 6) +
            (-parseInt(r(160)) / 7) * (-parseInt(a(170)) / 8) +
            parseInt(r(133)) / 9 +
            (parseInt(r(163)) / 10) * (parseInt(a(165)) / 11) +
            -parseInt(r(161)) / 12 ===
          e
        )
          break;
        n.push(n.shift());
      } catch {
        n.push(n.shift());
      }
  })(Ei, -1617767 + 7318 * 202 + 963472);
  function kt(t, e) {
    const r = Ei();
    return (
      (kt = function (a, n) {
        return (a = a - 129), r[a];
      }),
      kt(t, e)
    );
  }
  const Im = () => {
      const t = kt,
        e = kt,
        r = {
          SUplI: function (a, n) {
            return a !== n;
          },
          gdsVr: t(173),
          fDJxn: function (a, n) {
            return a !== n;
          },
          FzgVC: function (a, n) {
            return a(n);
          },
          RphJy: "return this",
        };
      return r[t(139)](typeof globalThis, r[e(164)])
        ? globalThis
        : r[t(139)](typeof window, "undefined")
        ? window
        : r[t(172)](typeof global, r.gdsVr)
        ? global
        : typeof self !== r.gdsVr
        ? self
        : r[t(156)](Function, r[e(155)])();
    },
    ix = (t, e, r) => {
      const a = kt,
        n = kt,
        s = {};
      (s.BODwV = function (i, l) {
        return i !== l;
      }),
        (s.axlRk = "undefined"),
        (s.WGYMl = function (i, l) {
          return i in l;
        }),
        (s[a(162)] = n(131)),
        (s[n(142)] = function (i, l) {
          return i === l;
        }),
        (s[n(159)] = a(166));
      const o = s;
      o[n(147)](typeof window, o.axlRk)
        ? t.postMessage(e, "*", r)
        : o.WGYMl(o[a(162)], t) &&
          o[a(142)](typeof t[a(131)], o.LnNVQ) &&
          t.postMessage(e, r);
    },
    lx = (t, e) => {
      const r = kt,
        a = kt,
        n = {};
      (n.tblHl = r(152)),
        (n.CQBXk = function (o, i) {
          return o === i;
        }),
        (n.rzcdo = a(166)),
        (n[a(140)] = function (o, i) {
          return o in i;
        }),
        (n[r(157)] = "onmessage"),
        (n.jnGTR = function (o, i) {
          return o !== i;
        }),
        (n.xkAIW = "undefined");
      const s = n;
      s.tblHl in t && s.CQBXk(typeof t[a(152)], s.rzcdo)
        ? t[a(152)]("message", e)
        : s.SjhYv(s[a(157)], t) &&
          s[a(158)](typeof t.onmessage, s.xkAIW) &&
          (t[a(130)] = e);
    };
  class bi {
    constructor(e) {
      this._port = e;
    }
    async start() {
      const e = kt;
      this._port &&
        ((this[e(138)].onmessage = (r) => {
          var a, n;
          const s = e;
          try {
            const o = Ss.parse(r[s(135)].message);
            (a = this.onmessage) == null || a.call(this, o, r[s(135)].extra);
          } catch (o) {
            const i = new Error("MessageChannel failed to parse message: " + o);
            (n = this.onerror) == null || n.call(this, i);
          }
        }),
        (this._port.onmessageerror = (r) => {
          var a;
          const n = new Error(
            "MessageChannel transport error: " + JSON.stringify(r)
          );
          (a = this.onerror) == null || a.call(this, n);
        }),
        this[e(138)][e(153)]());
    }
    async send(e, r) {
      const a = {
        OXUfv: function (n) {
          return n();
        },
        HGTbd: function (n, s) {
          return n(s);
        },
        Pfhxv: function (n, s) {
          return n(s);
        },
      };
      return new Promise((n, s) => {
        var o;
        const i = kt,
          l = kt;
        try {
          const c = {};
          c.authInfo = r == null ? void 0 : r[i(132)];
          const u = {};
          (u[l(148)] = e),
            (u[i(141)] = c),
            this[i(138)] && this[l(138)].postMessage(u),
            a[l(144)](n);
        } catch (c) {
          const u = c instanceof Error ? c : new Error(a.HGTbd(String, c));
          (o = this[i(137)]) == null || o.call(this, u), a[i(151)](s, u);
        }
      });
    }
    async close() {
      var e, r;
      const a = kt,
        n = kt;
      (e = this._port) == null || e[a(129)](),
        (this[n(138)] = void 0),
        (r = this.onclose) == null || r.call(this);
    }
  }
  function Ei() {
    const t = [
      "start",
      "18osCtKg",
      "RphJy",
      "FzgVC",
      "MJJde",
      "jnGTR",
      "LnNVQ",
      "1051519VVnrnU",
      "33477396wnvbno",
      "sxstg",
      "5032460FukhmU",
      "gdsVr",
      "11iMeJBh",
      "function",
      "_endpoint",
      "_listen",
      "1275704COqcWf",
      "56LfVOEz",
      "listen",
      "fDJxn",
      "undefined",
      "ports",
      "JlLHy",
      "4dKwrPa",
      "close",
      "onmessage",
      "postMessage",
      "authInfo",
      "11129553jiEKRY",
      "776455JhRkBm",
      "data",
      "port2",
      "onerror",
      "_port",
      "SUplI",
      "SjhYv",
      "extra",
      "cgHZW",
      "2982963YuFHfk",
      "OXUfv",
      "1sYviCF",
      "port1",
      "BODwV",
      "message",
      "ZJoRh",
      "_globalObject",
      "Pfhxv",
      "addEventListener",
    ];
    return (
      (Ei = function () {
        return t;
      }),
      Ei()
    );
  }
  class Fu extends bi {
    constructor(e, r = Im()) {
      const a = kt,
        n = {
          JlLHy: function (o, i, l, c) {
            return o(i, l, c);
          },
        };
      super(), (this[a(167)] = e), (this[a(150)] = r);
      const s = new MessageChannel();
      (this._port = s.port1),
        n[a(175)](ix, this._globalObject, { endpoint: this._endpoint }, [
          s.port2,
        ]);
    }
  }
  class Vu extends bi {
    constructor(e, r = Im()) {
      const a = kt,
        n = {
          vqpjH: function (s, o) {
            return s === o;
          },
          iWjpS: function (s) {
            return s();
          },
          ZJoRh: function (s, o, i) {
            return s(o, i);
          },
        };
      super(),
        (this._endpoint = e),
        (this[a(150)] = r),
        (this._listen = new Promise((s) => {
          const o = a;
          n[o(149)](lx, this[o(150)], (i) => {
            const l = o;
            i.data &&
              n.vqpjH(i.data.endpoint, this._endpoint) &&
              ((this[l(138)] = i[l(174)][-9452 + -4726 * -2]), n.iWjpS(s));
          });
        }));
    }
    async [Uu(171)]() {
      return this[Uu(168)];
    }
  }
  const cx = () => {
    const t = Uu,
      e = new MessageChannel();
    return [new bi(e[t(146)]), new bi(e[t(136)])];
  };
  (function (t, e) {
    const r = Ye,
      a = Ye,
      n = t();
    for (;;)
      try {
        if (
          -parseInt(r(415)) / 1 +
            (-parseInt(a(357)) / 2) * (parseInt(r(368)) / 3) +
            -parseInt(a(408)) / 4 +
            parseInt(r(371)) / 5 +
            (-parseInt(a(429)) / 6) * (-parseInt(r(412)) / 7) +
            (parseInt(r(407)) / 8) * (parseInt(r(423)) / 9) +
            -parseInt(r(375)) / 10 ===
          e
        )
          break;
        n.push(n.shift());
      } catch {
        n.push(n.shift());
      }
  })(Si, -7527 * 130 + 350160 + 1329539);
  const ux = async (t, e, r) => {
      var a;
      const n = Ye,
        s = Ye,
        o = {};
      (o.PgGRq = "tools/call"),
        (o[n(354)] = n(387)),
        (o[s(369)] = n(364)),
        (o[s(394)] = s(426)),
        (o[n(406)] = "ping"),
        (o.BWglk = n(360)),
        (o[s(409)] = "logging/setLevel"),
        (o.YTglM = s(399));
      const i = o,
        { id: l, method: c, params: u } = r;
      let f = {};
      switch (c) {
        case "tools/list":
          f = await e.listTools(u);
          break;
        case i.PgGRq:
          f = await e.callTool(u);
          break;
        case n(390):
          f = await e.listResources(u);
          break;
        case i[n(354)]:
          f = await e[n(382)](u);
          break;
        case "resources/read":
          f = await e[n(376)](u);
          break;
        case i.INhFO:
          f = await e[s(418)](u);
          break;
        case "resources/unsubscribe":
          f = await e[n(393)](u);
          break;
        case "prompts/get":
          f = await e.getPrompt(u);
          break;
        case i[s(394)]:
          f = await e[n(422)](u);
          break;
        case i[s(406)]:
          f = await e.ping();
          break;
        case i.BWglk:
          f = await e.complete(u);
          break;
        case i.exSlO:
          f = await e.setLoggingLevel(u == null ? void 0 : u[s(355)]);
          break;
      }
      const v = {};
      (v.result = f),
        (v[s(374)] = i[s(361)]),
        (v.id = l),
        await ((a = t == null ? void 0 : t.transport) == null
          ? void 0
          : a.send(v));
    },
    dx = async (t, e, r) => {
      var a;
      const n = Ye,
        s = Ye,
        o = {};
      (o.mKgNI = "roots/list"),
        (o[n(391)] = n(380)),
        (o.BUcjm = "ping"),
        (o[s(367)] = "2.0");
      const i = o,
        { id: l, method: c, params: u } = r;
      let f = {};
      switch (c) {
        case i[s(397)]:
          const d = {};
          (d.method = c), (d[s(395)] = u), (f = await e[s(377)](d, Jc));
          break;
        case "sampling/createMessage":
          const p = {};
          (p[n(365)] = c), (p[n(395)] = u), (f = await e[s(377)](p, Zc));
          break;
        case i.HHuTf:
          const g = {};
          (g.method = c), (g.params = u), (f = await e.request(g, Hc));
          break;
        case i.BUcjm:
          const m = {};
          (m.method = c), (f = await e.request(m, mn));
          break;
      }
      const v = {};
      return (
        (v[s(401)] = f),
        (v.jsonrpc = i[n(367)]),
        (v.id = l),
        await ((a = t == null ? void 0 : t.transport) == null
          ? void 0
          : a[n(388)](v)),
        f
      );
    },
    fx = (t, e) => {
      const r = Ye,
        a = Ye,
        n = {
          lfNNa: function (o, i, l, c) {
            return o(i, l, c);
          },
          ERLmZ: r(399),
        },
        s = t[a(362)];
      t._onrequest = async (o, i) => {
        var l, c, u, f, v;
        const d = a,
          p = r,
          { id: g, method: m } = o;
        try {
          m === d(398)
            ? await s[p(428)](t, o, i)
            : await n[p(425)](ux, t, e, o);
        } catch (h) {
          const { code: y, message: _, data: w } = h;
          try {
            if (y) {
              const E = {};
              (E.code = y), (E.message = _), (E.data = w);
              const P = {};
              (P.error = E),
                (P.jsonrpc = n[p(370)]),
                (P.id = g),
                await ((l = t == null ? void 0 : t[p(381)]) == null
                  ? void 0
                  : l.send(P));
            } else
              (u =
                (c = t == null ? void 0 : t[d(381)]) == null
                  ? void 0
                  : c.onerror) == null || u.call(c, h);
          } catch (E) {
            (v =
              (f = t == null ? void 0 : t[d(381)]) == null
                ? void 0
                : f.onerror) == null || v.call(f, E);
          }
        }
      };
    },
    px = (t, e) => {
      const r = Ye,
        a = Ye,
        n = {};
      (n.HMnPG = function (o, i) {
        return o !== i;
      }),
        (n[r(402)] = r(404)),
        (n.FwMpF = "notifications/cancelled");
      const s = n;
      t[r(403)] = async (o) => {
        var i, l;
        const c = a,
          u = r,
          { method: f, params: v } = o;
        if (
          s.HMnPG(f, s[c(402)]) &&
          (s[c(396)](f, s.FwMpF) || (v != null && v[u(359)]))
        )
          try {
            await e.notification(o);
          } catch (d) {
            (l =
              (i = t == null ? void 0 : t.transport) == null
                ? void 0
                : i.onerror) == null || l.call(i, d);
          }
      };
    },
    hx = (t, e) => async (r) => {
      var a, n, s, o, i;
      const l = Ye,
        c = Ye,
        u = {
          SAxlc: function (f, v, d, p) {
            return f(v, d, p);
          },
          dFopk: "2.0",
        };
      try {
        return await u[l(383)](dx, t, e, r);
      } catch (f) {
        const { code: v, message: d, data: p } = f;
        try {
          if (v) {
            const g = {};
            (g[c(427)] = v), (g[l(358)] = d), (g[c(353)] = p);
            const m = {};
            (m[l(392)] = g),
              (m.jsonrpc = u[l(421)]),
              (m.id = r.id),
              await ((a = t == null ? void 0 : t.transport) == null
                ? void 0
                : a.send(m));
          } else
            (s =
              (n = t == null ? void 0 : t[c(381)]) == null
                ? void 0
                : n.onerror) == null || s.call(n, f);
        } catch (g) {
          (i =
            (o = t == null ? void 0 : t[l(381)]) == null
              ? void 0
              : o.onerror) == null || i.call(o, g);
        }
      }
    };
  function Si() {
    const t = [
      "level",
      "originalOnResponse",
      "55170mBdYDU",
      "message",
      "forward",
      "completion/complete",
      "YTglM",
      "_onrequest",
      "push",
      "resources/subscribe",
      "method",
      "evRYg",
      "IwJLf",
      "36vWOzfl",
      "INhFO",
      "ERLmZ",
      "4771400ICkNjz",
      "removeListener",
      "bepKH",
      "jsonrpc",
      "1588030zEKxZA",
      "readResource",
      "request",
      "indexOf",
      "_onresponse",
      "elicitation/create",
      "transport",
      "listResourceTemplates",
      "SAxlc",
      "TivTb",
      "VvMvg",
      "lKSxx",
      "resources/templates/list",
      "send",
      "removeRequestListener",
      "resources/list",
      "HHuTf",
      "error",
      "unsubscribeResource",
      "JgvOQ",
      "params",
      "HMnPG",
      "mKgNI",
      "initialize",
      "2.0",
      "clearListener",
      "result",
      "xAZkD",
      "_onnotification",
      "notifications/initialized",
      "DNAeN",
      "deQam",
      "18856juHcqp",
      "1408312pVrTzy",
      "exSlO",
      "_notificationHandlers",
      "fallbackRequestHandler",
      "1770391vhkQKM",
      "clear",
      "length",
      "917098eoebuK",
      "onerror",
      "eBAUu",
      "subscribeResource",
      "get",
      "clearRequestListener",
      "dFopk",
      "listPrompts",
      "2853mVPrjm",
      "addNotificationListener",
      "lfNNa",
      "prompts/list",
      "code",
      "call",
      "18wkYBws",
      "addResponseListener",
      "data",
      "RZSpk",
    ];
    return (
      (Si = function () {
        return t;
      }),
      Si()
    );
  }
  const mx = (t, e) => async (r) => {
    var a, n, s;
    const o = Ye,
      i = Ye,
      l = {};
    (l[o(384)] = function (v, d) {
      return v !== d;
    }),
      (l.HBVzz = "notifications/cancelled"),
      (l.bepKH = "2.0");
    const c = l,
      { method: u, params: f } = r;
    if (
      c.TivTb(u, "notifications/initialized") &&
      (u !== c.HBVzz || (f != null && f[i(359)]))
    )
      try {
        const v = { ...r };
        (v[o(374)] = c[i(373)]),
          await ((a = e == null ? void 0 : e.transport) == null
            ? void 0
            : a[i(388)](v));
      } catch (v) {
        (s =
          (n = t == null ? void 0 : t.transport) == null
            ? void 0
            : n.onerror) == null || s.call(n, v);
      }
  };
  function Ye(t, e) {
    const r = Si();
    return (
      (Ye = function (a, n) {
        return (a = a - (14 * -396 + -8764 + -2932 * -5)), r[a];
      }),
      Ye(t, e)
    );
  }
  const vx = (t, e) => async (r) => {
      var a, n, s, o, i, l;
      const c = Ye,
        u = Ye,
        f = {};
      f.lCWNU = "2.0";
      const v = f;
      try {
        await ((a = e == null ? void 0 : e.transport) == null
          ? void 0
          : a.send(r));
      } catch (d) {
        const { code: p, message: g, data: m } = d;
        try {
          if (p) {
            const h = {};
            (h.code = p), (h[c(358)] = g), (h[c(353)] = m);
            const y = {};
            (y.error = h),
              (y.jsonrpc = v.lCWNU),
              (y.id = r.id),
              await ((n = t == null ? void 0 : t[c(381)]) == null
                ? void 0
                : n[u(388)](y));
          } else
            (o =
              (s = t == null ? void 0 : t.transport) == null
                ? void 0
                : s.onerror) == null || o.call(s, d);
        } catch (h) {
          (l =
            (i = t == null ? void 0 : t[c(381)]) == null
              ? void 0
              : i[c(416)]) == null || l.call(i, h);
        }
      }
    },
    Zu = () => {
      const t = Ye,
        e = {
          ppppd: function (l, c) {
            return l !== c;
          },
          VvMvg: function (l, c) {
            return l(c);
          },
          kyvea: function (l, c) {
            return l === c;
          },
          Finqx: "function",
          DNAeN: function (l, c) {
            return l !== c;
          },
        },
        r = [],
        a = (l, c) => {
          const u = Ye;
          if (c) {
            const f = [];
            for (const v of r)
              try {
                f[u(363)](v(l, c));
              } catch {}
            for (const v of f) if (e.ppppd(v, null)) return v;
          } else
            for (const f of r)
              try {
                e[u(385)](f, l);
              } catch {}
        },
        n = (l) => {
          const c = Ye;
          e.kyvea(typeof l, e.Finqx) && !r.includes(l) && r[c(363)](l);
        },
        s = (l) => {
          const c = Ye,
            u = r[c(378)](l);
          e[c(405)](u, -1) && r.splice(u, -9316 + -82 * 53 + -1 * -13663);
        },
        o = () => {
          const l = Ye;
          r[l(414)] = -1 * -9084 + -3251 * -1 + 12335 * -1;
        },
        i = {};
      return (
        (i.handleListener = a),
        (i.addListener = n),
        (i[t(372)] = s),
        (i[t(400)] = o),
        i
      );
    },
    gx = (t) => {
      const e = Ye,
        r = Ye,
        a = {
          nsbwy: function (n) {
            return n();
          },
          evRYg: function (n) {
            return n();
          },
          SwOnF: function (n) {
            return n();
          },
        };
      {
        const {
          handleListener: n,
          addListener: s,
          removeListener: o,
          clearListener: i,
        } = a.nsbwy(Zu);
        (t._onresponse = n),
          (t[e(352)] = s),
          (t.removeResponseListener = o),
          (t.clearResponseListener = i);
      }
      {
        const {
          handleListener: n,
          addListener: s,
          removeListener: o,
          clearListener: i,
        } = a[r(366)](Zu);
        (t[e(411)] = n),
          (t.addRequestListener = s),
          (t[e(389)] = o),
          (t[r(420)] = i);
      }
      {
        const {
          handleListener: n,
          addListener: s,
          removeListener: o,
          clearListener: i,
        } = a.SwOnF(Zu);
        (t.fallbackNotificationHandler = n),
          (t.addNotificationListener = s),
          (t.removeNotificationListener = o),
          (t.clearNotificationListener = i);
      }
    },
    yx = (t, { beforeInit: e, afterInit: r } = {}) => {
      const a = Ye,
        n = Ye,
        s = {
          eBAUu: "function",
          uldJU: function (i, l) {
            return i(l);
          },
          nOioM: function (i, l) {
            return i === l;
          },
          mYMiK: function (i) {
            return i();
          },
          lKSxx: function (i) {
            return i();
          },
        },
        o = new Map(t._notificationHandlers);
      t._requestHandlers[a(413)](),
        t[n(410)][a(413)](),
        s.nOioM(typeof e, s.eBAUu) && s.mYMiK(e),
        t._onresponse.name === n(379) && (t[n(356)] = t._onresponse),
        gx(t),
        t[n(352)]((i) => {
          t[a(356)].call(t, i);
        }),
        s.nOioM(typeof r, s[n(417)]) && s[a(386)](r),
        t[n(424)]((i) => {
          const l = a,
            { method: c } = i,
            u = o[l(419)](c);
          typeof u === s.eBAUu && s.uldJU(u, i);
        });
    },
    _x = an;
  function an(t, e) {
    const r = $i();
    return (
      (an = function (a, n) {
        return (a = a - (-499 * 3 + 1 * -890 + -337 * -8)), r[a];
      }),
      an(t, e)
    );
  }
  (function (t, e) {
    const r = an,
      a = an,
      n = t();
    for (;;)
      try {
        if (
          (parseInt(r(315)) / 1) * (-parseInt(r(316)) / 2) +
            (parseInt(r(319)) / 3) * (-parseInt(r(320)) / 4) +
            -parseInt(a(324)) / 5 +
            (parseInt(r(327)) / 6) * (-parseInt(a(323)) / 7) +
            parseInt(a(312)) / 8 +
            -parseInt(r(310)) / 9 +
            (parseInt(r(325)) / 10) * (parseInt(r(322)) / 11) ===
          e
        )
          break;
        n.push(n.shift());
      } catch {
        n.push(n.shift());
      }
  })($i, 815846 + -859697 * 1 + 650566);
  const wx = () => {
      const t = an,
        e = an,
        r = {};
      (r[t(317)] = function (n, s) {
        return n & s;
      }),
        (r[e(326)] = function (n, s) {
          return n | s;
        }),
        (r.CJbSq = function (n, s) {
          return n & s;
        }),
        (r[e(313)] = function (n, s) {
          return n === s;
        }),
        (r.aiAIs = e(309));
      const a = r;
      return a[t(313)](typeof crypto, a.aiAIs) && crypto[t(314)]
        ? crypto.randomUUID()
        : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (n) => {
            const s = t,
              o = t,
              i = a[s(317)](
                crypto[o(321)](new Uint8Array(-8718 + 124 * 25 + 5619))[
                  -6393 + -329 * -4 + 1 * 5077
                ],
                222 * -2 + -5419 * -1 + -496 * 10
              );
            return (
              n === "x"
                ? i
                : a.koxtC(a.CJbSq(i, 1510 + 1 * -1507), 737 * -3 + -3740 + 5959)
            ).toString(16);
          });
    },
    bx = (t) => {
      const e = an,
        r = an,
        a = new Uint8Array(t);
      return (
        crypto[e(321)](a),
        Array[e(311)](a, (n) =>
          n.toString(-9830 * 1 + 15 * -389 + 15681).padStart(2, "0")
        )[r(328)]("")
      );
    },
    Vn = {};
  function $i() {
    const t = [
      "322602YEeXTL",
      "cWMWo",
      "randomBytes",
      "360714cQwoni",
      "4jGlyZR",
      "getRandomValues",
      "11vuSHLa",
      "7coyLYd",
      "576200ZDqfSL",
      "25441610RPtFTZ",
      "koxtC",
      "4124070gqAgCl",
      "join",
      "object",
      "8383374JYLMHO",
      "from",
      "4496536egULKP",
      "bXzKK",
      "randomUUID",
      "4ZgaCxq",
    ];
    return (
      ($i = function () {
        return t;
      }),
      $i()
    );
  }
  (Vn.randomUUID = wx), (Vn[_x(318)] = bx);
  const Cs = qr,
    wn = qr;
  (function (t, e) {
    const r = qr,
      a = qr,
      n = t();
    for (;;)
      try {
        if (
          -parseInt(r(202)) / 1 +
            -parseInt(a(206)) / 2 +
            -parseInt(a(205)) / 3 +
            parseInt(r(176)) / 4 +
            -parseInt(a(180)) / 5 +
            -parseInt(a(194)) / 6 +
            parseInt(r(188)) / 7 ===
          e
        )
          break;
        n.push(n.shift());
      } catch {
        n.push(n.shift());
      }
  })(Pi, 112621 * 2 + -1 * -1870746 + -1103066);
  function Pi() {
    const t = [
      "function",
      "JPlVw",
      "removeRequestListener",
      "authProvider",
      "1.0.0",
      "rmzgk",
      "ZXEHq",
      "KmDTz",
      "oHJBZ",
      "TIBus",
      "credentials",
      "197184QVZkrq",
      "removeResponseListener",
      "set",
      "searchParams",
      "9184715GDLahr",
      "version",
      "listChanged",
      "KaUfV",
      "include",
      "Authorization",
      "afterInit",
      "entries",
      "50977584KLIJFM",
      "sampling",
      "capabilities",
      "randomUUID",
      "close",
      "requestInit",
      "1757244qRFdUY",
      "headers",
      "transport",
      "mcp-sse-proxy-client",
      "sessionId",
      "wZCHj",
      "roots",
      "removeNotificationListener",
      "1628495nlouLW",
      "addRequestListener",
      "xZlrW",
      "4650435ijSJjJ",
      "2060858ZiIYSc",
      "SUlgi",
      "_eventSource",
      "eventSourceInit",
      "MRyfg",
      "mcp-stream-proxy-client",
      "sse-session-id",
      "name",
      "alwWV",
      "aDqLK",
    ];
    return (
      (Pi = function () {
        return t;
      }),
      Pi()
    );
  }
  const Ex = (t, e) => {
      const r = qr,
        a = qr,
        n = {
          MRyfg: function (l, c, u) {
            return l(c, u);
          },
        };
      n[r(210)](fx, t, e), n.MRyfg(px, t, e);
      const s = hx(e, t),
        o = n.MRyfg(vx, e, t),
        i = mx(e, t);
      e[r(203)](s),
        e.addResponseListener(o),
        e.addNotificationListener(i),
        (t.onclose = () => {
          const l = r,
            c = a;
          e[l(218)](s), e[l(177)](o), e[c(201)](i);
        });
    },
    km = (t, e, r) => {
      const a = qr,
        n = qr,
        s = {
          oHJBZ: function (l, c) {
            return l instanceof c;
          },
          THMqs: a(192),
          Ukaqt: function (l, c, u) {
            return l(c, u);
          },
          pgcGT: function (l, c, u) {
            return l(c, u);
          },
        },
        o = () => {
          var l;
          const c = a,
            u = a;
          s[c(173)](r, Ra) &&
            ((l = r[u(208)]) == null ||
              l.addEventListener(s.THMqs, () => {
                var f;
                const v = c;
                (f = r._eventSource) == null || f[v(192)]();
              })),
            s.Ukaqt(Ex, t, e);
        },
        i = {};
      (i[n(186)] = o), s.pgcGT(yx, e, i);
    },
    Cm = (t, e = Vn[Cs(191)]()) => {
      const r = Cs,
        a = Cs,
        n = {
          sFqUo: function (u, f, v) {
            return u(f, v);
          },
          KmDTz: r(184),
        },
        s = {};
      s[a(212)] = e;
      const o = s,
        i = {};
      i["sse-session-id"] = e;
      const l = {};
      (l[a(195)] = i), (l[r(175)] = n[r(172)]);
      const c = {
        requestInit: l,
        eventSourceInit: {
          async fetch(u, f) {
            const v = r,
              d = new Headers((f == null ? void 0 : f.headers) || {});
            Object[v(187)](o).forEach(([g, m]) => {
              d[v(178)](g, m);
            });
            const p = { ...f };
            return (p.headers = d), n.sFqUo(fetch, u, p);
          },
          withCredentials: !0,
        },
      };
      return (
        t &&
          ((c[a(193)][r(195)].Authorization = "Bearer " + t),
          (o.Authorization = "Bearer " + t)),
        c
      );
    },
    Rm = (t, e = Vn[wn(191)]()) => {
      const r = wn,
        a = Cs,
        n = {};
      n["stream-session-id"] = e;
      const s = {};
      (s.headers = n), (s[r(175)] = r(184));
      const o = {};
      o[a(193)] = s;
      const i = o;
      return t && (i.requestInit[r(195)][r(185)] = "Bearer " + t), i;
    };
  function qr(t, e) {
    const r = Pi();
    return (
      (qr = function (a, n) {
        return (a = a - (-1 * -8402 + -921 * -6 + 13759 * -1)), r[a];
      }),
      qr(t, e)
    );
  }
  const Rs = async (t, e, r) => {
      const a = wn,
        n = {
          YdzuA: function (o, i) {
            return o instanceof i;
          },
          uzBvt: function (o) {
            return o();
          },
          alwWV: function (o, i, l, c) {
            return o(i, l, c);
          },
        },
        s = r();
      try {
        return await t.connect(s), s;
      } catch (o) {
        if (n.YdzuA(o, Sr)) {
          const i = await n.uzBvt(e);
          return await s.finishAuth(i), await n[a(214)](Rs, t, e, r);
        } else throw o;
      }
    },
    Om = (t, e) => {
      const r = wn,
        a = wn,
        n = {};
      (n[r(199)] = "waitForOAuthCode"),
        (n[r(183)] = function (o, i) {
          return o === i;
        }),
        (n[a(207)] = r(216));
      const s = n;
      if (s.wZCHj in t) return t.waitForOAuthCode;
      if (s.KaUfV(typeof e, s[r(207)])) return e;
      throw new Error(
        "waitForOAuthCode need to be provided when authProvider is provided"
      );
    },
    Sx = async (t) => {
      const e = wn,
        r = wn,
        a = {
          rasho: e(197),
          rmzgk: r(169),
          JPlVw: function (M) {
            return M();
          },
          TIBus: function (M, H, V) {
            return M(H, V);
          },
          JyYqS: function (M, H, V, J) {
            return M(H, V, J);
          },
          ywGtJ: function (M, H, V, J) {
            return M(H, V, J);
          },
        },
        {
          client: n,
          url: s,
          token: o,
          sessionId: i,
          authProvider: l,
          requestInit: c,
          eventSourceInit: u,
          waitForOAuthCode: f,
        } = t,
        v = {};
      (v[e(219)] = l), (v[e(193)] = c), (v.eventSourceInit = u);
      const d = v,
        p = i || Vn[r(191)](),
        g = Cm(o, p);
      if (c) {
        const M = { ...g.requestInit, ...c };
        (M.headers = { ...g[r(193)][r(195)], ...c[e(195)] }), (d[r(193)] = M);
      } else d[e(193)] = g[r(193)];
      if (u) {
        const M = { ...g.eventSourceInit, ...u };
        d[e(209)] = M;
      } else d[e(209)] = g[e(209)];
      const m = {};
      m[r(182)] = !0;
      const h = {};
      (h[r(200)] = m), (h.sampling = {}), (h.elicitation = {});
      const y = h,
        _ = {};
      (_[r(213)] = a.rasho), (_[r(181)] = a[e(170)]);
      const w = {};
      w.capabilities = y;
      const E = new pi(_, w),
        P = () => new Ra(new URL(s), d);
      let x = a[e(217)](P);
      if (l) {
        const M = a[r(174)](Om, l, f);
        x = await a.JyYqS(Rs, E, M, P);
      } else await E.connect(x);
      a.ywGtJ(km, E, n, x), (x[e(198)] = x._endpoint[r(179)].get("sessionId"));
      const A = {};
      return (A.transport = x), (A[e(198)] = x[r(198)]), A;
    },
    $x = async (t) => {
      const e = wn,
        r = Cs,
        a = {
          AJbbW: function (M, H, V) {
            return M(H, V);
          },
          ZXEHq: e(211),
          aDqLK: function (M) {
            return M();
          },
          nKQkl: function (M, H, V) {
            return M(H, V);
          },
          xZlrW: function (M, H, V, J) {
            return M(H, V, J);
          },
        },
        {
          client: n,
          url: s,
          token: o,
          sessionId: i,
          authProvider: l,
          requestInit: c,
          reconnectionOptions: u,
          waitForOAuthCode: f,
        } = t,
        v = {};
      (v.authProvider = l), (v.requestInit = c), (v.reconnectionOptions = u);
      const d = v,
        p = i || Vn.randomUUID(),
        g = a.AJbbW(Rm, o, p);
      if (c) {
        const M = { ...g[e(193)], ...c };
        (M.headers = { ...g.requestInit.headers, ...c[r(195)] }),
          (d.requestInit = M);
      } else d[e(193)] = g[e(193)];
      const m = {};
      m[r(182)] = !0;
      const h = {};
      (h[e(200)] = m), (h[e(189)] = {}), (h.elicitation = {});
      const y = h,
        _ = {};
      (_[e(213)] = a[e(171)]), (_.version = e(169));
      const w = {};
      w[e(190)] = y;
      const E = new pi(_, w),
        P = () => new Oa(new URL(s), d);
      let x = a[e(215)](P);
      if (l) {
        const M = a.nKQkl(Om, l, f);
        x = await a[r(204)](Rs, E, M, P);
      } else await E.connect(x);
      km(E, n, x);
      const A = {};
      return (A[r(196)] = x), (A[e(198)] = x[e(198)]), A;
    };
  function Ti() {
    const t = [
      "_callBackPromise",
      "clientMetadata",
      "clientInformation",
      "_redirectCallback",
      "134455mslyQC",
      "558338pOTNJB",
      "510616LiqUbS",
      "json",
      "7441KftUnn",
      "20YdRwwG",
      "POST",
      "code",
      "_getAuthCodeByState",
      "DjZmq",
      "statusText",
      "17336099YnGEHr",
      "saveCodeVerifier",
      "996bqURbL",
      "Failed to fetch auth code: ",
      "_clientMetadata",
      "saveTokens",
      "VGvoL",
      "No code verifier saved",
      "redirect_uris",
      "reject",
      "693422ltcndC",
      "Failed to redirect: ",
      "redirectUrl",
      "99IWgtlv",
      "6UDGeyf",
      "waitForOAuthCode",
      "codeVerifier",
      "waitForOAuthCodeFunction",
      "GET",
      "_codeVerifier",
      "_clientInformation",
      "resolve",
      "getAuthCodeByStateFunction",
      "_tokens",
      "8655150IwrNAp",
      "_state",
    ];
    return (
      (Ti = function () {
        return t;
      }),
      Ti()
    );
  }
  const Ur = tr,
    Hu = tr;
  (function (t, e) {
    const r = tr,
      a = tr,
      n = t();
    for (;;)
      try {
        if (
          parseInt(r(259)) / 1 +
            (parseInt(a(239)) / 2) * (-parseInt(a(263)) / 3) +
            (parseInt(r(243)) / 4) * (parseInt(a(238)) / 5) +
            (parseInt(r(251)) / 6) * (parseInt(r(242)) / 7) +
            (-parseInt(a(240)) / 8) * (-parseInt(r(262)) / 9) +
            parseInt(r(273)) / 10 +
            -parseInt(a(249)) / 11 ===
          e
        )
          break;
        n.push(n.shift());
      } catch {
        n.push(n.shift());
      }
  })(Ti, 437600);
  const Px = () => Vn.randomBytes(8128 + 115 * -5 + -7513);
  function tr(t, e) {
    const r = Ti();
    return (
      (tr = function (a, n) {
        return (a = a - (-1 * 2069 + 9 * 832 + 54 * -96)), r[a];
      }),
      tr(t, e)
    );
  }
  class Tx {
    constructor(e) {
      const r = tr,
        a = tr;
      this[r(275)] = {};
      const {
        clientMetadata: n,
        state: s,
        redirectCallback: o,
        getAuthCodeByState: i,
        waitForOAuthCode: l,
      } = e;
      (this[a(253)] = n),
        (this._redirectUrl = n[r(257)][-9616 + -4068 * -1 + 5548]),
        (this._state = s || Px()),
        (this[a(237)] = o || this.redirectCallbackFunction),
        (this[a(246)] = i || this[r(271)]),
        (this[r(264)] = l || this[a(266)]());
    }
    async redirectCallbackFunction(e) {
      var r, a, n, s, o, i;
      const l = tr,
        c = tr,
        u = {};
      u.TspJZ = l(267);
      const f = u,
        v = {};
      v.method = f.TspJZ;
      const d = await fetch(e, v);
      !d.ok &&
        ((a = (r = this._callBackPromise).reject) == null ||
          a.call(r, l(260) + d.statusText));
      const p = await this[c(246)](this._redirectUrl, this[c(274)]);
      if (!p.ok) {
        (s = (n = this[c(275)])[c(258)]) == null ||
          s.call(n, c(252) + p[c(248)]);
        return;
      }
      const g = await p[l(241)]();
      (i = (o = this[l(275)])[c(270)]) == null || i.call(o, g[c(245)]);
    }
    async getAuthCodeByStateFunction(e, r) {
      const a = tr,
        n = tr,
        s = {
          DjZmq: function (i, l, c) {
            return i(l, c);
          },
          WUtMg: "application/x-www-form-urlencoded",
        },
        o = {};
      return (
        (o.state = r),
        s[a(247)](fetch, e, {
          method: n(244),
          headers: { "Content-Type": s.WUtMg },
          body: new URLSearchParams(o),
        })
      );
    }
    waitForOAuthCodeFunction() {
      const e = this._callBackPromise;
      return () =>
        new Promise((r, a) => {
          const n = tr;
          (e.resolve = r), (e[n(258)] = a);
        });
    }
    get [Ur(261)]() {
      return this._redirectUrl;
    }
    get [Hu(235)]() {
      return this._clientMetadata;
    }
    state() {
      return this[Ur(274)];
    }
    [Ur(236)]() {
      return this._clientInformation;
    }
    saveClientInformation(e) {
      const r = Hu;
      this[r(269)] = e;
    }
    tokens() {
      return this._tokens;
    }
    [Hu(254)](e) {
      const r = Ur;
      this[r(272)] = e;
    }
    redirectToAuthorization(e) {
      this[Ur(237)](e);
    }
    [Ur(250)](e) {
      const r = Ur;
      this[r(268)] = e;
    }
    [Ur(265)]() {
      const e = Ur,
        r = Ur,
        a = {};
      a[e(255)] = e(256);
      const n = a;
      if (!this._codeVerifier) throw new Error(n[r(255)]);
      return this[r(268)];
    }
  }
  (function (t, e) {
    for (var r = Ii, a = Ii, n = t(); ; )
      try {
        var s =
          (-parseInt(r(299)) / 1) * (-parseInt(a(296)) / 2) +
          -parseInt(a(298)) / 3 +
          parseInt(a(300)) / 4 +
          -parseInt(r(292)) / 5 +
          (parseInt(a(295)) / 6) * (parseInt(r(294)) / 7) +
          -parseInt(r(297)) / 8 +
          -parseInt(a(293)) / 9;
        if (s === e) break;
        n.push(n.shift());
      } catch {
        n.push(n.shift());
      }
  })(xi, 722500 + -10 * 107029 + 902741);
  function xi() {
    var t = [
      "2iLxULY",
      "1547872TvYRpQ",
      "3124428cOXNRq",
      "1035197lJDFGt",
      "3486564wwalRD",
      "2645980SUHNlu",
      "872424UrZLEr",
      "2905TFXGtD",
      "7362fQOePf",
    ];
    return (
      (xi = function () {
        return t;
      }),
      xi()
    );
  }
  function Ii(t, e) {
    var r = xi();
    return (
      (Ii = function (a, n) {
        a = a - (2152 * 2 + -563 * 12 + 2744);
        var s = r[a];
        return s;
      }),
      Ii(t, e)
    );
  }
  class xx extends xh {
    constructor(e, r) {
      var a;
      super(r),
        (this._serverInfo = e),
        (this._capabilities =
          (a = r == null ? void 0 : r.capabilities) !== null && a !== void 0
            ? a
            : {}),
        (this._instructions = r == null ? void 0 : r.instructions),
        this.setRequestHandler(th, (n) => this._oninitialize(n)),
        this.setNotificationHandler(Cc, () => {
          var n;
          return (n = this.oninitialized) === null || n === void 0
            ? void 0
            : n.call(this);
        });
    }
    registerCapabilities(e) {
      if (this.transport)
        throw new Error(
          "Cannot register capabilities after connecting to transport"
        );
      this._capabilities = Ih(this._capabilities, e);
    }
    assertCapabilityForMethod(e) {
      var r, a, n;
      switch (e) {
        case "sampling/createMessage":
          if (
            !(
              !((r = this._clientCapabilities) === null || r === void 0) &&
              r.sampling
            )
          )
            throw new Error(
              `Client does not support sampling (required for ${e})`
            );
          break;
        case "elicitation/create":
          if (
            !(
              !((a = this._clientCapabilities) === null || a === void 0) &&
              a.elicitation
            )
          )
            throw new Error(
              `Client does not support elicitation (required for ${e})`
            );
          break;
        case "roots/list":
          if (
            !(
              !((n = this._clientCapabilities) === null || n === void 0) &&
              n.roots
            )
          )
            throw new Error(
              `Client does not support listing roots (required for ${e})`
            );
          break;
      }
    }
    assertNotificationCapability(e) {
      switch (e) {
        case "notifications/message":
          if (!this._capabilities.logging)
            throw new Error(
              `Server does not support logging (required for ${e})`
            );
          break;
        case "notifications/resources/updated":
        case "notifications/resources/list_changed":
          if (!this._capabilities.resources)
            throw new Error(
              `Server does not support notifying about resources (required for ${e})`
            );
          break;
        case "notifications/tools/list_changed":
          if (!this._capabilities.tools)
            throw new Error(
              `Server does not support notifying of tool list changes (required for ${e})`
            );
          break;
        case "notifications/prompts/list_changed":
          if (!this._capabilities.prompts)
            throw new Error(
              `Server does not support notifying of prompt list changes (required for ${e})`
            );
          break;
      }
    }
    assertRequestHandlerCapability(e) {
      switch (e) {
        case "sampling/createMessage":
          if (!this._capabilities.sampling)
            throw new Error(
              `Server does not support sampling (required for ${e})`
            );
          break;
        case "logging/setLevel":
          if (!this._capabilities.logging)
            throw new Error(
              `Server does not support logging (required for ${e})`
            );
          break;
        case "prompts/get":
        case "prompts/list":
          if (!this._capabilities.prompts)
            throw new Error(
              `Server does not support prompts (required for ${e})`
            );
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
          if (!this._capabilities.resources)
            throw new Error(
              `Server does not support resources (required for ${e})`
            );
          break;
        case "tools/call":
        case "tools/list":
          if (!this._capabilities.tools)
            throw new Error(
              `Server does not support tools (required for ${e})`
            );
          break;
      }
    }
    async _oninitialize(e) {
      const r = e.params.protocolVersion;
      return (
        (this._clientCapabilities = e.params.capabilities),
        (this._clientVersion = e.params.clientInfo),
        {
          protocolVersion: Bp.includes(r) ? r : bs,
          capabilities: this.getCapabilities(),
          serverInfo: this._serverInfo,
          ...(this._instructions && { instructions: this._instructions }),
        }
      );
    }
    getClientCapabilities() {
      return this._clientCapabilities;
    }
    getClientVersion() {
      return this._clientVersion;
    }
    getCapabilities() {
      return this._capabilities;
    }
    async ping() {
      return this.request({ method: "ping" }, mn);
    }
    async createMessage(e, r) {
      return this.request(
        { method: "sampling/createMessage", params: e },
        Zc,
        r
      );
    }
    async elicitInput(e, r) {
      const a = await this.request(
        { method: "elicitation/create", params: e },
        Hc,
        r
      );
      if (a.action === "accept" && a.content)
        try {
          const n = new vm(),
            s = n.compile(e.requestedSchema);
          if (!s(a.content))
            throw new st(
              rt.InvalidParams,
              `Elicitation response content does not match requested schema: ${n.errorsText(
                s.errors
              )}`
            );
        } catch (n) {
          throw n instanceof st
            ? n
            : new st(
                rt.InternalError,
                `Error validating elicitation response: ${n}`
              );
        }
      return a;
    }
    async listRoots(e, r) {
      return this.request({ method: "roots/list", params: e }, Jc, r);
    }
    async sendLoggingMessage(e) {
      return this.notification({ method: "notifications/message", params: e });
    }
    async sendResourceUpdated(e) {
      return this.notification({
        method: "notifications/resources/updated",
        params: e,
      });
    }
    async sendResourceListChanged() {
      return this.notification({
        method: "notifications/resources/list_changed",
      });
    }
    async sendToolListChanged() {
      return this.notification({ method: "notifications/tools/list_changed" });
    }
    async sendPromptListChanged() {
      return this.notification({
        method: "notifications/prompts/list_changed",
      });
    }
  }
  const Ix = Symbol("Let zodToJsonSchema decide on which parser to use"),
    Am = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      allowedAdditionalProperties: !0,
      rejectedAdditionalProperties: !1,
      definitionPath: "definitions",
      target: "jsonSchema7",
      strictUnions: !1,
      definitions: {},
      errorMessages: !1,
      markdownDescription: !1,
      patternStrategy: "escape",
      applyRegexFlags: !1,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref",
      openAiAnyTypeName: "OpenAiAnyType",
    },
    kx = (t) => (typeof t == "string" ? { ...Am, name: t } : { ...Am, ...t }),
    Cx = (t) => {
      const e = kx(t),
        r =
          e.name !== void 0
            ? [...e.basePath, e.definitionPath, e.name]
            : e.basePath;
      return {
        ...e,
        flags: { hasReferencedOpenAiAnyType: !1 },
        currentPath: r,
        propertyPath: void 0,
        seen: new Map(
          Object.entries(e.definitions).map(([a, n]) => [
            n._def,
            {
              def: n._def,
              path: [...e.basePath, e.definitionPath, a],
              jsonSchema: void 0,
            },
          ])
        ),
      };
    };
  function Nm(t, e, r, a) {
    a != null &&
      a.errorMessages &&
      r &&
      (t.errorMessage = { ...t.errorMessage, [e]: r });
  }
  function Ke(t, e, r, a, n) {
    (t[e] = r), Nm(t, e, a, n);
  }
  const Mm = (t, e) => {
    let r = 0;
    for (; r < t.length && r < e.length && t[r] === e[r]; r++);
    return [(t.length - r).toString(), ...e.slice(r)].join("/");
  };
  function Qt(t) {
    if (t.target !== "openAi") return {};
    const e = [...t.basePath, t.definitionPath, t.openAiAnyTypeName];
    return (
      (t.flags.hasReferencedOpenAiAnyType = !0),
      {
        $ref:
          t.$refStrategy === "relative" ? Mm(e, t.currentPath) : e.join("/"),
      }
    );
  }
  function Rx(t, e) {
    var a, n, s;
    const r = { type: "array" };
    return (
      (a = t.type) != null &&
        a._def &&
        ((s = (n = t.type) == null ? void 0 : n._def) == null
          ? void 0
          : s.typeName) !== X.ZodAny &&
        (r.items = He(t.type._def, {
          ...e,
          currentPath: [...e.currentPath, "items"],
        })),
      t.minLength &&
        Ke(r, "minItems", t.minLength.value, t.minLength.message, e),
      t.maxLength &&
        Ke(r, "maxItems", t.maxLength.value, t.maxLength.message, e),
      t.exactLength &&
        (Ke(r, "minItems", t.exactLength.value, t.exactLength.message, e),
        Ke(r, "maxItems", t.exactLength.value, t.exactLength.message, e)),
      r
    );
  }
  function Ox(t, e) {
    const r = { type: "integer", format: "int64" };
    if (!t.checks) return r;
    for (const a of t.checks)
      switch (a.kind) {
        case "min":
          e.target === "jsonSchema7"
            ? a.inclusive
              ? Ke(r, "minimum", a.value, a.message, e)
              : Ke(r, "exclusiveMinimum", a.value, a.message, e)
            : (a.inclusive || (r.exclusiveMinimum = !0),
              Ke(r, "minimum", a.value, a.message, e));
          break;
        case "max":
          e.target === "jsonSchema7"
            ? a.inclusive
              ? Ke(r, "maximum", a.value, a.message, e)
              : Ke(r, "exclusiveMaximum", a.value, a.message, e)
            : (a.inclusive || (r.exclusiveMaximum = !0),
              Ke(r, "maximum", a.value, a.message, e));
          break;
        case "multipleOf":
          Ke(r, "multipleOf", a.value, a.message, e);
          break;
      }
    return r;
  }
  function Ax() {
    return { type: "boolean" };
  }
  function jm(t, e) {
    return He(t.type._def, e);
  }
  const Nx = (t, e) => He(t.innerType._def, e);
  function Dm(t, e, r) {
    const a = r ?? e.dateStrategy;
    if (Array.isArray(a)) return { anyOf: a.map((n, s) => Dm(t, e, n)) };
    switch (a) {
      case "string":
      case "format:date-time":
        return { type: "string", format: "date-time" };
      case "format:date":
        return { type: "string", format: "date" };
      case "integer":
        return Mx(t, e);
    }
  }
  const Mx = (t, e) => {
    const r = { type: "integer", format: "unix-time" };
    if (e.target === "openApi3") return r;
    for (const a of t.checks)
      switch (a.kind) {
        case "min":
          Ke(r, "minimum", a.value, a.message, e);
          break;
        case "max":
          Ke(r, "maximum", a.value, a.message, e);
          break;
      }
    return r;
  };
  function jx(t, e) {
    return { ...He(t.innerType._def, e), default: t.defaultValue() };
  }
  function Dx(t, e) {
    return e.effectStrategy === "input" ? He(t.schema._def, e) : Qt(e);
  }
  function Lx(t) {
    return { type: "string", enum: Array.from(t.values) };
  }
  const zx = (t) => ("type" in t && t.type === "string" ? !1 : "allOf" in t);
  function qx(t, e) {
    const r = [
      He(t.left._def, { ...e, currentPath: [...e.currentPath, "allOf", "0"] }),
      He(t.right._def, { ...e, currentPath: [...e.currentPath, "allOf", "1"] }),
    ].filter((s) => !!s);
    let a =
      e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
    const n = [];
    return (
      r.forEach((s) => {
        if (zx(s))
          n.push(...s.allOf),
            s.unevaluatedProperties === void 0 && (a = void 0);
        else {
          let o = s;
          if ("additionalProperties" in s && s.additionalProperties === !1) {
            const { additionalProperties: i, ...l } = s;
            o = l;
          } else a = void 0;
          n.push(o);
        }
      }),
      n.length ? { allOf: n, ...a } : void 0
    );
  }
  function Ux(t, e) {
    const r = typeof t.value;
    return r !== "bigint" && r !== "number" && r !== "boolean" && r !== "string"
      ? { type: Array.isArray(t.value) ? "array" : "object" }
      : e.target === "openApi3"
      ? { type: r === "bigint" ? "integer" : r, enum: [t.value] }
      : { type: r === "bigint" ? "integer" : r, const: t.value };
  }
  let Bu;
  const $r = {
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    email:
      /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    emoji: () => (
      Bu === void 0 &&
        (Bu = RegExp(
          "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
          "u"
        )),
      Bu
    ),
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr:
      /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr:
      /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url:
      /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
  };
  function Lm(t, e) {
    const r = { type: "string" };
    if (t.checks)
      for (const a of t.checks)
        switch (a.kind) {
          case "min":
            Ke(
              r,
              "minLength",
              typeof r.minLength == "number"
                ? Math.max(r.minLength, a.value)
                : a.value,
              a.message,
              e
            );
            break;
          case "max":
            Ke(
              r,
              "maxLength",
              typeof r.maxLength == "number"
                ? Math.min(r.maxLength, a.value)
                : a.value,
              a.message,
              e
            );
            break;
          case "email":
            switch (e.emailStrategy) {
              case "format:email":
                Pr(r, "email", a.message, e);
                break;
              case "format:idn-email":
                Pr(r, "idn-email", a.message, e);
                break;
              case "pattern:zod":
                Ut(r, $r.email, a.message, e);
                break;
            }
            break;
          case "url":
            Pr(r, "uri", a.message, e);
            break;
          case "uuid":
            Pr(r, "uuid", a.message, e);
            break;
          case "regex":
            Ut(r, a.regex, a.message, e);
            break;
          case "cuid":
            Ut(r, $r.cuid, a.message, e);
            break;
          case "cuid2":
            Ut(r, $r.cuid2, a.message, e);
            break;
          case "startsWith":
            Ut(r, RegExp(`^${Ju(a.value, e)}`), a.message, e);
            break;
          case "endsWith":
            Ut(r, RegExp(`${Ju(a.value, e)}$`), a.message, e);
            break;
          case "datetime":
            Pr(r, "date-time", a.message, e);
            break;
          case "date":
            Pr(r, "date", a.message, e);
            break;
          case "time":
            Pr(r, "time", a.message, e);
            break;
          case "duration":
            Pr(r, "duration", a.message, e);
            break;
          case "length":
            Ke(
              r,
              "minLength",
              typeof r.minLength == "number"
                ? Math.max(r.minLength, a.value)
                : a.value,
              a.message,
              e
            ),
              Ke(
                r,
                "maxLength",
                typeof r.maxLength == "number"
                  ? Math.min(r.maxLength, a.value)
                  : a.value,
                a.message,
                e
              );
            break;
          case "includes": {
            Ut(r, RegExp(Ju(a.value, e)), a.message, e);
            break;
          }
          case "ip": {
            a.version !== "v6" && Pr(r, "ipv4", a.message, e),
              a.version !== "v4" && Pr(r, "ipv6", a.message, e);
            break;
          }
          case "base64url":
            Ut(r, $r.base64url, a.message, e);
            break;
          case "jwt":
            Ut(r, $r.jwt, a.message, e);
            break;
          case "cidr": {
            a.version !== "v6" && Ut(r, $r.ipv4Cidr, a.message, e),
              a.version !== "v4" && Ut(r, $r.ipv6Cidr, a.message, e);
            break;
          }
          case "emoji":
            Ut(r, $r.emoji(), a.message, e);
            break;
          case "ulid": {
            Ut(r, $r.ulid, a.message, e);
            break;
          }
          case "base64": {
            switch (e.base64Strategy) {
              case "format:binary": {
                Pr(r, "binary", a.message, e);
                break;
              }
              case "contentEncoding:base64": {
                Ke(r, "contentEncoding", "base64", a.message, e);
                break;
              }
              case "pattern:zod": {
                Ut(r, $r.base64, a.message, e);
                break;
              }
            }
            break;
          }
          case "nanoid":
            Ut(r, $r.nanoid, a.message, e);
        }
    return r;
  }
  function Ju(t, e) {
    return e.patternStrategy === "escape" ? Vx(t) : t;
  }
  const Fx = new Set(
    "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
  );
  function Vx(t) {
    let e = "";
    for (let r = 0; r < t.length; r++) Fx.has(t[r]) || (e += "\\"), (e += t[r]);
    return e;
  }
  function Pr(t, e, r, a) {
    var n;
    t.format || ((n = t.anyOf) != null && n.some((s) => s.format))
      ? (t.anyOf || (t.anyOf = []),
        t.format &&
          (t.anyOf.push({
            format: t.format,
            ...(t.errorMessage &&
              a.errorMessages && {
                errorMessage: { format: t.errorMessage.format },
              }),
          }),
          delete t.format,
          t.errorMessage &&
            (delete t.errorMessage.format,
            Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)),
        t.anyOf.push({
          format: e,
          ...(r && a.errorMessages && { errorMessage: { format: r } }),
        }))
      : Ke(t, "format", e, r, a);
  }
  function Ut(t, e, r, a) {
    var n;
    t.pattern || ((n = t.allOf) != null && n.some((s) => s.pattern))
      ? (t.allOf || (t.allOf = []),
        t.pattern &&
          (t.allOf.push({
            pattern: t.pattern,
            ...(t.errorMessage &&
              a.errorMessages && {
                errorMessage: { pattern: t.errorMessage.pattern },
              }),
          }),
          delete t.pattern,
          t.errorMessage &&
            (delete t.errorMessage.pattern,
            Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)),
        t.allOf.push({
          pattern: zm(e, a),
          ...(r && a.errorMessages && { errorMessage: { pattern: r } }),
        }))
      : Ke(t, "pattern", zm(e, a), r, a);
  }
  function zm(t, e) {
    var l;
    if (!e.applyRegexFlags || !t.flags) return t.source;
    const r = {
        i: t.flags.includes("i"),
        m: t.flags.includes("m"),
        s: t.flags.includes("s"),
      },
      a = r.i ? t.source.toLowerCase() : t.source;
    let n = "",
      s = !1,
      o = !1,
      i = !1;
    for (let c = 0; c < a.length; c++) {
      if (s) {
        (n += a[c]), (s = !1);
        continue;
      }
      if (r.i) {
        if (o) {
          if (a[c].match(/[a-z]/)) {
            i
              ? ((n += a[c]),
                (n += `${a[c - 2]}-${a[c]}`.toUpperCase()),
                (i = !1))
              : a[c + 1] === "-" && (l = a[c + 2]) != null && l.match(/[a-z]/)
              ? ((n += a[c]), (i = !0))
              : (n += `${a[c]}${a[c].toUpperCase()}`);
            continue;
          }
        } else if (a[c].match(/[a-z]/)) {
          n += `[${a[c]}${a[c].toUpperCase()}]`;
          continue;
        }
      }
      if (r.m) {
        if (a[c] === "^") {
          n += `(^|(?<=[\r
]))`;
          continue;
        } else if (a[c] === "$") {
          n += `($|(?=[\r
]))`;
          continue;
        }
      }
      if (r.s && a[c] === ".") {
        n += o
          ? `${a[c]}\r
`
          : `[${a[c]}\r
]`;
        continue;
      }
      (n += a[c]),
        a[c] === "\\"
          ? (s = !0)
          : o && a[c] === "]"
          ? (o = !1)
          : !o && a[c] === "[" && (o = !0);
    }
    try {
      new RegExp(n);
    } catch {
      return (
        console.warn(
          `Could not convert regex pattern at ${e.currentPath.join(
            "/"
          )} to a flag-independent form! Falling back to the flag-ignorant source`
        ),
        t.source
      );
    }
    return n;
  }
  function qm(t, e) {
    var a, n, s, o, i, l;
    if (
      (e.target === "openAi" &&
        console.warn(
          "Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."
        ),
      e.target === "openApi3" &&
        ((a = t.keyType) == null ? void 0 : a._def.typeName) === X.ZodEnum)
    )
      return {
        type: "object",
        required: t.keyType._def.values,
        properties: t.keyType._def.values.reduce(
          (c, u) => ({
            ...c,
            [u]:
              He(t.valueType._def, {
                ...e,
                currentPath: [...e.currentPath, "properties", u],
              }) ?? Qt(e),
          }),
          {}
        ),
        additionalProperties: e.rejectedAdditionalProperties,
      };
    const r = {
      type: "object",
      additionalProperties:
        He(t.valueType._def, {
          ...e,
          currentPath: [...e.currentPath, "additionalProperties"],
        }) ?? e.allowedAdditionalProperties,
    };
    if (e.target === "openApi3") return r;
    if (
      ((n = t.keyType) == null ? void 0 : n._def.typeName) === X.ZodString &&
      (s = t.keyType._def.checks) != null &&
      s.length
    ) {
      const { type: c, ...u } = Lm(t.keyType._def, e);
      return { ...r, propertyNames: u };
    } else {
      if (((o = t.keyType) == null ? void 0 : o._def.typeName) === X.ZodEnum)
        return { ...r, propertyNames: { enum: t.keyType._def.values } };
      if (
        ((i = t.keyType) == null ? void 0 : i._def.typeName) === X.ZodBranded &&
        t.keyType._def.type._def.typeName === X.ZodString &&
        (l = t.keyType._def.type._def.checks) != null &&
        l.length
      ) {
        const { type: c, ...u } = jm(t.keyType._def, e);
        return { ...r, propertyNames: u };
      }
    }
    return r;
  }
  function Zx(t, e) {
    if (e.mapStrategy === "record") return qm(t, e);
    const r =
        He(t.keyType._def, {
          ...e,
          currentPath: [...e.currentPath, "items", "items", "0"],
        }) || Qt(e),
      a =
        He(t.valueType._def, {
          ...e,
          currentPath: [...e.currentPath, "items", "items", "1"],
        }) || Qt(e);
    return {
      type: "array",
      maxItems: 125,
      items: { type: "array", items: [r, a], minItems: 2, maxItems: 2 },
    };
  }
  function Hx(t) {
    const e = t.values,
      a = Object.keys(t.values)
        .filter((s) => typeof e[e[s]] != "number")
        .map((s) => e[s]),
      n = Array.from(new Set(a.map((s) => typeof s)));
    return {
      type:
        n.length === 1
          ? n[0] === "string"
            ? "string"
            : "number"
          : ["string", "number"],
      enum: a,
    };
  }
  function Bx(t) {
    return t.target === "openAi"
      ? void 0
      : { not: Qt({ ...t, currentPath: [...t.currentPath, "not"] }) };
  }
  function Jx(t) {
    return t.target === "openApi3"
      ? { enum: ["null"], nullable: !0 }
      : { type: "null" };
  }
  const ki = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null",
  };
  function Kx(t, e) {
    if (e.target === "openApi3") return Um(t, e);
    const r =
      t.options instanceof Map ? Array.from(t.options.values()) : t.options;
    if (
      r.every(
        (a) =>
          a._def.typeName in ki && (!a._def.checks || !a._def.checks.length)
      )
    ) {
      const a = r.reduce((n, s) => {
        const o = ki[s._def.typeName];
        return o && !n.includes(o) ? [...n, o] : n;
      }, []);
      return { type: a.length > 1 ? a : a[0] };
    } else if (
      r.every((a) => a._def.typeName === "ZodLiteral" && !a.description)
    ) {
      const a = r.reduce((n, s) => {
        const o = typeof s._def.value;
        switch (o) {
          case "string":
          case "number":
          case "boolean":
            return [...n, o];
          case "bigint":
            return [...n, "integer"];
          case "object":
            if (s._def.value === null) return [...n, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return n;
        }
      }, []);
      if (a.length === r.length) {
        const n = a.filter((s, o, i) => i.indexOf(s) === o);
        return {
          type: n.length > 1 ? n : n[0],
          enum: r.reduce(
            (s, o) => (s.includes(o._def.value) ? s : [...s, o._def.value]),
            []
          ),
        };
      }
    } else if (r.every((a) => a._def.typeName === "ZodEnum"))
      return {
        type: "string",
        enum: r.reduce(
          (a, n) => [...a, ...n._def.values.filter((s) => !a.includes(s))],
          []
        ),
      };
    return Um(t, e);
  }
  const Um = (t, e) => {
    const r = (
      t.options instanceof Map ? Array.from(t.options.values()) : t.options
    )
      .map((a, n) =>
        He(a._def, { ...e, currentPath: [...e.currentPath, "anyOf", `${n}`] })
      )
      .filter(
        (a) =>
          !!a &&
          (!e.strictUnions ||
            (typeof a == "object" && Object.keys(a).length > 0))
      );
    return r.length ? { anyOf: r } : void 0;
  };
  function Gx(t, e) {
    if (
      ["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
        t.innerType._def.typeName
      ) &&
      (!t.innerType._def.checks || !t.innerType._def.checks.length)
    )
      return e.target === "openApi3"
        ? { type: ki[t.innerType._def.typeName], nullable: !0 }
        : { type: [ki[t.innerType._def.typeName], "null"] };
    if (e.target === "openApi3") {
      const a = He(t.innerType._def, { ...e, currentPath: [...e.currentPath] });
      return a && "$ref" in a
        ? { allOf: [a], nullable: !0 }
        : a && { ...a, nullable: !0 };
    }
    const r = He(t.innerType._def, {
      ...e,
      currentPath: [...e.currentPath, "anyOf", "0"],
    });
    return r && { anyOf: [r, { type: "null" }] };
  }
  function Wx(t, e) {
    const r = { type: "number" };
    if (!t.checks) return r;
    for (const a of t.checks)
      switch (a.kind) {
        case "int":
          (r.type = "integer"), Nm(r, "type", a.message, e);
          break;
        case "min":
          e.target === "jsonSchema7"
            ? a.inclusive
              ? Ke(r, "minimum", a.value, a.message, e)
              : Ke(r, "exclusiveMinimum", a.value, a.message, e)
            : (a.inclusive || (r.exclusiveMinimum = !0),
              Ke(r, "minimum", a.value, a.message, e));
          break;
        case "max":
          e.target === "jsonSchema7"
            ? a.inclusive
              ? Ke(r, "maximum", a.value, a.message, e)
              : Ke(r, "exclusiveMaximum", a.value, a.message, e)
            : (a.inclusive || (r.exclusiveMaximum = !0),
              Ke(r, "maximum", a.value, a.message, e));
          break;
        case "multipleOf":
          Ke(r, "multipleOf", a.value, a.message, e);
          break;
      }
    return r;
  }
  function Qx(t, e) {
    const r = e.target === "openAi",
      a = { type: "object", properties: {} },
      n = [],
      s = t.shape();
    for (const i in s) {
      let l = s[i];
      if (l === void 0 || l._def === void 0) continue;
      let c = Xx(l);
      c &&
        r &&
        (l._def.typeName === "ZodOptional" && (l = l._def.innerType),
        l.isNullable() || (l = l.nullable()),
        (c = !1));
      const u = He(l._def, {
        ...e,
        currentPath: [...e.currentPath, "properties", i],
        propertyPath: [...e.currentPath, "properties", i],
      });
      u !== void 0 && ((a.properties[i] = u), c || n.push(i));
    }
    n.length && (a.required = n);
    const o = Yx(t, e);
    return o !== void 0 && (a.additionalProperties = o), a;
  }
  function Yx(t, e) {
    if (t.catchall._def.typeName !== "ZodNever")
      return He(t.catchall._def, {
        ...e,
        currentPath: [...e.currentPath, "additionalProperties"],
      });
    switch (t.unknownKeys) {
      case "passthrough":
        return e.allowedAdditionalProperties;
      case "strict":
        return e.rejectedAdditionalProperties;
      case "strip":
        return e.removeAdditionalStrategy === "strict"
          ? e.allowedAdditionalProperties
          : e.rejectedAdditionalProperties;
    }
  }
  function Xx(t) {
    try {
      return t.isOptional();
    } catch {
      return !0;
    }
  }
  const eI = (t, e) => {
      var a;
      if (
        e.currentPath.toString() ===
        ((a = e.propertyPath) == null ? void 0 : a.toString())
      )
        return He(t.innerType._def, e);
      const r = He(t.innerType._def, {
        ...e,
        currentPath: [...e.currentPath, "anyOf", "1"],
      });
      return r ? { anyOf: [{ not: Qt(e) }, r] } : Qt(e);
    },
    tI = (t, e) => {
      if (e.pipeStrategy === "input") return He(t.in._def, e);
      if (e.pipeStrategy === "output") return He(t.out._def, e);
      const r = He(t.in._def, {
          ...e,
          currentPath: [...e.currentPath, "allOf", "0"],
        }),
        a = He(t.out._def, {
          ...e,
          currentPath: [...e.currentPath, "allOf", r ? "1" : "0"],
        });
      return { allOf: [r, a].filter((n) => n !== void 0) };
    };
  function rI(t, e) {
    return He(t.type._def, e);
  }
  function nI(t, e) {
    const a = {
      type: "array",
      uniqueItems: !0,
      items: He(t.valueType._def, {
        ...e,
        currentPath: [...e.currentPath, "items"],
      }),
    };
    return (
      t.minSize && Ke(a, "minItems", t.minSize.value, t.minSize.message, e),
      t.maxSize && Ke(a, "maxItems", t.maxSize.value, t.maxSize.message, e),
      a
    );
  }
  function aI(t, e) {
    return t.rest
      ? {
          type: "array",
          minItems: t.items.length,
          items: t.items
            .map((r, a) =>
              He(r._def, {
                ...e,
                currentPath: [...e.currentPath, "items", `${a}`],
              })
            )
            .reduce((r, a) => (a === void 0 ? r : [...r, a]), []),
          additionalItems: He(t.rest._def, {
            ...e,
            currentPath: [...e.currentPath, "additionalItems"],
          }),
        }
      : {
          type: "array",
          minItems: t.items.length,
          maxItems: t.items.length,
          items: t.items
            .map((r, a) =>
              He(r._def, {
                ...e,
                currentPath: [...e.currentPath, "items", `${a}`],
              })
            )
            .reduce((r, a) => (a === void 0 ? r : [...r, a]), []),
        };
  }
  function sI(t) {
    return { not: Qt(t) };
  }
  function oI(t) {
    return Qt(t);
  }
  const iI = (t, e) => He(t.innerType._def, e),
    lI = (t, e, r) => {
      switch (e) {
        case X.ZodString:
          return Lm(t, r);
        case X.ZodNumber:
          return Wx(t, r);
        case X.ZodObject:
          return Qx(t, r);
        case X.ZodBigInt:
          return Ox(t, r);
        case X.ZodBoolean:
          return Ax();
        case X.ZodDate:
          return Dm(t, r);
        case X.ZodUndefined:
          return sI(r);
        case X.ZodNull:
          return Jx(r);
        case X.ZodArray:
          return Rx(t, r);
        case X.ZodUnion:
        case X.ZodDiscriminatedUnion:
          return Kx(t, r);
        case X.ZodIntersection:
          return qx(t, r);
        case X.ZodTuple:
          return aI(t, r);
        case X.ZodRecord:
          return qm(t, r);
        case X.ZodLiteral:
          return Ux(t, r);
        case X.ZodEnum:
          return Lx(t);
        case X.ZodNativeEnum:
          return Hx(t);
        case X.ZodNullable:
          return Gx(t, r);
        case X.ZodOptional:
          return eI(t, r);
        case X.ZodMap:
          return Zx(t, r);
        case X.ZodSet:
          return nI(t, r);
        case X.ZodLazy:
          return () => t.getter()._def;
        case X.ZodPromise:
          return rI(t, r);
        case X.ZodNaN:
        case X.ZodNever:
          return Bx(r);
        case X.ZodEffects:
          return Dx(t, r);
        case X.ZodAny:
          return Qt(r);
        case X.ZodUnknown:
          return oI(r);
        case X.ZodDefault:
          return jx(t, r);
        case X.ZodBranded:
          return jm(t, r);
        case X.ZodReadonly:
          return iI(t, r);
        case X.ZodCatch:
          return Nx(t, r);
        case X.ZodPipeline:
          return tI(t, r);
        case X.ZodFunction:
        case X.ZodVoid:
        case X.ZodSymbol:
          return;
        default:
          return ((a) => {})();
      }
    };
  function He(t, e, r = !1) {
    var i;
    const a = e.seen.get(t);
    if (e.override) {
      const l = (i = e.override) == null ? void 0 : i.call(e, t, e, a, r);
      if (l !== Ix) return l;
    }
    if (a && !r) {
      const l = cI(a, e);
      if (l !== void 0) return l;
    }
    const n = { def: t, path: e.currentPath, jsonSchema: void 0 };
    e.seen.set(t, n);
    const s = lI(t, t.typeName, e),
      o = typeof s == "function" ? He(s(), e) : s;
    if ((o && uI(t, e, o), e.postProcess)) {
      const l = e.postProcess(o, t, e);
      return (n.jsonSchema = o), l;
    }
    return (n.jsonSchema = o), o;
  }
  const cI = (t, e) => {
      switch (e.$refStrategy) {
        case "root":
          return { $ref: t.path.join("/") };
        case "relative":
          return { $ref: Mm(e.currentPath, t.path) };
        case "none":
        case "seen":
          return t.path.length < e.currentPath.length &&
            t.path.every((r, a) => e.currentPath[a] === r)
            ? (console.warn(
                `Recursive reference detected at ${e.currentPath.join(
                  "/"
                )}! Defaulting to any`
              ),
              Qt(e))
            : e.$refStrategy === "seen"
            ? Qt(e)
            : void 0;
      }
    },
    uI = (t, e, r) => (
      t.description &&
        ((r.description = t.description),
        e.markdownDescription && (r.markdownDescription = t.description)),
      r
    ),
    Ku = (t, e) => {
      const r = Cx(e);
      let a =
        typeof e == "object" && e.definitions
          ? Object.entries(e.definitions).reduce(
              (l, [c, u]) => ({
                ...l,
                [c]:
                  He(
                    u._def,
                    { ...r, currentPath: [...r.basePath, r.definitionPath, c] },
                    !0
                  ) ?? Qt(r),
              }),
              {}
            )
          : void 0;
      const n =
          typeof e == "string"
            ? e
            : (e == null ? void 0 : e.nameStrategy) === "title" || e == null
            ? void 0
            : e.name,
        s =
          He(
            t._def,
            n === void 0
              ? r
              : { ...r, currentPath: [...r.basePath, r.definitionPath, n] },
            !1
          ) ?? Qt(r),
        o =
          typeof e == "object" &&
          e.name !== void 0 &&
          e.nameStrategy === "title"
            ? e.name
            : void 0;
      o !== void 0 && (s.title = o),
        r.flags.hasReferencedOpenAiAnyType &&
          (a || (a = {}),
          a[r.openAiAnyTypeName] ||
            (a[r.openAiAnyTypeName] = {
              type: ["string", "number", "integer", "boolean", "array", "null"],
              items: {
                $ref:
                  r.$refStrategy === "relative"
                    ? "1"
                    : [
                        ...r.basePath,
                        r.definitionPath,
                        r.openAiAnyTypeName,
                      ].join("/"),
              },
            }));
      const i =
        n === void 0
          ? a
            ? { ...s, [r.definitionPath]: a }
            : s
          : {
              $ref: [
                ...(r.$refStrategy === "relative" ? [] : r.basePath),
                r.definitionPath,
                n,
              ].join("/"),
              [r.definitionPath]: { ...a, [n]: s },
            };
      return (
        r.target === "jsonSchema7"
          ? (i.$schema = "http://json-schema.org/draft-07/schema#")
          : (r.target === "jsonSchema2019-09" || r.target === "openAi") &&
            (i.$schema = "https://json-schema.org/draft/2019-09/schema#"),
        r.target === "openAi" &&
          ("anyOf" in i ||
            "oneOf" in i ||
            "allOf" in i ||
            ("type" in i && Array.isArray(i.type))) &&
          console.warn(
            "Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."
          ),
        i
      );
    };
  var Gu;
  (function (t) {
    t.Completable = "McpCompletable";
  })(Gu || (Gu = {}));
  class Ci extends Oe {
    _parse(e) {
      const { ctx: r } = this._processInputParams(e),
        a = r.data;
      return this._def.type._parse({ data: a, path: r.path, parent: r });
    }
    unwrap() {
      return this._def.type;
    }
  }
  Ci.create = (t, e) =>
    new Ci({
      type: t,
      typeName: Gu.Completable,
      complete: e.complete,
      ...fI(e),
    });
  function dI(t, e) {
    return Ci.create(t, { ...t._def, complete: e });
  }
  function fI(t) {
    if (!t) return {};
    const {
      errorMap: e,
      invalid_type_error: r,
      required_error: a,
      description: n,
    } = t;
    if (e && (r || a))
      throw new Error(
        `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
      );
    return e
      ? { errorMap: e, description: n }
      : {
          errorMap: (o, i) => {
            var l, c;
            const { message: u } = t;
            return o.code === "invalid_enum_value"
              ? { message: u ?? i.defaultError }
              : typeof i.data > "u"
              ? {
                  message:
                    (l = u ?? a) !== null && l !== void 0 ? l : i.defaultError,
                }
              : o.code !== "invalid_type"
              ? { message: i.defaultError }
              : {
                  message:
                    (c = u ?? r) !== null && c !== void 0 ? c : i.defaultError,
                };
          },
          description: n,
        };
  }
  const Fm = 1e6,
    Wu = 1e6,
    Vm = 1e4,
    pI = 1e6;
  class sn {
    static isTemplate(e) {
      return /\{[^}\s]+\}/.test(e);
    }
    static validateLength(e, r, a) {
      if (e.length > r)
        throw new Error(
          `${a} exceeds maximum length of ${r} characters (got ${e.length})`
        );
    }
    get variableNames() {
      return this.parts.flatMap((e) => (typeof e == "string" ? [] : e.names));
    }
    constructor(e) {
      sn.validateLength(e, Fm, "Template"),
        (this.template = e),
        (this.parts = this.parse(e));
    }
    toString() {
      return this.template;
    }
    parse(e) {
      const r = [];
      let a = "",
        n = 0,
        s = 0;
      for (; n < e.length; )
        if (e[n] === "{") {
          a && (r.push(a), (a = ""));
          const o = e.indexOf("}", n);
          if (o === -1) throw new Error("Unclosed template expression");
          if ((s++, s > Vm))
            throw new Error(
              `Template contains too many expressions (max ${Vm})`
            );
          const i = e.slice(n + 1, o),
            l = this.getOperator(i),
            c = i.includes("*"),
            u = this.getNames(i),
            f = u[0];
          for (const v of u) sn.validateLength(v, Wu, "Variable name");
          r.push({ name: f, operator: l, names: u, exploded: c }), (n = o + 1);
        } else (a += e[n]), n++;
      return a && r.push(a), r;
    }
    getOperator(e) {
      return ["+", "#", ".", "/", "?", "&"].find((a) => e.startsWith(a)) || "";
    }
    getNames(e) {
      const r = this.getOperator(e);
      return e
        .slice(r.length)
        .split(",")
        .map((a) => a.replace("*", "").trim())
        .filter((a) => a.length > 0);
    }
    encodeValue(e, r) {
      return (
        sn.validateLength(e, Wu, "Variable value"),
        r === "+" || r === "#" ? encodeURI(e) : encodeURIComponent(e)
      );
    }
    expandPart(e, r) {
      if (e.operator === "?" || e.operator === "&") {
        const o = e.names
          .map((l) => {
            const c = r[l];
            if (c === void 0) return "";
            const u = Array.isArray(c)
              ? c.map((f) => this.encodeValue(f, e.operator)).join(",")
              : this.encodeValue(c.toString(), e.operator);
            return `${l}=${u}`;
          })
          .filter((l) => l.length > 0);
        return o.length === 0
          ? ""
          : (e.operator === "?" ? "?" : "&") + o.join("&");
      }
      if (e.names.length > 1) {
        const o = e.names.map((i) => r[i]).filter((i) => i !== void 0);
        return o.length === 0
          ? ""
          : o.map((i) => (Array.isArray(i) ? i[0] : i)).join(",");
      }
      const a = r[e.name];
      if (a === void 0) return "";
      const s = (Array.isArray(a) ? a : [a]).map((o) =>
        this.encodeValue(o, e.operator)
      );
      switch (e.operator) {
        case "":
          return s.join(",");
        case "+":
          return s.join(",");
        case "#":
          return "#" + s.join(",");
        case ".":
          return "." + s.join(".");
        case "/":
          return "/" + s.join("/");
        default:
          return s.join(",");
      }
    }
    expand(e) {
      let r = "",
        a = !1;
      for (const n of this.parts) {
        if (typeof n == "string") {
          r += n;
          continue;
        }
        const s = this.expandPart(n, e);
        s &&
          ((n.operator === "?" || n.operator === "&") && a
            ? (r += s.replace("?", "&"))
            : (r += s),
          (n.operator === "?" || n.operator === "&") && (a = !0));
      }
      return r;
    }
    escapeRegExp(e) {
      return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    partToRegExp(e) {
      const r = [];
      for (const s of e.names) sn.validateLength(s, Wu, "Variable name");
      if (e.operator === "?" || e.operator === "&") {
        for (let s = 0; s < e.names.length; s++) {
          const o = e.names[s],
            i = s === 0 ? "\\" + e.operator : "&";
          r.push({ pattern: i + this.escapeRegExp(o) + "=([^&]+)", name: o });
        }
        return r;
      }
      let a;
      const n = e.name;
      switch (e.operator) {
        case "":
          a = e.exploded ? "([^/]+(?:,[^/]+)*)" : "([^/,]+)";
          break;
        case "+":
        case "#":
          a = "(.+)";
          break;
        case ".":
          a = "\\.([^/,]+)";
          break;
        case "/":
          a = "/" + (e.exploded ? "([^/]+(?:,[^/]+)*)" : "([^/,]+)");
          break;
        default:
          a = "([^/]+)";
      }
      return r.push({ pattern: a, name: n }), r;
    }
    match(e) {
      sn.validateLength(e, Fm, "URI");
      let r = "^";
      const a = [];
      for (const i of this.parts)
        if (typeof i == "string") r += this.escapeRegExp(i);
        else {
          const l = this.partToRegExp(i);
          for (const { pattern: c, name: u } of l)
            (r += c), a.push({ name: u, exploded: i.exploded });
        }
      (r += "$"), sn.validateLength(r, pI, "Generated regex pattern");
      const n = new RegExp(r),
        s = e.match(n);
      if (!s) return null;
      const o = {};
      for (let i = 0; i < a.length; i++) {
        const { name: l, exploded: c } = a[i],
          u = s[i + 1],
          f = l.replace("*", "");
        c && u.includes(",") ? (o[f] = u.split(",")) : (o[f] = u);
      }
      return o;
    }
  }
  class Zm {
    constructor(e, r) {
      (this._registeredResources = {}),
        (this._registeredResourceTemplates = {}),
        (this._registeredTools = {}),
        (this._registeredPrompts = {}),
        (this._toolHandlersInitialized = !1),
        (this._completionHandlerInitialized = !1),
        (this._resourceHandlersInitialized = !1),
        (this._promptHandlersInitialized = !1),
        (this.server = new xx(e, r));
    }
    async connect(e) {
      return await this.server.connect(e);
    }
    async close() {
      await this.server.close();
    }
    setToolRequestHandlers() {
      this._toolHandlersInitialized ||
        (this.server.assertCanSetRequestHandler(Uc.shape.method.value),
        this.server.assertCanSetRequestHandler(Fc.shape.method.value),
        this.server.registerCapabilities({ tools: { listChanged: !0 } }),
        this.server.setRequestHandler(Uc, () => ({
          tools: Object.entries(this._registeredTools)
            .filter(([, e]) => e.enabled)
            .map(([e, r]) => {
              const a = {
                name: e,
                title: r.title,
                description: r.description,
                inputSchema: r.inputSchema
                  ? Ku(r.inputSchema, { strictUnions: !0 })
                  : mI,
                annotations: r.annotations,
              };
              return (
                r.outputSchema &&
                  (a.outputSchema = Ku(r.outputSchema, { strictUnions: !0 })),
                a
              );
            }),
        })),
        this.server.setRequestHandler(Fc, async (e, r) => {
          const a = this._registeredTools[e.params.name];
          if (!a)
            throw new st(rt.InvalidParams, `Tool ${e.params.name} not found`);
          if (!a.enabled)
            throw new st(rt.InvalidParams, `Tool ${e.params.name} disabled`);
          let n;
          if (a.inputSchema) {
            const s = await a.inputSchema.safeParseAsync(e.params.arguments);
            if (!s.success)
              throw new st(
                rt.InvalidParams,
                `Invalid arguments for tool ${e.params.name}: ${s.error.message}`
              );
            const o = s.data,
              i = a.callback;
            try {
              n = await Promise.resolve(i(o, r));
            } catch (l) {
              n = {
                content: [
                  {
                    type: "text",
                    text: l instanceof Error ? l.message : String(l),
                  },
                ],
                isError: !0,
              };
            }
          } else {
            const s = a.callback;
            try {
              n = await Promise.resolve(s(r));
            } catch (o) {
              n = {
                content: [
                  {
                    type: "text",
                    text: o instanceof Error ? o.message : String(o),
                  },
                ],
                isError: !0,
              };
            }
          }
          if (a.outputSchema && !n.isError) {
            if (!n.structuredContent)
              throw new st(
                rt.InvalidParams,
                `Tool ${e.params.name} has an output schema but no structured content was provided`
              );
            const s = await a.outputSchema.safeParseAsync(n.structuredContent);
            if (!s.success)
              throw new st(
                rt.InvalidParams,
                `Invalid structured content for tool ${e.params.name}: ${s.error.message}`
              );
          }
          return n;
        }),
        (this._toolHandlersInitialized = !0));
    }
    setCompletionRequestHandler() {
      this._completionHandlerInitialized ||
        (this.server.assertCanSetRequestHandler(Bc.shape.method.value),
        this.server.registerCapabilities({ completions: {} }),
        this.server.setRequestHandler(Bc, async (e) => {
          switch (e.params.ref.type) {
            case "ref/prompt":
              return this.handlePromptCompletion(e, e.params.ref);
            case "ref/resource":
              return this.handleResourceCompletion(e, e.params.ref);
            default:
              throw new st(
                rt.InvalidParams,
                `Invalid completion reference: ${e.params.ref}`
              );
          }
        }),
        (this._completionHandlerInitialized = !0));
    }
    async handlePromptCompletion(e, r) {
      const a = this._registeredPrompts[r.name];
      if (!a) throw new st(rt.InvalidParams, `Prompt ${r.name} not found`);
      if (!a.enabled)
        throw new st(rt.InvalidParams, `Prompt ${r.name} disabled`);
      if (!a.argsSchema) return Ri;
      const n = a.argsSchema.shape[e.params.argument.name];
      if (!(n instanceof Ci)) return Ri;
      const o = await n._def.complete(
        e.params.argument.value,
        e.params.context
      );
      return Bm(o);
    }
    async handleResourceCompletion(e, r) {
      const a = Object.values(this._registeredResourceTemplates).find(
        (o) => o.resourceTemplate.uriTemplate.toString() === r.uri
      );
      if (!a) {
        if (this._registeredResources[r.uri]) return Ri;
        throw new st(
          rt.InvalidParams,
          `Resource template ${e.params.ref.uri} not found`
        );
      }
      const n = a.resourceTemplate.completeCallback(e.params.argument.name);
      if (!n) return Ri;
      const s = await n(e.params.argument.value, e.params.context);
      return Bm(s);
    }
    setResourceRequestHandlers() {
      this._resourceHandlersInitialized ||
        (this.server.assertCanSetRequestHandler(Qo.shape.method.value),
        this.server.assertCanSetRequestHandler(Nc.shape.method.value),
        this.server.assertCanSetRequestHandler(Mc.shape.method.value),
        this.server.registerCapabilities({ resources: { listChanged: !0 } }),
        this.server.setRequestHandler(Qo, async (e, r) => {
          const a = Object.entries(this._registeredResources)
              .filter(([s, o]) => o.enabled)
              .map(([s, o]) => ({ uri: s, name: o.name, ...o.metadata })),
            n = [];
          for (const s of Object.values(this._registeredResourceTemplates)) {
            if (!s.resourceTemplate.listCallback) continue;
            const o = await s.resourceTemplate.listCallback(r);
            for (const i of o.resources) n.push({ ...s.metadata, ...i });
          }
          return { resources: [...a, ...n] };
        }),
        this.server.setRequestHandler(Nc, async () => ({
          resourceTemplates: Object.entries(
            this._registeredResourceTemplates
          ).map(([r, a]) => ({
            name: r,
            uriTemplate: a.resourceTemplate.uriTemplate.toString(),
            ...a.metadata,
          })),
        })),
        this.server.setRequestHandler(Mc, async (e, r) => {
          const a = new URL(e.params.uri),
            n = this._registeredResources[a.toString()];
          if (n) {
            if (!n.enabled)
              throw new st(rt.InvalidParams, `Resource ${a} disabled`);
            return n.readCallback(a, r);
          }
          for (const s of Object.values(this._registeredResourceTemplates)) {
            const o = s.resourceTemplate.uriTemplate.match(a.toString());
            if (o) return s.readCallback(a, o, r);
          }
          throw new st(rt.InvalidParams, `Resource ${a} not found`);
        }),
        this.setCompletionRequestHandler(),
        (this._resourceHandlersInitialized = !0));
    }
    setPromptRequestHandlers() {
      this._promptHandlersInitialized ||
        (this.server.assertCanSetRequestHandler(jc.shape.method.value),
        this.server.assertCanSetRequestHandler(Dc.shape.method.value),
        this.server.registerCapabilities({ prompts: { listChanged: !0 } }),
        this.server.setRequestHandler(jc, () => ({
          prompts: Object.entries(this._registeredPrompts)
            .filter(([, e]) => e.enabled)
            .map(([e, r]) => ({
              name: e,
              title: r.title,
              description: r.description,
              arguments: r.argsSchema ? gI(r.argsSchema) : void 0,
            })),
        })),
        this.server.setRequestHandler(Dc, async (e, r) => {
          const a = this._registeredPrompts[e.params.name];
          if (!a)
            throw new st(rt.InvalidParams, `Prompt ${e.params.name} not found`);
          if (!a.enabled)
            throw new st(rt.InvalidParams, `Prompt ${e.params.name} disabled`);
          if (a.argsSchema) {
            const n = await a.argsSchema.safeParseAsync(e.params.arguments);
            if (!n.success)
              throw new st(
                rt.InvalidParams,
                `Invalid arguments for prompt ${e.params.name}: ${n.error.message}`
              );
            const s = n.data,
              o = a.callback;
            return await Promise.resolve(o(s, r));
          } else {
            const n = a.callback;
            return await Promise.resolve(n(r));
          }
        }),
        this.setCompletionRequestHandler(),
        (this._promptHandlersInitialized = !0));
    }
    resource(e, r, ...a) {
      let n;
      typeof a[0] == "object" && (n = a.shift());
      const s = a[0];
      if (typeof r == "string") {
        if (this._registeredResources[r])
          throw new Error(`Resource ${r} is already registered`);
        const o = this._createRegisteredResource(e, void 0, r, n, s);
        return (
          this.setResourceRequestHandlers(), this.sendResourceListChanged(), o
        );
      } else {
        if (this._registeredResourceTemplates[e])
          throw new Error(`Resource template ${e} is already registered`);
        const o = this._createRegisteredResourceTemplate(e, void 0, r, n, s);
        return (
          this.setResourceRequestHandlers(), this.sendResourceListChanged(), o
        );
      }
    }
    registerResource(e, r, a, n) {
      if (typeof r == "string") {
        if (this._registeredResources[r])
          throw new Error(`Resource ${r} is already registered`);
        const s = this._createRegisteredResource(e, a.title, r, a, n);
        return (
          this.setResourceRequestHandlers(), this.sendResourceListChanged(), s
        );
      } else {
        if (this._registeredResourceTemplates[e])
          throw new Error(`Resource template ${e} is already registered`);
        const s = this._createRegisteredResourceTemplate(e, a.title, r, a, n);
        return (
          this.setResourceRequestHandlers(), this.sendResourceListChanged(), s
        );
      }
    }
    _createRegisteredResource(e, r, a, n, s) {
      const o = {
        name: e,
        title: r,
        metadata: n,
        readCallback: s,
        enabled: !0,
        disable: () => o.update({ enabled: !1 }),
        enable: () => o.update({ enabled: !0 }),
        remove: () => o.update({ uri: null }),
        update: (i) => {
          typeof i.uri < "u" &&
            i.uri !== a &&
            (delete this._registeredResources[a],
            i.uri && (this._registeredResources[i.uri] = o)),
            typeof i.name < "u" && (o.name = i.name),
            typeof i.title < "u" && (o.title = i.title),
            typeof i.metadata < "u" && (o.metadata = i.metadata),
            typeof i.callback < "u" && (o.readCallback = i.callback),
            typeof i.enabled < "u" && (o.enabled = i.enabled),
            this.sendResourceListChanged();
        },
      };
      return (this._registeredResources[a] = o), o;
    }
    _createRegisteredResourceTemplate(e, r, a, n, s) {
      const o = {
        resourceTemplate: a,
        title: r,
        metadata: n,
        readCallback: s,
        enabled: !0,
        disable: () => o.update({ enabled: !1 }),
        enable: () => o.update({ enabled: !0 }),
        remove: () => o.update({ name: null }),
        update: (i) => {
          typeof i.name < "u" &&
            i.name !== e &&
            (delete this._registeredResourceTemplates[e],
            i.name && (this._registeredResourceTemplates[i.name] = o)),
            typeof i.title < "u" && (o.title = i.title),
            typeof i.template < "u" && (o.resourceTemplate = i.template),
            typeof i.metadata < "u" && (o.metadata = i.metadata),
            typeof i.callback < "u" && (o.readCallback = i.callback),
            typeof i.enabled < "u" && (o.enabled = i.enabled),
            this.sendResourceListChanged();
        },
      };
      return (this._registeredResourceTemplates[e] = o), o;
    }
    _createRegisteredPrompt(e, r, a, n, s) {
      const o = {
        title: r,
        description: a,
        argsSchema: n === void 0 ? void 0 : re(n),
        callback: s,
        enabled: !0,
        disable: () => o.update({ enabled: !1 }),
        enable: () => o.update({ enabled: !0 }),
        remove: () => o.update({ name: null }),
        update: (i) => {
          typeof i.name < "u" &&
            i.name !== e &&
            (delete this._registeredPrompts[e],
            i.name && (this._registeredPrompts[i.name] = o)),
            typeof i.title < "u" && (o.title = i.title),
            typeof i.description < "u" && (o.description = i.description),
            typeof i.argsSchema < "u" && (o.argsSchema = re(i.argsSchema)),
            typeof i.callback < "u" && (o.callback = i.callback),
            typeof i.enabled < "u" && (o.enabled = i.enabled),
            this.sendPromptListChanged();
        },
      };
      return (this._registeredPrompts[e] = o), o;
    }
    _createRegisteredTool(e, r, a, n, s, o, i) {
      const l = {
        title: r,
        description: a,
        inputSchema: n === void 0 ? void 0 : re(n),
        outputSchema: s === void 0 ? void 0 : re(s),
        annotations: o,
        callback: i,
        enabled: !0,
        disable: () => l.update({ enabled: !1 }),
        enable: () => l.update({ enabled: !0 }),
        remove: () => l.update({ name: null }),
        update: (c) => {
          typeof c.name < "u" &&
            c.name !== e &&
            (delete this._registeredTools[e],
            c.name && (this._registeredTools[c.name] = l)),
            typeof c.title < "u" && (l.title = c.title),
            typeof c.description < "u" && (l.description = c.description),
            typeof c.paramsSchema < "u" && (l.inputSchema = re(c.paramsSchema)),
            typeof c.callback < "u" && (l.callback = c.callback),
            typeof c.annotations < "u" && (l.annotations = c.annotations),
            typeof c.enabled < "u" && (l.enabled = c.enabled),
            this.sendToolListChanged();
        },
      };
      return (
        (this._registeredTools[e] = l),
        this.setToolRequestHandlers(),
        this.sendToolListChanged(),
        l
      );
    }
    tool(e, ...r) {
      if (this._registeredTools[e])
        throw new Error(`Tool ${e} is already registered`);
      let a, n, s, o;
      if ((typeof r[0] == "string" && (a = r.shift()), r.length > 1)) {
        const l = r[0];
        Hm(l)
          ? ((n = r.shift()),
            r.length > 1 &&
              typeof r[0] == "object" &&
              r[0] !== null &&
              !Hm(r[0]) &&
              (o = r.shift()))
          : typeof l == "object" && l !== null && (o = r.shift());
      }
      const i = r[0];
      return this._createRegisteredTool(e, void 0, a, n, s, o, i);
    }
    registerTool(e, r, a) {
      if (this._registeredTools[e])
        throw new Error(`Tool ${e} is already registered`);
      const {
        title: n,
        description: s,
        inputSchema: o,
        outputSchema: i,
        annotations: l,
      } = r;
      return this._createRegisteredTool(e, n, s, o, i, l, a);
    }
    prompt(e, ...r) {
      if (this._registeredPrompts[e])
        throw new Error(`Prompt ${e} is already registered`);
      let a;
      typeof r[0] == "string" && (a = r.shift());
      let n;
      r.length > 1 && (n = r.shift());
      const s = r[0],
        o = this._createRegisteredPrompt(e, void 0, a, n, s);
      return this.setPromptRequestHandlers(), this.sendPromptListChanged(), o;
    }
    registerPrompt(e, r, a) {
      if (this._registeredPrompts[e])
        throw new Error(`Prompt ${e} is already registered`);
      const { title: n, description: s, argsSchema: o } = r,
        i = this._createRegisteredPrompt(e, n, s, o, a);
      return this.setPromptRequestHandlers(), this.sendPromptListChanged(), i;
    }
    isConnected() {
      return this.server.transport !== void 0;
    }
    sendResourceListChanged() {
      this.isConnected() && this.server.sendResourceListChanged();
    }
    sendToolListChanged() {
      this.isConnected() && this.server.sendToolListChanged();
    }
    sendPromptListChanged() {
      this.isConnected() && this.server.sendPromptListChanged();
    }
  }
  class hI {
    constructor(e, r) {
      (this._callbacks = r),
        (this._uriTemplate = typeof e == "string" ? new sn(e) : e);
    }
    get uriTemplate() {
      return this._uriTemplate;
    }
    get listCallback() {
      return this._callbacks.list;
    }
    completeCallback(e) {
      var r;
      return (r = this._callbacks.complete) === null || r === void 0
        ? void 0
        : r[e];
    }
  }
  const mI = { type: "object", properties: {} };
  function Hm(t) {
    return typeof t != "object" || t === null
      ? !1
      : Object.keys(t).length === 0 || Object.values(t).some(vI);
  }
  function vI(t) {
    return (
      t !== null &&
      typeof t == "object" &&
      "parse" in t &&
      typeof t.parse == "function" &&
      "safeParse" in t &&
      typeof t.safeParse == "function"
    );
  }
  function gI(t) {
    return Object.entries(t.shape).map(([e, r]) => ({
      name: e,
      description: r.description,
      required: !r.isOptional(),
    }));
  }
  function Bm(t) {
    return {
      completion: {
        values: t.slice(0, 100),
        total: t.length,
        hasMore: t.length > 100,
      },
    };
  }
  const Ri = { completion: { values: [], hasMore: !1 } };
  function yI(t) {
    var e;
    if (t.title !== void 0 && t.title !== "") return t.title;
    if ("annotations" in t) {
      const r = t;
      if (!((e = r.annotations) === null || e === void 0) && e.title)
        return r.annotations.title;
    }
    return t.name;
  }
  class _I {
    constructor(e, r) {
      const a = { name: "web-mcp-server", version: "1.0.0" },
        n = {
          prompts: { listChanged: !0 },
          resources: { subscribe: !0, listChanged: !0 },
          tools: { listChanged: !0 },
          completions: {},
          logging: {},
        };
      (this.server = new Zm(e || a, r || { capabilities: n })),
        (this.server.server.oninitialized = () => {
          var s;
          (s = this.oninitialized) == null || s.call(this);
        }),
        (this.server.server.onclose = () => {
          var s;
          (s = this.onclose) == null || s.call(this);
        }),
        (this.server.server.onerror = (s) => {
          var o;
          (o = this.onerror) == null || o.call(this, s);
        }),
        this.server.server.setRequestHandler(Vc, async () => ({}));
    }
    async connect(e) {
      return (
        typeof e.start == "function"
          ? ((this.transport = e),
            (this.transport.onclose = void 0),
            (this.transport.onerror = void 0),
            (this.transport.onmessage = void 0))
          : ((this.transport = new Vu(e)), await this.transport.listen()),
        await this.server.connect(this.transport),
        this.transport
      );
    }
    async close() {
      await this.server.close();
    }
    registerTool(e, r, a) {
      return this.server.registerTool(e, r, a);
    }
    registerPrompt(e, r, a) {
      return this.server.registerPrompt(e, r, a);
    }
    registerResource(e, r, a, n) {
      return typeof r == "string"
        ? this.server.registerResource(e, r, a, n)
        : this.server.registerResource(e, r, a, n);
    }
    isConnected() {
      return this.server.isConnected();
    }
    sendResourceListChanged() {
      this.server.sendResourceListChanged();
    }
    sendToolListChanged() {
      this.server.sendToolListChanged();
    }
    sendPromptListChanged() {
      this.server.sendPromptListChanged();
    }
    getClientCapabilities() {
      return this.server.server.getClientCapabilities();
    }
    getClientVersion() {
      return this.server.server.getClientVersion();
    }
    async ping() {
      return await this.server.server.ping();
    }
    async createMessage(e, r) {
      return await this.server.server.createMessage(e, r);
    }
    async elicitInput(e, r) {
      return await this.server.server.elicitInput(e, r);
    }
    async listRoots(e, r) {
      return await this.server.server.listRoots(e, r);
    }
    async sendLoggingMessage(e) {
      return await this.server.server.sendLoggingMessage(e);
    }
    async sendResourceUpdated(e) {
      return await this.server.server.sendResourceUpdated(e);
    }
    request(e, r, a) {
      return this.server.server.request(e, r, a);
    }
    async notification(e, r) {
      return await this.server.server.notification(e, r);
    }
    setRequestHandler(e, r) {
      this.server.server.setRequestHandler(e, r);
    }
    removeRequestHandler(e) {
      this.server.server.removeRequestHandler(e);
    }
    setNotificationHandler(e, r) {
      this.server.server.setNotificationHandler(e, r);
    }
    removeNotificationHandler(e) {
      this.server.server.removeNotificationHandler(e);
    }
    onSubscribe(e) {
      this.server.server.setRequestHandler(dh, e);
    }
    onUnsubscribe(e) {
      this.server.server.setRequestHandler(fh, e);
    }
    onSetLogLevel(e) {
      this.server.server.setRequestHandler(Vc, e);
    }
    onListResources(e) {
      this.server.server.setRequestHandler(Qo, e);
    }
    onRootsListChanged(e) {
      this.server.server.setNotificationHandler(Th, e);
    }
    async onPagehide(e) {
      e.persisted ||
        (this.transport &&
          typeof this.transport.close == "function" &&
          (await this.transport.close()));
    }
  }
  const wI = (t, e) => new Vu(t, e),
    bI = () => cx(),
    EI = (t) => t instanceof Vu,
    SI = (t) => t instanceof Zm;
  class $I {
    constructor(e, r) {
      const a = { name: "web-mcp-client", version: "1.0.0" },
        n = { roots: { listChanged: !0 }, sampling: {}, elicitation: {} };
      (this.client = new pi(e || a, r || { capabilities: n })),
        (this.client.onclose = () => {
          var s;
          (s = this.onclose) == null || s.call(this);
        }),
        (this.client.onerror = (s) => {
          var o;
          (o = this.onerror) == null || o.call(this, s);
        });
    }
    async connect(e) {
      if (typeof e.start == "function")
        return (
          (this.transport = e),
          (this.transport.onclose = void 0),
          (this.transport.onerror = void 0),
          (this.transport.onmessage = void 0),
          await this.client.connect(this.transport),
          { transport: this.transport, sessionId: this.transport.sessionId }
        );
      const {
        url: r,
        token: a,
        sessionId: n,
        authProvider: s,
        type: o,
        agent: i,
        onError: l,
        onUnauthorized: c,
        onReconnect: u,
      } = e;
      if (i === !0) {
        const d = {
          client: this.client,
          url: r,
          token: a,
          sessionId: n,
          authProvider: s,
        };
        let p = !1,
          g;
        const m = async () => {
          const { transport: h, sessionId: y } =
            o === "sse" ? await Sx(d) : await $x(d);
          (h.onerror = async (_) => {
            l == null || l(_),
              _.message === "Unauthorized" &&
                !p &&
                (typeof c == "function"
                  ? await c(m)
                  : ((p = !0),
                    await m(),
                    (p = !1),
                    await (u == null ? void 0 : u())));
          }),
            (g = { transport: h, sessionId: y });
        };
        return await m(), g;
      }
      const f = new URL(r);
      let v;
      if (
        (o === "channel" && ((v = new Fu(r)), await this.client.connect(v)),
        o === "sse")
      )
        if (s) {
          const d = () => new Ra(f, { authProvider: s });
          v = await Rs(this.client, s.waitForOAuthCode, d);
        } else {
          const d = Cm(a, n);
          (v = new Ra(f, d)), await this.client.connect(v);
        }
      if (typeof v > "u")
        if (s) {
          const d = () => new Oa(f, { authProvider: s });
          v = await Rs(this.client, s.waitForOAuthCode, d);
        } else {
          const d = Rm(a, n);
          (v = new Oa(f, d)), await this.client.connect(v);
        }
      return (
        (this.transport = v),
        { transport: this.transport, sessionId: this.transport.sessionId }
      );
    }
    async close() {
      await this.client.close();
    }
    getServerCapabilities() {
      return this.client.getServerCapabilities();
    }
    getServerVersion() {
      return this.client.getServerVersion();
    }
    getInstructions() {
      return this.client.getInstructions();
    }
    async ping(e) {
      return await this.client.ping(e);
    }
    async complete(e, r) {
      return await this.client.complete(e, r);
    }
    async setLoggingLevel(e, r) {
      return await this.client.setLoggingLevel(e, r);
    }
    async getPrompt(e, r) {
      return await this.client.getPrompt(e, r);
    }
    async listPrompts(e, r) {
      return await this.client.listPrompts(e, r);
    }
    async listResources(e, r) {
      return await this.client.listResources(e, r);
    }
    async listResourceTemplates(e, r) {
      return await this.client.listResourceTemplates(e, r);
    }
    async readResource(e, r) {
      return await this.client.readResource(e, r);
    }
    async subscribeResource(e, r) {
      return await this.client.subscribeResource(e, r);
    }
    async unsubscribeResource(e, r) {
      return await this.client.unsubscribeResource(e, r);
    }
    async callTool(e, r) {
      return await this.client.callTool(e, Yo, r);
    }
    async listTools(e, r) {
      return await this.client.listTools(e, r);
    }
    async sendRootsListChanged() {
      return await this.client.sendRootsListChanged();
    }
    request(e, r, a) {
      return this.client.request(e, r, a);
    }
    async notification(e, r) {
      return await this.client.notification(e, r);
    }
    setRequestHandler(e, r) {
      this.client.setRequestHandler(e, r);
    }
    removeRequestHandler(e) {
      this.client.removeRequestHandler(e);
    }
    setNotificationHandler(e, r) {
      this.client.setNotificationHandler(e, r);
    }
    removeNotificationHandler(e) {
      this.client.removeNotificationHandler(e);
    }
    onElicit(e) {
      this.client.setRequestHandler(Sh, e);
    }
    onCreateMessage(e) {
      this.client.setRequestHandler(Eh, e);
    }
    onListRoots(e) {
      this.client.setRequestHandler(Ph, e);
    }
    onToolListChanged(e) {
      this.client.setNotificationHandler(_h, e);
    }
    onPromptListChanged(e) {
      this.client.setNotificationHandler(gh, e);
    }
    onResourceListChanged(e) {
      this.client.setNotificationHandler(uh, e);
    }
    onResourceUpdated(e) {
      this.client.setNotificationHandler(ph, e);
    }
    onLoggingMessage(e) {
      this.client.setNotificationHandler(bh, e);
    }
    async onPagehide(e) {
      e.persisted ||
        (Jm(this.transport)
          ? await this.transport.terminateSession()
          : this.transport &&
            typeof this.transport.close == "function" &&
            (await this.transport.close()));
    }
  }
  const PI = (t, e) => new Ra(t, e),
    TI = (t, e) => new Oa(t, e),
    xI = (t, e) => new Fu(t, e),
    II = (t) => t instanceof Ra,
    Jm = (t) => t instanceof Oa,
    kI = (t) => t instanceof Fu,
    CI = (t) => t instanceof pi;
  var Aa = {},
    RI = function () {
      return (
        typeof Promise == "function" &&
        Promise.prototype &&
        Promise.prototype.then
      );
    },
    Km = {},
    rr = {};
  let Qu;
  const OI = [
    0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655,
    733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921,
    2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706,
  ];
  (rr.getSymbolSize = function (e) {
    if (!e) throw new Error('"version" cannot be null or undefined');
    if (e < 1 || e > 40)
      throw new Error('"version" should be in range from 1 to 40');
    return e * 4 + 17;
  }),
    (rr.getSymbolTotalCodewords = function (e) {
      return OI[e];
    }),
    (rr.getBCHDigit = function (t) {
      let e = 0;
      for (; t !== 0; ) e++, (t >>>= 1);
      return e;
    }),
    (rr.setToSJISFunction = function (e) {
      if (typeof e != "function")
        throw new Error('"toSJISFunc" is not a valid function.');
      Qu = e;
    }),
    (rr.isKanjiModeEnabled = function () {
      return typeof Qu < "u";
    }),
    (rr.toSJIS = function (e) {
      return Qu(e);
    });
  var Oi = {};
  (function (t) {
    (t.L = { bit: 1 }),
      (t.M = { bit: 0 }),
      (t.Q = { bit: 3 }),
      (t.H = { bit: 2 });
    function e(r) {
      if (typeof r != "string") throw new Error("Param is not a string");
      switch (r.toLowerCase()) {
        case "l":
        case "low":
          return t.L;
        case "m":
        case "medium":
          return t.M;
        case "q":
        case "quartile":
          return t.Q;
        case "h":
        case "high":
          return t.H;
        default:
          throw new Error("Unknown EC Level: " + r);
      }
    }
    (t.isValid = function (a) {
      return a && typeof a.bit < "u" && a.bit >= 0 && a.bit < 4;
    }),
      (t.from = function (a, n) {
        if (t.isValid(a)) return a;
        try {
          return e(a);
        } catch {
          return n;
        }
      });
  })(Oi);
  function Gm() {
    (this.buffer = []), (this.length = 0);
  }
  Gm.prototype = {
    get: function (t) {
      const e = Math.floor(t / 8);
      return ((this.buffer[e] >>> (7 - (t % 8))) & 1) === 1;
    },
    put: function (t, e) {
      for (let r = 0; r < e; r++) this.putBit(((t >>> (e - r - 1)) & 1) === 1);
    },
    getLengthInBits: function () {
      return this.length;
    },
    putBit: function (t) {
      const e = Math.floor(this.length / 8);
      this.buffer.length <= e && this.buffer.push(0),
        t && (this.buffer[e] |= 128 >>> this.length % 8),
        this.length++;
    },
  };
  var AI = Gm;
  function Os(t) {
    if (!t || t < 1)
      throw new Error("BitMatrix size must be defined and greater than 0");
    (this.size = t),
      (this.data = new Uint8Array(t * t)),
      (this.reservedBit = new Uint8Array(t * t));
  }
  (Os.prototype.set = function (t, e, r, a) {
    const n = t * this.size + e;
    (this.data[n] = r), a && (this.reservedBit[n] = !0);
  }),
    (Os.prototype.get = function (t, e) {
      return this.data[t * this.size + e];
    }),
    (Os.prototype.xor = function (t, e, r) {
      this.data[t * this.size + e] ^= r;
    }),
    (Os.prototype.isReserved = function (t, e) {
      return this.reservedBit[t * this.size + e];
    });
  var NI = Os,
    Wm = {};
  (function (t) {
    const e = rr.getSymbolSize;
    (t.getRowColCoords = function (a) {
      if (a === 1) return [];
      const n = Math.floor(a / 7) + 2,
        s = e(a),
        o = s === 145 ? 26 : Math.ceil((s - 13) / (2 * n - 2)) * 2,
        i = [s - 7];
      for (let l = 1; l < n - 1; l++) i[l] = i[l - 1] - o;
      return i.push(6), i.reverse();
    }),
      (t.getPositions = function (a) {
        const n = [],
          s = t.getRowColCoords(a),
          o = s.length;
        for (let i = 0; i < o; i++)
          for (let l = 0; l < o; l++)
            (i === 0 && l === 0) ||
              (i === 0 && l === o - 1) ||
              (i === o - 1 && l === 0) ||
              n.push([s[i], s[l]]);
        return n;
      });
  })(Wm);
  var Qm = {};
  const MI = rr.getSymbolSize,
    Ym = 7;
  Qm.getPositions = function (e) {
    const r = MI(e);
    return [
      [0, 0],
      [r - Ym, 0],
      [0, r - Ym],
    ];
  };
  var Xm = {};
  (function (t) {
    t.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7,
    };
    const e = { N1: 3, N2: 3, N3: 40, N4: 10 };
    (t.isValid = function (n) {
      return n != null && n !== "" && !isNaN(n) && n >= 0 && n <= 7;
    }),
      (t.from = function (n) {
        return t.isValid(n) ? parseInt(n, 10) : void 0;
      }),
      (t.getPenaltyN1 = function (n) {
        const s = n.size;
        let o = 0,
          i = 0,
          l = 0,
          c = null,
          u = null;
        for (let f = 0; f < s; f++) {
          (i = l = 0), (c = u = null);
          for (let v = 0; v < s; v++) {
            let d = n.get(f, v);
            d === c ? i++ : (i >= 5 && (o += e.N1 + (i - 5)), (c = d), (i = 1)),
              (d = n.get(v, f)),
              d === u
                ? l++
                : (l >= 5 && (o += e.N1 + (l - 5)), (u = d), (l = 1));
          }
          i >= 5 && (o += e.N1 + (i - 5)), l >= 5 && (o += e.N1 + (l - 5));
        }
        return o;
      }),
      (t.getPenaltyN2 = function (n) {
        const s = n.size;
        let o = 0;
        for (let i = 0; i < s - 1; i++)
          for (let l = 0; l < s - 1; l++) {
            const c =
              n.get(i, l) +
              n.get(i, l + 1) +
              n.get(i + 1, l) +
              n.get(i + 1, l + 1);
            (c === 4 || c === 0) && o++;
          }
        return o * e.N2;
      }),
      (t.getPenaltyN3 = function (n) {
        const s = n.size;
        let o = 0,
          i = 0,
          l = 0;
        for (let c = 0; c < s; c++) {
          i = l = 0;
          for (let u = 0; u < s; u++)
            (i = ((i << 1) & 2047) | n.get(c, u)),
              u >= 10 && (i === 1488 || i === 93) && o++,
              (l = ((l << 1) & 2047) | n.get(u, c)),
              u >= 10 && (l === 1488 || l === 93) && o++;
        }
        return o * e.N3;
      }),
      (t.getPenaltyN4 = function (n) {
        let s = 0;
        const o = n.data.length;
        for (let l = 0; l < o; l++) s += n.data[l];
        return Math.abs(Math.ceil((s * 100) / o / 5) - 10) * e.N4;
      });
    function r(a, n, s) {
      switch (a) {
        case t.Patterns.PATTERN000:
          return (n + s) % 2 === 0;
        case t.Patterns.PATTERN001:
          return n % 2 === 0;
        case t.Patterns.PATTERN010:
          return s % 3 === 0;
        case t.Patterns.PATTERN011:
          return (n + s) % 3 === 0;
        case t.Patterns.PATTERN100:
          return (Math.floor(n / 2) + Math.floor(s / 3)) % 2 === 0;
        case t.Patterns.PATTERN101:
          return ((n * s) % 2) + ((n * s) % 3) === 0;
        case t.Patterns.PATTERN110:
          return (((n * s) % 2) + ((n * s) % 3)) % 2 === 0;
        case t.Patterns.PATTERN111:
          return (((n * s) % 3) + ((n + s) % 2)) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + a);
      }
    }
    (t.applyMask = function (n, s) {
      const o = s.size;
      for (let i = 0; i < o; i++)
        for (let l = 0; l < o; l++)
          s.isReserved(l, i) || s.xor(l, i, r(n, l, i));
    }),
      (t.getBestMask = function (n, s) {
        const o = Object.keys(t.Patterns).length;
        let i = 0,
          l = 1 / 0;
        for (let c = 0; c < o; c++) {
          s(c), t.applyMask(c, n);
          const u =
            t.getPenaltyN1(n) +
            t.getPenaltyN2(n) +
            t.getPenaltyN3(n) +
            t.getPenaltyN4(n);
          t.applyMask(c, n), u < l && ((l = u), (i = c));
        }
        return i;
      });
  })(Xm);
  var Ai = {};
  const bn = Oi,
    Ni = [
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2,
      4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4,
      9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6,
      13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9,
      18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34,
      40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17,
      33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56,
      66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81,
    ],
    Mi = [
      7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72,
      88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160,
      192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198,
      288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168,
      308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700,
      224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810,
      960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390,
      728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868,
      1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530,
      1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100,
      660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430,
    ];
  (Ai.getBlocksCount = function (e, r) {
    switch (r) {
      case bn.L:
        return Ni[(e - 1) * 4 + 0];
      case bn.M:
        return Ni[(e - 1) * 4 + 1];
      case bn.Q:
        return Ni[(e - 1) * 4 + 2];
      case bn.H:
        return Ni[(e - 1) * 4 + 3];
      default:
        return;
    }
  }),
    (Ai.getTotalCodewordsCount = function (e, r) {
      switch (r) {
        case bn.L:
          return Mi[(e - 1) * 4 + 0];
        case bn.M:
          return Mi[(e - 1) * 4 + 1];
        case bn.Q:
          return Mi[(e - 1) * 4 + 2];
        case bn.H:
          return Mi[(e - 1) * 4 + 3];
        default:
          return;
      }
    });
  var ev = {},
    ji = {};
  const As = new Uint8Array(512),
    Di = new Uint8Array(256);
  (function () {
    let e = 1;
    for (let r = 0; r < 255; r++)
      (As[r] = e), (Di[e] = r), (e <<= 1), e & 256 && (e ^= 285);
    for (let r = 255; r < 512; r++) As[r] = As[r - 255];
  })(),
    (ji.log = function (e) {
      if (e < 1) throw new Error("log(" + e + ")");
      return Di[e];
    }),
    (ji.exp = function (e) {
      return As[e];
    }),
    (ji.mul = function (e, r) {
      return e === 0 || r === 0 ? 0 : As[Di[e] + Di[r]];
    }),
    (function (t) {
      const e = ji;
      (t.mul = function (a, n) {
        const s = new Uint8Array(a.length + n.length - 1);
        for (let o = 0; o < a.length; o++)
          for (let i = 0; i < n.length; i++) s[o + i] ^= e.mul(a[o], n[i]);
        return s;
      }),
        (t.mod = function (a, n) {
          let s = new Uint8Array(a);
          for (; s.length - n.length >= 0; ) {
            const o = s[0];
            for (let l = 0; l < n.length; l++) s[l] ^= e.mul(n[l], o);
            let i = 0;
            for (; i < s.length && s[i] === 0; ) i++;
            s = s.slice(i);
          }
          return s;
        }),
        (t.generateECPolynomial = function (a) {
          let n = new Uint8Array([1]);
          for (let s = 0; s < a; s++)
            n = t.mul(n, new Uint8Array([1, e.exp(s)]));
          return n;
        });
    })(ev);
  const tv = ev;
  function Yu(t) {
    (this.genPoly = void 0),
      (this.degree = t),
      this.degree && this.initialize(this.degree);
  }
  (Yu.prototype.initialize = function (e) {
    (this.degree = e), (this.genPoly = tv.generateECPolynomial(this.degree));
  }),
    (Yu.prototype.encode = function (e) {
      if (!this.genPoly) throw new Error("Encoder not initialized");
      const r = new Uint8Array(e.length + this.degree);
      r.set(e);
      const a = tv.mod(r, this.genPoly),
        n = this.degree - a.length;
      if (n > 0) {
        const s = new Uint8Array(this.degree);
        return s.set(a, n), s;
      }
      return a;
    });
  var jI = Yu,
    rv = {},
    En = {},
    Xu = {};
  Xu.isValid = function (e) {
    return !isNaN(e) && e >= 1 && e <= 40;
  };
  var Fr = {};
  const nv = "[0-9]+",
    DI = "[A-Z $%*+\\-./:]+";
  let Ns =
    "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
  Ns = Ns.replace(/u/g, "\\u");
  const LI =
    "(?:(?![A-Z0-9 $%*+\\-./:]|" +
    Ns +
    `)(?:.|[\r
]))+`;
  (Fr.KANJI = new RegExp(Ns, "g")),
    (Fr.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g")),
    (Fr.BYTE = new RegExp(LI, "g")),
    (Fr.NUMERIC = new RegExp(nv, "g")),
    (Fr.ALPHANUMERIC = new RegExp(DI, "g"));
  const zI = new RegExp("^" + Ns + "$"),
    qI = new RegExp("^" + nv + "$"),
    UI = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
  (Fr.testKanji = function (e) {
    return zI.test(e);
  }),
    (Fr.testNumeric = function (e) {
      return qI.test(e);
    }),
    (Fr.testAlphanumeric = function (e) {
      return UI.test(e);
    }),
    (function (t) {
      const e = Xu,
        r = Fr;
      (t.NUMERIC = { id: "Numeric", bit: 1, ccBits: [10, 12, 14] }),
        (t.ALPHANUMERIC = { id: "Alphanumeric", bit: 2, ccBits: [9, 11, 13] }),
        (t.BYTE = { id: "Byte", bit: 4, ccBits: [8, 16, 16] }),
        (t.KANJI = { id: "Kanji", bit: 8, ccBits: [8, 10, 12] }),
        (t.MIXED = { bit: -1 }),
        (t.getCharCountIndicator = function (s, o) {
          if (!s.ccBits) throw new Error("Invalid mode: " + s);
          if (!e.isValid(o)) throw new Error("Invalid version: " + o);
          return o >= 1 && o < 10
            ? s.ccBits[0]
            : o < 27
            ? s.ccBits[1]
            : s.ccBits[2];
        }),
        (t.getBestModeForData = function (s) {
          return r.testNumeric(s)
            ? t.NUMERIC
            : r.testAlphanumeric(s)
            ? t.ALPHANUMERIC
            : r.testKanji(s)
            ? t.KANJI
            : t.BYTE;
        }),
        (t.toString = function (s) {
          if (s && s.id) return s.id;
          throw new Error("Invalid mode");
        }),
        (t.isValid = function (s) {
          return s && s.bit && s.ccBits;
        });
      function a(n) {
        if (typeof n != "string") throw new Error("Param is not a string");
        switch (n.toLowerCase()) {
          case "numeric":
            return t.NUMERIC;
          case "alphanumeric":
            return t.ALPHANUMERIC;
          case "kanji":
            return t.KANJI;
          case "byte":
            return t.BYTE;
          default:
            throw new Error("Unknown mode: " + n);
        }
      }
      t.from = function (s, o) {
        if (t.isValid(s)) return s;
        try {
          return a(s);
        } catch {
          return o;
        }
      };
    })(En),
    (function (t) {
      const e = rr,
        r = Ai,
        a = Oi,
        n = En,
        s = Xu,
        o = 7973,
        i = e.getBCHDigit(o);
      function l(v, d, p) {
        for (let g = 1; g <= 40; g++) if (d <= t.getCapacity(g, p, v)) return g;
      }
      function c(v, d) {
        return n.getCharCountIndicator(v, d) + 4;
      }
      function u(v, d) {
        let p = 0;
        return (
          v.forEach(function (g) {
            const m = c(g.mode, d);
            p += m + g.getBitsLength();
          }),
          p
        );
      }
      function f(v, d) {
        for (let p = 1; p <= 40; p++)
          if (u(v, p) <= t.getCapacity(p, d, n.MIXED)) return p;
      }
      (t.from = function (d, p) {
        return s.isValid(d) ? parseInt(d, 10) : p;
      }),
        (t.getCapacity = function (d, p, g) {
          if (!s.isValid(d)) throw new Error("Invalid QR Code version");
          typeof g > "u" && (g = n.BYTE);
          const m = e.getSymbolTotalCodewords(d),
            h = r.getTotalCodewordsCount(d, p),
            y = (m - h) * 8;
          if (g === n.MIXED) return y;
          const _ = y - c(g, d);
          switch (g) {
            case n.NUMERIC:
              return Math.floor((_ / 10) * 3);
            case n.ALPHANUMERIC:
              return Math.floor((_ / 11) * 2);
            case n.KANJI:
              return Math.floor(_ / 13);
            case n.BYTE:
            default:
              return Math.floor(_ / 8);
          }
        }),
        (t.getBestVersionForData = function (d, p) {
          let g;
          const m = a.from(p, a.M);
          if (Array.isArray(d)) {
            if (d.length > 1) return f(d, m);
            if (d.length === 0) return 1;
            g = d[0];
          } else g = d;
          return l(g.mode, g.getLength(), m);
        }),
        (t.getEncodedBits = function (d) {
          if (!s.isValid(d) || d < 7)
            throw new Error("Invalid QR Code version");
          let p = d << 12;
          for (; e.getBCHDigit(p) - i >= 0; ) p ^= o << (e.getBCHDigit(p) - i);
          return (d << 12) | p;
        });
    })(rv);
  var av = {};
  const ed = rr,
    sv = 1335,
    FI = 21522,
    ov = ed.getBCHDigit(sv);
  av.getEncodedBits = function (e, r) {
    const a = (e.bit << 3) | r;
    let n = a << 10;
    for (; ed.getBCHDigit(n) - ov >= 0; ) n ^= sv << (ed.getBCHDigit(n) - ov);
    return ((a << 10) | n) ^ FI;
  };
  var iv = {};
  const VI = En;
  function Na(t) {
    (this.mode = VI.NUMERIC), (this.data = t.toString());
  }
  (Na.getBitsLength = function (e) {
    return 10 * Math.floor(e / 3) + (e % 3 ? (e % 3) * 3 + 1 : 0);
  }),
    (Na.prototype.getLength = function () {
      return this.data.length;
    }),
    (Na.prototype.getBitsLength = function () {
      return Na.getBitsLength(this.data.length);
    }),
    (Na.prototype.write = function (e) {
      let r, a, n;
      for (r = 0; r + 3 <= this.data.length; r += 3)
        (a = this.data.substr(r, 3)), (n = parseInt(a, 10)), e.put(n, 10);
      const s = this.data.length - r;
      s > 0 &&
        ((a = this.data.substr(r)), (n = parseInt(a, 10)), e.put(n, s * 3 + 1));
    });
  var ZI = Na;
  const HI = En,
    td = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":",
    ];
  function Ma(t) {
    (this.mode = HI.ALPHANUMERIC), (this.data = t);
  }
  (Ma.getBitsLength = function (e) {
    return 11 * Math.floor(e / 2) + 6 * (e % 2);
  }),
    (Ma.prototype.getLength = function () {
      return this.data.length;
    }),
    (Ma.prototype.getBitsLength = function () {
      return Ma.getBitsLength(this.data.length);
    }),
    (Ma.prototype.write = function (e) {
      let r;
      for (r = 0; r + 2 <= this.data.length; r += 2) {
        let a = td.indexOf(this.data[r]) * 45;
        (a += td.indexOf(this.data[r + 1])), e.put(a, 11);
      }
      this.data.length % 2 && e.put(td.indexOf(this.data[r]), 6);
    });
  var BI = Ma;
  const JI = En;
  function ja(t) {
    (this.mode = JI.BYTE),
      typeof t == "string"
        ? (this.data = new TextEncoder().encode(t))
        : (this.data = new Uint8Array(t));
  }
  (ja.getBitsLength = function (e) {
    return e * 8;
  }),
    (ja.prototype.getLength = function () {
      return this.data.length;
    }),
    (ja.prototype.getBitsLength = function () {
      return ja.getBitsLength(this.data.length);
    }),
    (ja.prototype.write = function (t) {
      for (let e = 0, r = this.data.length; e < r; e++) t.put(this.data[e], 8);
    });
  var KI = ja;
  const GI = En,
    WI = rr;
  function Da(t) {
    (this.mode = GI.KANJI), (this.data = t);
  }
  (Da.getBitsLength = function (e) {
    return e * 13;
  }),
    (Da.prototype.getLength = function () {
      return this.data.length;
    }),
    (Da.prototype.getBitsLength = function () {
      return Da.getBitsLength(this.data.length);
    }),
    (Da.prototype.write = function (t) {
      let e;
      for (e = 0; e < this.data.length; e++) {
        let r = WI.toSJIS(this.data[e]);
        if (r >= 33088 && r <= 40956) r -= 33088;
        else if (r >= 57408 && r <= 60351) r -= 49472;
        else
          throw new Error(
            "Invalid SJIS character: " +
              this.data[e] +
              `
Make sure your charset is UTF-8`
          );
        (r = ((r >>> 8) & 255) * 192 + (r & 255)), t.put(r, 13);
      }
    });
  var QI = Da,
    lv = { exports: {} };
  (function (t) {
    var e = {
      single_source_shortest_paths: function (r, a, n) {
        var s = {},
          o = {};
        o[a] = 0;
        var i = e.PriorityQueue.make();
        i.push(a, 0);
        for (var l, c, u, f, v, d, p, g, m; !i.empty(); ) {
          (l = i.pop()), (c = l.value), (f = l.cost), (v = r[c] || {});
          for (u in v)
            v.hasOwnProperty(u) &&
              ((d = v[u]),
              (p = f + d),
              (g = o[u]),
              (m = typeof o[u] > "u"),
              (m || g > p) && ((o[u] = p), i.push(u, p), (s[u] = c)));
        }
        if (typeof n < "u" && typeof o[n] > "u") {
          var h = ["Could not find a path from ", a, " to ", n, "."].join("");
          throw new Error(h);
        }
        return s;
      },
      extract_shortest_path_from_predecessor_list: function (r, a) {
        for (var n = [], s = a; s; ) n.push(s), r[s], (s = r[s]);
        return n.reverse(), n;
      },
      find_path: function (r, a, n) {
        var s = e.single_source_shortest_paths(r, a, n);
        return e.extract_shortest_path_from_predecessor_list(s, n);
      },
      PriorityQueue: {
        make: function (r) {
          var a = e.PriorityQueue,
            n = {},
            s;
          r = r || {};
          for (s in a) a.hasOwnProperty(s) && (n[s] = a[s]);
          return (n.queue = []), (n.sorter = r.sorter || a.default_sorter), n;
        },
        default_sorter: function (r, a) {
          return r.cost - a.cost;
        },
        push: function (r, a) {
          var n = { value: r, cost: a };
          this.queue.push(n), this.queue.sort(this.sorter);
        },
        pop: function () {
          return this.queue.shift();
        },
        empty: function () {
          return this.queue.length === 0;
        },
      },
    };
    t.exports = e;
  })(lv);
  var YI = lv.exports;
  (function (t) {
    const e = En,
      r = ZI,
      a = BI,
      n = KI,
      s = QI,
      o = Fr,
      i = rr,
      l = YI;
    function c(h) {
      return unescape(encodeURIComponent(h)).length;
    }
    function u(h, y, _) {
      const w = [];
      let E;
      for (; (E = h.exec(_)) !== null; )
        w.push({ data: E[0], index: E.index, mode: y, length: E[0].length });
      return w;
    }
    function f(h) {
      const y = u(o.NUMERIC, e.NUMERIC, h),
        _ = u(o.ALPHANUMERIC, e.ALPHANUMERIC, h);
      let w, E;
      return (
        i.isKanjiModeEnabled()
          ? ((w = u(o.BYTE, e.BYTE, h)), (E = u(o.KANJI, e.KANJI, h)))
          : ((w = u(o.BYTE_KANJI, e.BYTE, h)), (E = [])),
        y
          .concat(_, w, E)
          .sort(function (x, A) {
            return x.index - A.index;
          })
          .map(function (x) {
            return { data: x.data, mode: x.mode, length: x.length };
          })
      );
    }
    function v(h, y) {
      switch (y) {
        case e.NUMERIC:
          return r.getBitsLength(h);
        case e.ALPHANUMERIC:
          return a.getBitsLength(h);
        case e.KANJI:
          return s.getBitsLength(h);
        case e.BYTE:
          return n.getBitsLength(h);
      }
    }
    function d(h) {
      return h.reduce(function (y, _) {
        const w = y.length - 1 >= 0 ? y[y.length - 1] : null;
        return w && w.mode === _.mode
          ? ((y[y.length - 1].data += _.data), y)
          : (y.push(_), y);
      }, []);
    }
    function p(h) {
      const y = [];
      for (let _ = 0; _ < h.length; _++) {
        const w = h[_];
        switch (w.mode) {
          case e.NUMERIC:
            y.push([
              w,
              { data: w.data, mode: e.ALPHANUMERIC, length: w.length },
              { data: w.data, mode: e.BYTE, length: w.length },
            ]);
            break;
          case e.ALPHANUMERIC:
            y.push([w, { data: w.data, mode: e.BYTE, length: w.length }]);
            break;
          case e.KANJI:
            y.push([w, { data: w.data, mode: e.BYTE, length: c(w.data) }]);
            break;
          case e.BYTE:
            y.push([{ data: w.data, mode: e.BYTE, length: c(w.data) }]);
        }
      }
      return y;
    }
    function g(h, y) {
      const _ = {},
        w = { start: {} };
      let E = ["start"];
      for (let P = 0; P < h.length; P++) {
        const x = h[P],
          A = [];
        for (let M = 0; M < x.length; M++) {
          const H = x[M],
            V = "" + P + M;
          A.push(V), (_[V] = { node: H, lastCount: 0 }), (w[V] = {});
          for (let J = 0; J < E.length; J++) {
            const z = E[J];
            _[z] && _[z].node.mode === H.mode
              ? ((w[z][V] =
                  v(_[z].lastCount + H.length, H.mode) -
                  v(_[z].lastCount, H.mode)),
                (_[z].lastCount += H.length))
              : (_[z] && (_[z].lastCount = H.length),
                (w[z][V] =
                  v(H.length, H.mode) +
                  4 +
                  e.getCharCountIndicator(H.mode, y)));
          }
        }
        E = A;
      }
      for (let P = 0; P < E.length; P++) w[E[P]].end = 0;
      return { map: w, table: _ };
    }
    function m(h, y) {
      let _;
      const w = e.getBestModeForData(h);
      if (((_ = e.from(y, w)), _ !== e.BYTE && _.bit < w.bit))
        throw new Error(
          '"' +
            h +
            '" cannot be encoded with mode ' +
            e.toString(_) +
            `.
 Suggested mode is: ` +
            e.toString(w)
        );
      switch ((_ === e.KANJI && !i.isKanjiModeEnabled() && (_ = e.BYTE), _)) {
        case e.NUMERIC:
          return new r(h);
        case e.ALPHANUMERIC:
          return new a(h);
        case e.KANJI:
          return new s(h);
        case e.BYTE:
          return new n(h);
      }
    }
    (t.fromArray = function (y) {
      return y.reduce(function (_, w) {
        return (
          typeof w == "string"
            ? _.push(m(w, null))
            : w.data && _.push(m(w.data, w.mode)),
          _
        );
      }, []);
    }),
      (t.fromString = function (y, _) {
        const w = f(y, i.isKanjiModeEnabled()),
          E = p(w),
          P = g(E, _),
          x = l.find_path(P.map, "start", "end"),
          A = [];
        for (let M = 1; M < x.length - 1; M++) A.push(P.table[x[M]].node);
        return t.fromArray(d(A));
      }),
      (t.rawSplit = function (y) {
        return t.fromArray(f(y, i.isKanjiModeEnabled()));
      });
  })(iv);
  const Li = rr,
    rd = Oi,
    XI = AI,
    ek = NI,
    tk = Wm,
    rk = Qm,
    nd = Xm,
    ad = Ai,
    nk = jI,
    zi = rv,
    ak = av,
    sk = En,
    sd = iv;
  function ok(t, e) {
    const r = t.size,
      a = rk.getPositions(e);
    for (let n = 0; n < a.length; n++) {
      const s = a[n][0],
        o = a[n][1];
      for (let i = -1; i <= 7; i++)
        if (!(s + i <= -1 || r <= s + i))
          for (let l = -1; l <= 7; l++)
            o + l <= -1 ||
              r <= o + l ||
              ((i >= 0 && i <= 6 && (l === 0 || l === 6)) ||
              (l >= 0 && l <= 6 && (i === 0 || i === 6)) ||
              (i >= 2 && i <= 4 && l >= 2 && l <= 4)
                ? t.set(s + i, o + l, !0, !0)
                : t.set(s + i, o + l, !1, !0));
    }
  }
  function ik(t) {
    const e = t.size;
    for (let r = 8; r < e - 8; r++) {
      const a = r % 2 === 0;
      t.set(r, 6, a, !0), t.set(6, r, a, !0);
    }
  }
  function lk(t, e) {
    const r = tk.getPositions(e);
    for (let a = 0; a < r.length; a++) {
      const n = r[a][0],
        s = r[a][1];
      for (let o = -2; o <= 2; o++)
        for (let i = -2; i <= 2; i++)
          o === -2 || o === 2 || i === -2 || i === 2 || (o === 0 && i === 0)
            ? t.set(n + o, s + i, !0, !0)
            : t.set(n + o, s + i, !1, !0);
    }
  }
  function ck(t, e) {
    const r = t.size,
      a = zi.getEncodedBits(e);
    let n, s, o;
    for (let i = 0; i < 18; i++)
      (n = Math.floor(i / 3)),
        (s = (i % 3) + r - 8 - 3),
        (o = ((a >> i) & 1) === 1),
        t.set(n, s, o, !0),
        t.set(s, n, o, !0);
  }
  function od(t, e, r) {
    const a = t.size,
      n = ak.getEncodedBits(e, r);
    let s, o;
    for (s = 0; s < 15; s++)
      (o = ((n >> s) & 1) === 1),
        s < 6
          ? t.set(s, 8, o, !0)
          : s < 8
          ? t.set(s + 1, 8, o, !0)
          : t.set(a - 15 + s, 8, o, !0),
        s < 8
          ? t.set(8, a - s - 1, o, !0)
          : s < 9
          ? t.set(8, 15 - s - 1 + 1, o, !0)
          : t.set(8, 15 - s - 1, o, !0);
    t.set(a - 8, 8, 1, !0);
  }
  function uk(t, e) {
    const r = t.size;
    let a = -1,
      n = r - 1,
      s = 7,
      o = 0;
    for (let i = r - 1; i > 0; i -= 2)
      for (i === 6 && i--; ; ) {
        for (let l = 0; l < 2; l++)
          if (!t.isReserved(n, i - l)) {
            let c = !1;
            o < e.length && (c = ((e[o] >>> s) & 1) === 1),
              t.set(n, i - l, c),
              s--,
              s === -1 && (o++, (s = 7));
          }
        if (((n += a), n < 0 || r <= n)) {
          (n -= a), (a = -a);
          break;
        }
      }
  }
  function dk(t, e, r) {
    const a = new XI();
    r.forEach(function (l) {
      a.put(l.mode.bit, 4),
        a.put(l.getLength(), sk.getCharCountIndicator(l.mode, t)),
        l.write(a);
    });
    const n = Li.getSymbolTotalCodewords(t),
      s = ad.getTotalCodewordsCount(t, e),
      o = (n - s) * 8;
    for (
      a.getLengthInBits() + 4 <= o && a.put(0, 4);
      a.getLengthInBits() % 8 !== 0;

    )
      a.putBit(0);
    const i = (o - a.getLengthInBits()) / 8;
    for (let l = 0; l < i; l++) a.put(l % 2 ? 17 : 236, 8);
    return fk(a, t, e);
  }
  function fk(t, e, r) {
    const a = Li.getSymbolTotalCodewords(e),
      n = ad.getTotalCodewordsCount(e, r),
      s = a - n,
      o = ad.getBlocksCount(e, r),
      i = a % o,
      l = o - i,
      c = Math.floor(a / o),
      u = Math.floor(s / o),
      f = u + 1,
      v = c - u,
      d = new nk(v);
    let p = 0;
    const g = new Array(o),
      m = new Array(o);
    let h = 0;
    const y = new Uint8Array(t.buffer);
    for (let x = 0; x < o; x++) {
      const A = x < l ? u : f;
      (g[x] = y.slice(p, p + A)),
        (m[x] = d.encode(g[x])),
        (p += A),
        (h = Math.max(h, A));
    }
    const _ = new Uint8Array(a);
    let w = 0,
      E,
      P;
    for (E = 0; E < h; E++)
      for (P = 0; P < o; P++) E < g[P].length && (_[w++] = g[P][E]);
    for (E = 0; E < v; E++) for (P = 0; P < o; P++) _[w++] = m[P][E];
    return _;
  }
  function pk(t, e, r, a) {
    let n;
    if (Array.isArray(t)) n = sd.fromArray(t);
    else if (typeof t == "string") {
      let c = e;
      if (!c) {
        const u = sd.rawSplit(t);
        c = zi.getBestVersionForData(u, r);
      }
      n = sd.fromString(t, c || 40);
    } else throw new Error("Invalid data");
    const s = zi.getBestVersionForData(n, r);
    if (!s)
      throw new Error(
        "The amount of data is too big to be stored in a QR Code"
      );
    if (!e) e = s;
    else if (e < s)
      throw new Error(
        `
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` +
          s +
          `.
`
      );
    const o = dk(e, r, n),
      i = Li.getSymbolSize(e),
      l = new ek(i);
    return (
      ok(l, e),
      ik(l),
      lk(l, e),
      od(l, r, 0),
      e >= 7 && ck(l, e),
      uk(l, o),
      isNaN(a) && (a = nd.getBestMask(l, od.bind(null, l, r))),
      nd.applyMask(a, l),
      od(l, r, a),
      {
        modules: l,
        version: e,
        errorCorrectionLevel: r,
        maskPattern: a,
        segments: n,
      }
    );
  }
  Km.create = function (e, r) {
    if (typeof e > "u" || e === "") throw new Error("No input text");
    let a = rd.M,
      n,
      s;
    return (
      typeof r < "u" &&
        ((a = rd.from(r.errorCorrectionLevel, rd.M)),
        (n = zi.from(r.version)),
        (s = nd.from(r.maskPattern)),
        r.toSJISFunc && Li.setToSJISFunction(r.toSJISFunc)),
      pk(e, n, a, s)
    );
  };
  var cv = {},
    id = {};
  (function (t) {
    function e(r) {
      if ((typeof r == "number" && (r = r.toString()), typeof r != "string"))
        throw new Error("Color should be defined as hex string");
      let a = r.slice().replace("#", "").split("");
      if (a.length < 3 || a.length === 5 || a.length > 8)
        throw new Error("Invalid hex color: " + r);
      (a.length === 3 || a.length === 4) &&
        (a = Array.prototype.concat.apply(
          [],
          a.map(function (s) {
            return [s, s];
          })
        )),
        a.length === 6 && a.push("F", "F");
      const n = parseInt(a.join(""), 16);
      return {
        r: (n >> 24) & 255,
        g: (n >> 16) & 255,
        b: (n >> 8) & 255,
        a: n & 255,
        hex: "#" + a.slice(0, 6).join(""),
      };
    }
    (t.getOptions = function (a) {
      a || (a = {}), a.color || (a.color = {});
      const n =
          typeof a.margin > "u" || a.margin === null || a.margin < 0
            ? 4
            : a.margin,
        s = a.width && a.width >= 21 ? a.width : void 0,
        o = a.scale || 4;
      return {
        width: s,
        scale: s ? 4 : o,
        margin: n,
        color: {
          dark: e(a.color.dark || "#000000ff"),
          light: e(a.color.light || "#ffffffff"),
        },
        type: a.type,
        rendererOpts: a.rendererOpts || {},
      };
    }),
      (t.getScale = function (a, n) {
        return n.width && n.width >= a + n.margin * 2
          ? n.width / (a + n.margin * 2)
          : n.scale;
      }),
      (t.getImageWidth = function (a, n) {
        const s = t.getScale(a, n);
        return Math.floor((a + n.margin * 2) * s);
      }),
      (t.qrToImageData = function (a, n, s) {
        const o = n.modules.size,
          i = n.modules.data,
          l = t.getScale(o, s),
          c = Math.floor((o + s.margin * 2) * l),
          u = s.margin * l,
          f = [s.color.light, s.color.dark];
        for (let v = 0; v < c; v++)
          for (let d = 0; d < c; d++) {
            let p = (v * c + d) * 4,
              g = s.color.light;
            if (v >= u && d >= u && v < c - u && d < c - u) {
              const m = Math.floor((v - u) / l),
                h = Math.floor((d - u) / l);
              g = f[i[m * o + h] ? 1 : 0];
            }
            (a[p++] = g.r), (a[p++] = g.g), (a[p++] = g.b), (a[p] = g.a);
          }
      });
  })(id),
    (function (t) {
      const e = id;
      function r(n, s, o) {
        n.clearRect(0, 0, s.width, s.height),
          s.style || (s.style = {}),
          (s.height = o),
          (s.width = o),
          (s.style.height = o + "px"),
          (s.style.width = o + "px");
      }
      function a() {
        try {
          return document.createElement("canvas");
        } catch {
          throw new Error("You need to specify a canvas element");
        }
      }
      (t.render = function (s, o, i) {
        let l = i,
          c = o;
        typeof l > "u" && (!o || !o.getContext) && ((l = o), (o = void 0)),
          o || (c = a()),
          (l = e.getOptions(l));
        const u = e.getImageWidth(s.modules.size, l),
          f = c.getContext("2d"),
          v = f.createImageData(u, u);
        return (
          e.qrToImageData(v.data, s, l), r(f, c, u), f.putImageData(v, 0, 0), c
        );
      }),
        (t.renderToDataURL = function (s, o, i) {
          let l = i;
          typeof l > "u" && (!o || !o.getContext) && ((l = o), (o = void 0)),
            l || (l = {});
          const c = t.render(s, o, l),
            u = l.type || "image/png",
            f = l.rendererOpts || {};
          return c.toDataURL(u, f.quality);
        });
    })(cv);
  var uv = {};
  const hk = id;
  function dv(t, e) {
    const r = t.a / 255,
      a = e + '="' + t.hex + '"';
    return r < 1 ? a + " " + e + '-opacity="' + r.toFixed(2).slice(1) + '"' : a;
  }
  function ld(t, e, r) {
    let a = t + e;
    return typeof r < "u" && (a += " " + r), a;
  }
  function mk(t, e, r) {
    let a = "",
      n = 0,
      s = !1,
      o = 0;
    for (let i = 0; i < t.length; i++) {
      const l = Math.floor(i % e),
        c = Math.floor(i / e);
      !l && !s && (s = !0),
        t[i]
          ? (o++,
            (i > 0 && l > 0 && t[i - 1]) ||
              ((a += s ? ld("M", l + r, 0.5 + c + r) : ld("m", n, 0)),
              (n = 0),
              (s = !1)),
            (l + 1 < e && t[i + 1]) || ((a += ld("h", o)), (o = 0)))
          : n++;
    }
    return a;
  }
  uv.render = function (e, r, a) {
    const n = hk.getOptions(r),
      s = e.modules.size,
      o = e.modules.data,
      i = s + n.margin * 2,
      l = n.color.light.a
        ? "<path " +
          dv(n.color.light, "fill") +
          ' d="M0 0h' +
          i +
          "v" +
          i +
          'H0z"/>'
        : "",
      c =
        "<path " +
        dv(n.color.dark, "stroke") +
        ' d="' +
        mk(o, s, n.margin) +
        '"/>',
      u = 'viewBox="0 0 ' + i + " " + i + '"',
      v =
        '<svg xmlns="http://www.w3.org/2000/svg" ' +
        (n.width ? 'width="' + n.width + '" height="' + n.width + '" ' : "") +
        u +
        ' shape-rendering="crispEdges">' +
        l +
        c +
        `</svg>
`;
    return typeof a == "function" && a(null, v), v;
  };
  const vk = RI,
    cd = Km,
    fv = cv,
    gk = uv;
  function ud(t, e, r, a, n) {
    const s = [].slice.call(arguments, 1),
      o = s.length,
      i = typeof s[o - 1] == "function";
    if (!i && !vk()) throw new Error("Callback required as last argument");
    if (i) {
      if (o < 2) throw new Error("Too few arguments provided");
      o === 2
        ? ((n = r), (r = e), (e = a = void 0))
        : o === 3 &&
          (e.getContext && typeof n > "u"
            ? ((n = a), (a = void 0))
            : ((n = a), (a = r), (r = e), (e = void 0)));
    } else {
      if (o < 1) throw new Error("Too few arguments provided");
      return (
        o === 1
          ? ((r = e), (e = a = void 0))
          : o === 2 && !e.getContext && ((a = r), (r = e), (e = void 0)),
        new Promise(function (l, c) {
          try {
            const u = cd.create(r, a);
            l(t(u, e, a));
          } catch (u) {
            c(u);
          }
        })
      );
    }
    try {
      const l = cd.create(r, a);
      n(null, t(l, e, a));
    } catch (l) {
      n(l);
    }
  }
  (Aa.create = cd.create),
    (Aa.toCanvas = ud.bind(null, fv.render)),
    (Aa.toDataURL = ud.bind(null, fv.renderToDataURL)),
    (Aa.toString = ud.bind(null, function (t, e, r) {
      return gk.render(t, r);
    }));
  class pv {
    constructor(
      e,
      { size: r = 200, margin: a = 4, color: n = "#000", bgColor: s = "#fff" }
    ) {
      (this.value = e),
        (this.size = r),
        (this.margin = a),
        (this.color = n),
        (this.bgColor = s);
    }
    get qrCodeOption() {
      return {
        width: this.size,
        margin: this.margin,
        color: { dark: this.color, light: this.bgColor },
      };
    }
    async toDataURL() {
      return Aa.toDataURL(this.value, this.qrCodeOption);
    }
    async toCanvas(e) {
      return Aa.toCanvas(e, this.value, this.qrCodeOption);
    }
    async toImage(e) {
      e.src = await this.toDataURL();
    }
  }
  const hv = (t) => [
    {
      action: "qr-code",
      show: !0,
      text: "弹出二维码",
      icon: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect x="3" y="3" width="6" height="6" rx="1" stroke="currentColor" stroke-width="2" fill="none"/>
      <rect x="15" y="3" width="6" height="6" rx="1" stroke="currentColor" stroke-width="2" fill="none"/>
      <rect x="3" y="15" width="6" height="6" rx="1" stroke="currentColor" stroke-width="2" fill="none"/>
      <line x1="9" y1="6" x2="9" y2="18" stroke="currentColor" stroke-width="1.5"/>
      <line x1="15" y1="6" x2="15" y2="18" stroke="currentColor" stroke-width="1.5"/>
      <line x1="6" y1="9" x2="18" y2="9" stroke="currentColor" stroke-width="1.5"/>
      <line x1="6" y1="15" x2="18" y2="15" stroke="currentColor" stroke-width="1.5"/>
      <circle cx="12" cy="12" r="1" fill="currentColor"/>
    </svg>`,
    },
    {
      action: "ai-chat",
      show: !0,
      text: "弹出 AI 对话框",
      icon: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M20 2H4C2.9 2 2 2.9 2 4V22L6 18H20C21.1 18 22 17.1 22 16V4C22 2.9 21.1 2 20 2ZM20 16H6L4 18V4H20V16Z" fill="currentColor"/>
      <path d="M7 9H17V11H7V9Z" fill="currentColor"/>
      <path d="M7 12H14V14H7V12Z" fill="currentColor"/>
    </svg>`,
    },
    {
      action: "remote-control",
      show: !0,
      text: `识别码：${t.sessionId.slice(-6)}`,
      showCopyIcon: !0,
      icon: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" stroke-width="2" fill="none"/>
      <rect x="6" y="6" width="3" height="2" rx="0.5" fill="currentColor"/>
      <rect x="10" y="6" width="3" height="2" rx="0.5" fill="currentColor"/>
      <rect x="14" y="6" width="3" height="2" rx="0.5" fill="currentColor"/>
      <rect x="6" y="9" width="3" height="2" rx="0.5" fill="currentColor"/>
      <rect x="10" y="9" width="3" height="2" rx="0.5" fill="currentColor"/>
      <rect x="14" y="9" width="3" height="2" rx="0.5" fill="currentColor"/>
      <rect x="6" y="12" width="3" height="2" rx="0.5" fill="currentColor"/>
      <rect x="10" y="12" width="3" height="2" rx="0.5" fill="currentColor"/>
      <rect x="14" y="12" width="3" height="2" rx="0.5" fill="currentColor"/>
    </svg>`,
    },
    {
      action: "remote-url",
      show: !0,
      text: `${t.qrCodeUrl}`,
      tip: t.qrCodeUrl,
      showCopyIcon: !0,
      icon: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
      <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
    </svg>`,
    },
  ];
  class yk {
    constructor(e) {
      if (((this.isExpanded = !1), !e.sessionId))
        throw new Error("sessionId is required");
      (this.options = {
        qrCodeUrl: e.qrCodeUrl || "https://ai.opentiny.design/next-remoter",
        ...e,
      }),
        (this.menuItems = this.mergeMenuItems(e.menuItems)),
        this.init();
    }
    get sessionPrefix() {
      var e;
      return (e = this.options.qrCodeUrl) != null && e.includes("?")
        ? "&sessionId="
        : "?sessionId=";
    }
    mergeMenuItems(e) {
      return e
        ? hv(this.options).map((r) => {
            const a = e.find((n) => n.action === r.action);
            return a
              ? { ...r, ...a, show: a.show !== void 0 ? a.show : r.show }
              : r;
          })
        : hv(this.options);
    }
    init() {
      this.createFloatingBlock(),
        this.createDropdownMenu(),
        this.bindEvents(),
        this.addStyles();
    }
    createFloatingBlock() {
      (this.floatingBlock = document.createElement("div")),
        (this.floatingBlock.className = "tiny-remoter-floating-block"),
        (this.floatingBlock.innerHTML = `
      <div class="tiny-remoter-floating-block__icon">
        <img style="display: block; width: 56px;" src="https://ai.opentiny.design/next-remoter/svgs/logo-next-no-bg-left.svg" alt="icon" />
      </div>
    `),
        document.body.appendChild(this.floatingBlock);
    }
    createDropdownMenu() {
      (this.dropdownMenu = document.createElement("div")),
        (this.dropdownMenu.className = "tiny-remoter-floating-dropdown");
      const e = this.menuItems
        .filter((r) => r.show !== !1)
        .map(
          (r) => `
        <div class="tiny-remoter-dropdown-item" data-action="${r.action}">
          <div class="tiny-remoter-dropdown-item__icon">
            ${r.icon}
          </div>
          <span title="${r.tip}">${r.text}</span>
          ${
            r.showCopyIcon
              ? `
            <div class="tiny-remoter-copy-icon" data-action="${r.action}">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M16 1H4C2.9 1 2 1.9 2 3V17H4V3H16V1ZM19 5H8C6.9 5 6 5.9 6 7V21C6 22.1 6.9 23 8 23H19C20.1 23 21 22.1 21 21V7C21 5.9 20.1 5 19 5ZM19 21H8V7H19V21Z" fill="currentColor"/>
              </svg>
            </div>
          `
              : ""
          }
        </div>
      `
        )
        .join("");
      (this.dropdownMenu.innerHTML = e),
        document.body.appendChild(this.dropdownMenu);
    }
    bindEvents() {
      this.floatingBlock.addEventListener("click", () => {
        this.toggleDropdown();
      }),
        this.dropdownMenu.addEventListener("click", (e) => {
          const r = e.target,
            a = r.closest(".tiny-remoter-copy-icon");
          if (a) {
            e.stopPropagation();
            const o = a.dataset.action;
            o && this.handleAction(o);
            return;
          }
          const n = r.closest(".tiny-remoter-dropdown-item"),
            s = n == null ? void 0 : n.dataset.action;
          s && this.handleAction(s);
        }),
        document.addEventListener("click", (e) => {
          const r = e.target;
          !this.floatingBlock.contains(r) &&
            !this.dropdownMenu.contains(r) &&
            this.closeDropdown();
        }),
        document.addEventListener("keydown", (e) => {
          e.key === "Escape" && this.closeDropdown();
        });
    }
    toggleDropdown() {
      this.isExpanded ? this.closeDropdown() : this.openDropdown();
    }
    openDropdown() {
      (this.isExpanded = !0),
        this.floatingBlock.classList.add("expanded"),
        this.dropdownMenu.classList.add("show");
    }
    closeDropdown() {
      (this.isExpanded = !1),
        this.floatingBlock.classList.remove("expanded"),
        this.dropdownMenu.classList.remove("show");
    }
    handleAction(e) {
      switch (e) {
        case "qr-code":
          this.showQRCode();
          break;
        case "ai-chat":
          this.showAIChat();
          break;
        case "remote-control":
          this.copyRemoteControl();
          break;
        case "remote-url":
          this.copyRemoteURL();
          break;
      }
      this.closeDropdown();
    }
    copyRemoteControl() {
      this.copyToClipboard(this.options.sessionId.slice(-6));
    }
    copyRemoteURL() {
      this.copyToClipboard(
        (this.options.qrCodeUrl || "") +
          this.sessionPrefix +
          this.options.sessionId
      );
    }
    async copyToClipboard(e) {
      try {
        if (navigator.clipboard && window.isSecureContext)
          await navigator.clipboard.writeText(e), this.showCopyFeedback(!0);
        else {
          const r = document.createElement("textarea");
          (r.value = e),
            (r.style.position = "fixed"),
            (r.style.left = "-999999px"),
            (r.style.top = "-999999px"),
            document.body.appendChild(r),
            r.focus(),
            r.select();
          const a = document.execCommand("copy");
          document.body.removeChild(r),
            a ? this.showCopyFeedback(!0) : this.showCopyFeedback(!1);
        }
      } catch (r) {
        console.error("复制失败:", r), this.showCopyFeedback(!1);
      }
    }
    showCopyFeedback(e) {
      const r = e ? "复制成功！" : "复制失败，请手动复制",
        a = document.createElement("div");
      (a.className = `tiny-remoter-copy-feedback ${e ? "success" : "error"}`),
        (a.textContent = r),
        document.body.appendChild(a),
        setTimeout(() => a.classList.add("show"), 10),
        setTimeout(() => {
          a.classList.remove("show"),
            setTimeout(() => {
              a.parentNode && a.parentNode.removeChild(a);
            }, 300);
        }, 1500);
    }
    async showQRCode() {
      const r = await new pv(
          (this.options.qrCodeUrl || "") +
            this.sessionPrefix +
            this.options.sessionId,
          {}
        ).toDataURL(),
        a = this.createModal(
          "扫码前往智能遥控器",
          `
      <div style="text-align: center; padding: 32px;">
        <!-- 二维码容器 - 添加渐变背景和阴影效果 -->
        <div style="
          width: 240px; 
          height: 240px; 
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          margin: 0 auto 24px; 
          display: flex; 
          align-items: center; 
          justify-content: center; 
          border-radius: 20px;
          box-shadow: 0 20px 40px rgba(102, 126, 234, 0.3);
          position: relative;
          overflow: hidden;
        ">
          <!-- 装饰性背景元素 -->
          <div style="
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
          "></div>
          
          <!-- 二维码图片容器 -->
          <div style="
            width: 200px;
            height: 200px;
            background: white;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            position: relative;
            z-index: 1;
          ">
            <img src="${r}" alt="二维码" style="
              width: 100%; 
              height: 100%; 
              object-fit: contain;
              border-radius: 8px;
            ">
          </div>
        </div>
        
        <!-- 标题文字 -->
        <h3 style="
          color: #333;
          margin: 0 0 12px 0;
          font-size: 20px;
          font-weight: 600;
          letter-spacing: 0.5px;
        ">扫描二维码</h3>
        
        <!-- 描述文字 -->
        <p style="
          color: #666; 
          margin: 0 auto;
          margin-bottom: 20px;
          font-size: 14px;
          line-height: 1.6;
          max-width: 280px;
        ">请使用手机微信或者浏览器扫描二维码跳转到智能遥控器</p>
        
        <!-- 提示图标和文字 -->
        <div style="
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 8px;
          color: #999;
          font-size: 12px;
        ">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="opacity: 0.7;">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" fill="currentColor"/>
          </svg>
          <span>支持微信、浏览器等多种方式</span>
        </div>
      </div>
    `
        );
      this.showModal(a);
    }
    showAIChat() {
      var e, r;
      (r = (e = this.options).onShowAIChat) == null || r.call(e);
    }
    createModal(e, r) {
      const a = document.createElement("div");
      (a.className = "tiny-remoter-floating-modal"),
        (a.innerHTML = `
      <div class="tiny-remoter-modal-overlay"></div>
      <div class="tiny-remoter-modal-content">
        <div class="tiny-remoter-modal-header">
          <h3>${e}</h3>
          <button class="tiny-remoter-modal-close">&times;</button>
        </div>
        <div class="tiny-remoter-modal-body">
          ${r}
        </div>
      </div>
    `);
      const n = a.querySelector(".tiny-remoter-modal-close"),
        s = a.querySelector(".tiny-remoter-modal-overlay");
      return (
        n.addEventListener("click", () => this.hideModal(a)),
        s.addEventListener("click", () => this.hideModal(a)),
        a
      );
    }
    showModal(e) {
      document.body.appendChild(e),
        setTimeout(() => e.classList.add("show"), 10);
    }
    hideModal(e) {
      e.classList.remove("show"),
        setTimeout(() => {
          e.parentNode && e.parentNode.removeChild(e);
        }, 100);
    }
    addStyles() {
      const e = document.createElement("style");
      (e.textContent = `
      /* 浮动块样式 */
      .tiny-remoter-floating-block {
        position: fixed;
        bottom: 30px;
        right: 30px;
        width: 60px;
        height: 60px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 99;
        overflow: hidden;
        border-radius: 50%;
      }

      .tiny-remoter-floating-block__icon {
        transform: scale(0.8);
        transition: transform 0.3s ease;
      }

       .tiny-remoter-floating-block__icon:hover {
        transform: scale(1.1);
      }

      .tiny-remoter-floating-block.expanded .tiny-remoter-floating-block__icon {
        transform: scale(1.1);
      }

      /* 下拉菜单样式 */
      .tiny-remoter-floating-dropdown {
        position: fixed;
        bottom: 100px;
        right: 30px;
        background: white;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
        padding: 8px;
        opacity: 0;
        visibility: hidden;
        transform: translateY(20px) scale(0.95);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 999;
        min-width: 200px;
      }

      .tiny-remoter-floating-dropdown.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
      }

      .tiny-remoter-dropdown-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #333;
      }

      .tiny-remoter-dropdown-item > span {
        flex: 1;
        overflow: hidden;
        max-width: 120px;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .tiny-remoter-dropdown-item:hover {
        background: #f8f9fa;
        transform: translateX(4px);
      }

      .tiny-remoter-dropdown-item__icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        background: #f8f9fa;
        border-radius: 8px;
        color: #667eea;
      }

      /* 复制图标样式 */
      .tiny-remoter-copy-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        background: #f0f0f0;
        border-radius: 6px;
        color: #666;
        cursor: pointer;
        transition: all 0.2s ease;
        opacity: 0.7;
        margin-left: auto;
      }

      .tiny-remoter-copy-icon:hover {
        background: #e0e0e0;
        color: #333;
        opacity: 1;
        transform: scale(1.1);
      }

      .tiny-remoter-copy-icon:active {
        transform: scale(0.95);
      }

      /* 弹窗样式 */
      .tiny-remoter-floating-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2000;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .tiny-remoter-modal-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .tiny-remoter-modal-content {
        background: white;
        border-radius: 16px;
        box-shadow: 0 25px 80px rgba(0, 0, 0, 0.2);
        max-width: 500px;
        width: 90%;
        max-height: 80vh;
        overflow: hidden;
        transform: scale(0.9) translateY(20px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .tiny-remoter-floating-modal.show .tiny-remoter-modal-overlay {
        opacity: 1;
      }

      .tiny-remoter-floating-modal.show .tiny-remoter-modal-content {
        transform: scale(1) translateY(0);
      }

      .tiny-remoter-modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 20px 24px;
        border-bottom: 1px solid #f0f0f0;
      }

      .tiny-remoter-modal-header h3 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
        color: #333;
      }

      .tiny-remoter-modal-close {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #999;
        padding: 0;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .tiny-remoter-modal-close:hover {
        background: #f5f5f5;
        color: #666;
      }

      .tiny-remoter-modal-body {
        padding: 24px;
      }

      /* 二维码弹窗动画 */
      @keyframes rotate {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      /* 响应式设计 */
      @media (max-width: 768px) {
        .tiny-remoter-floating-block {
          bottom: 20px;
          right: 20px;
          width: 56px;
          height: 56px;
        }

        .tiny-remoter-floating-dropdown {
          bottom: 90px;
          right: 20px;
          min-width: 180px;
        }

        .tiny-remoter-modal-content {
          width: 95%;
          margin: 20px;
        }
      }

      /* 复制反馈提示样式 */
      .tiny-remoter-copy-feedback {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        z-index: 10000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        backdrop-filter: blur(4px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      .tiny-remoter-copy-feedback.show {
        opacity: 1;
        visibility: visible;
        transform: translate(-50%, -50%) scale(1);
      }

      .tiny-remoter-copy-feedback.success {
        background: rgba(34, 197, 94, 0.9);
      }

      .tiny-remoter-copy-feedback.error {
        background: rgba(239, 68, 68, 0.9);
      }

      /* 深色主题支持 */
      @media (prefers-color-scheme: dark) {
        .tiny-remoter-floating-dropdown {
          background: #1a1a1a;
          color: white;
        }

        .tiny-remoter-dropdown-item {
          color: white;
        }

        .tiny-remoter-dropdown-item:hover {
          background: #2a2a2a;
        }

        .tiny-remoter-dropdown-item__icon {
          background: #2a2a2a;
        }

        .tiny-remoter-copy-icon {
          background: #2a2a2a;
          color: #ccc;
        }

        .tiny-remoter-copy-icon:hover {
          background: #3a3a3a;
          color: white;
        }

        .tiny-remoter-modal-content {
          background: #1a1a1a;
          color: white;
        }

        .tiny-remoter-modal-header {
          border-bottom-color: #333;
        }

        .tiny-remoter-modal-header h3 {
          color: white;
        }
      }
    `),
        document.head.appendChild(e);
    }
    destroy() {
      this.floatingBlock.parentNode &&
        this.floatingBlock.parentNode.removeChild(this.floatingBlock),
        this.dropdownMenu.parentNode &&
          this.dropdownMenu.parentNode.removeChild(this.dropdownMenu);
    }
  }
  const _k = (t = {}) => new yk(t);
  var mv = "vercel.ai.error",
    wk = Symbol.for(mv),
    vv,
    bk = class D0 extends Error {
      constructor({ name: e, message: r, cause: a }) {
        super(r), (this[vv] = !0), (this.name = e), (this.cause = a);
      }
      static isInstance(e) {
        return D0.hasMarker(e, mv);
      }
      static hasMarker(e, r) {
        const a = Symbol.for(r);
        return (
          e != null &&
          typeof e == "object" &&
          a in e &&
          typeof e[a] == "boolean" &&
          e[a] === !0
        );
      }
    };
  vv = wk;
  var Se = bk,
    gv = "AI_APICallError",
    yv = `vercel.ai.error.${gv}`,
    Ek = Symbol.for(yv),
    _v,
    Xe = class extends Se {
      constructor({
        message: t,
        url: e,
        requestBodyValues: r,
        statusCode: a,
        responseHeaders: n,
        responseBody: s,
        cause: o,
        isRetryable: i = a != null &&
          (a === 408 || a === 409 || a === 429 || a >= 500),
        data: l,
      }) {
        super({ name: gv, message: t, cause: o }),
          (this[_v] = !0),
          (this.url = e),
          (this.requestBodyValues = r),
          (this.statusCode = a),
          (this.responseHeaders = n),
          (this.responseBody = s),
          (this.isRetryable = i),
          (this.data = l);
      }
      static isInstance(t) {
        return Se.hasMarker(t, yv);
      }
    };
  _v = Ek;
  var wv = "AI_EmptyResponseBodyError",
    bv = `vercel.ai.error.${wv}`,
    Sk = Symbol.for(bv),
    Ev,
    Sv = class extends Se {
      constructor({ message: t = "Empty response body" } = {}) {
        super({ name: wv, message: t }), (this[Ev] = !0);
      }
      static isInstance(t) {
        return Se.hasMarker(t, bv);
      }
    };
  Ev = Sk;
  function La(t) {
    return t == null
      ? "unknown error"
      : typeof t == "string"
      ? t
      : t instanceof Error
      ? t.message
      : JSON.stringify(t);
  }
  var $v = "AI_InvalidArgumentError",
    Pv = `vercel.ai.error.${$v}`,
    $k = Symbol.for(Pv),
    Tv,
    dd = class extends Se {
      constructor({ message: e, cause: r, argument: a }) {
        super({ name: $v, message: e, cause: r }),
          (this[Tv] = !0),
          (this.argument = a);
      }
      static isInstance(e) {
        return Se.hasMarker(e, Pv);
      }
    };
  Tv = $k;
  var xv = "AI_InvalidPromptError",
    Iv = `vercel.ai.error.${xv}`,
    Pk = Symbol.for(Iv),
    kv,
    Zn = class extends Se {
      constructor({ prompt: t, message: e, cause: r }) {
        super({ name: xv, message: `Invalid prompt: ${e}`, cause: r }),
          (this[kv] = !0),
          (this.prompt = t);
      }
      static isInstance(t) {
        return Se.hasMarker(t, Iv);
      }
    };
  kv = Pk;
  var Cv = "AI_InvalidResponseDataError",
    Rv = `vercel.ai.error.${Cv}`,
    Tk = Symbol.for(Rv),
    Ov,
    Ms = class extends Se {
      constructor({
        data: t,
        message: e = `Invalid response data: ${JSON.stringify(t)}.`,
      }) {
        super({ name: Cv, message: e }), (this[Ov] = !0), (this.data = t);
      }
      static isInstance(t) {
        return Se.hasMarker(t, Rv);
      }
    };
  Ov = Tk;
  var Av = "AI_JSONParseError",
    Nv = `vercel.ai.error.${Av}`,
    xk = Symbol.for(Nv),
    Mv,
    Sn = class extends Se {
      constructor({ text: t, cause: e }) {
        super({
          name: Av,
          message: `JSON parsing failed: Text: ${t}.
Error message: ${La(e)}`,
          cause: e,
        }),
          (this[Mv] = !0),
          (this.text = t);
      }
      static isInstance(t) {
        return Se.hasMarker(t, Nv);
      }
    };
  Mv = xk;
  var jv = "AI_LoadAPIKeyError",
    Dv = `vercel.ai.error.${jv}`,
    Ik = Symbol.for(Dv),
    Lv,
    qi = class extends Se {
      constructor({ message: t }) {
        super({ name: jv, message: t }), (this[Lv] = !0);
      }
      static isInstance(t) {
        return Se.hasMarker(t, Dv);
      }
    };
  Lv = Ik;
  var zv = "AI_NoSuchModelError",
    qv = `vercel.ai.error.${zv}`,
    kk = Symbol.for(qv),
    Uv,
    fd = class extends Se {
      constructor({
        errorName: t = zv,
        modelId: e,
        modelType: r,
        message: a = `No such ${r}: ${e}`,
      }) {
        super({ name: t, message: a }),
          (this[Uv] = !0),
          (this.modelId = e),
          (this.modelType = r);
      }
      static isInstance(t) {
        return Se.hasMarker(t, qv);
      }
    };
  Uv = kk;
  var Fv = "AI_TooManyEmbeddingValuesForCallError",
    Vv = `vercel.ai.error.${Fv}`,
    Ck = Symbol.for(Vv),
    Zv,
    Rk = class extends Se {
      constructor(t) {
        super({
          name: Fv,
          message: `Too many values for a single embedding call. The ${t.provider} model "${t.modelId}" can only embed up to ${t.maxEmbeddingsPerCall} values per call, but ${t.values.length} values were provided.`,
        }),
          (this[Zv] = !0),
          (this.provider = t.provider),
          (this.modelId = t.modelId),
          (this.maxEmbeddingsPerCall = t.maxEmbeddingsPerCall),
          (this.values = t.values);
      }
      static isInstance(t) {
        return Se.hasMarker(t, Vv);
      }
    };
  Zv = Ck;
  var Hv = "AI_TypeValidationError",
    Bv = `vercel.ai.error.${Hv}`,
    Ok = Symbol.for(Bv),
    Jv,
    Ak = class uf extends Se {
      constructor({ value: e, cause: r }) {
        super({
          name: Hv,
          message: `Type validation failed: Value: ${JSON.stringify(e)}.
Error message: ${La(r)}`,
          cause: r,
        }),
          (this[Jv] = !0),
          (this.value = e);
      }
      static isInstance(e) {
        return Se.hasMarker(e, Bv);
      }
      static wrap({ value: e, cause: r }) {
        return uf.isInstance(r) && r.value === e
          ? r
          : new uf({ value: e, cause: r });
      }
    };
  Jv = Ok;
  var Vr = Ak,
    Kv = "AI_UnsupportedFunctionalityError",
    Gv = `vercel.ai.error.${Kv}`,
    Nk = Symbol.for(Gv),
    Wv,
    dr = class extends Se {
      constructor({
        functionality: t,
        message: e = `'${t}' functionality not supported.`,
      }) {
        super({ name: Kv, message: e }),
          (this[Wv] = !0),
          (this.functionality = t);
      }
      static isInstance(t) {
        return Se.hasMarker(t, Gv);
      }
    };
  Wv = Nk;
  function B(t, e, r) {
    function a(i, l) {
      var c;
      Object.defineProperty(i, "_zod", { value: i._zod ?? {}, enumerable: !1 }),
        (c = i._zod).traits ?? (c.traits = new Set()),
        i._zod.traits.add(t),
        e(i, l);
      for (const u in o.prototype)
        u in i ||
          Object.defineProperty(i, u, { value: o.prototype[u].bind(i) });
      (i._zod.constr = o), (i._zod.def = l);
    }
    const n = (r == null ? void 0 : r.Parent) ?? Object;
    class s extends n {}
    Object.defineProperty(s, "name", { value: t });
    function o(i) {
      var l;
      const c = r != null && r.Parent ? new s() : this;
      a(c, i), (l = c._zod).deferred ?? (l.deferred = []);
      for (const u of c._zod.deferred) u();
      return c;
    }
    return (
      Object.defineProperty(o, "init", { value: a }),
      Object.defineProperty(o, Symbol.hasInstance, {
        value: (i) => {
          var l, c;
          return r != null && r.Parent && i instanceof r.Parent
            ? !0
            : (c =
                (l = i == null ? void 0 : i._zod) == null
                  ? void 0
                  : l.traits) == null
            ? void 0
            : c.has(t);
        },
      }),
      Object.defineProperty(o, "name", { value: t }),
      o
    );
  }
  class js extends Error {
    constructor() {
      super(
        "Encountered Promise during synchronous parse. Use .parseAsync() instead."
      );
    }
  }
  const Qv = {};
  function $n(t) {
    return Qv;
  }
  function Yv(t) {
    const e = Object.values(t).filter((a) => typeof a == "number");
    return Object.entries(t)
      .filter(([a, n]) => e.indexOf(+a) === -1)
      .map(([a, n]) => n);
  }
  function Mk(t, e) {
    return typeof e == "bigint" ? e.toString() : e;
  }
  function pd(t) {
    return {
      get value() {
        {
          const e = t();
          return Object.defineProperty(this, "value", { value: e }), e;
        }
      },
    };
  }
  function hd(t) {
    return t == null;
  }
  function md(t) {
    const e = t.startsWith("^") ? 1 : 0,
      r = t.endsWith("$") ? t.length - 1 : t.length;
    return t.slice(e, r);
  }
  function jk(t, e) {
    const r = (t.toString().split(".")[1] || "").length,
      a = (e.toString().split(".")[1] || "").length,
      n = r > a ? r : a,
      s = Number.parseInt(t.toFixed(n).replace(".", "")),
      o = Number.parseInt(e.toFixed(n).replace(".", ""));
    return (s % o) / 10 ** n;
  }
  function Be(t, e, r) {
    Object.defineProperty(t, e, {
      get() {
        {
          const a = r();
          return (t[e] = a), a;
        }
      },
      set(a) {
        Object.defineProperty(t, e, { value: a });
      },
      configurable: !0,
    });
  }
  function Ds(t, e, r) {
    Object.defineProperty(t, e, {
      value: r,
      writable: !0,
      enumerable: !0,
      configurable: !0,
    });
  }
  function Ls(t) {
    return JSON.stringify(t);
  }
  const Xv = Error.captureStackTrace ? Error.captureStackTrace : (...t) => {};
  function Ui(t) {
    return typeof t == "object" && t !== null && !Array.isArray(t);
  }
  const Dk = pd(() => {
    var t;
    if (
      typeof navigator < "u" &&
      (t = navigator == null ? void 0 : navigator.userAgent) != null &&
      t.includes("Cloudflare")
    )
      return !1;
    try {
      const e = Function;
      return new e(""), !0;
    } catch {
      return !1;
    }
  });
  function Fi(t) {
    if (Ui(t) === !1) return !1;
    const e = t.constructor;
    if (e === void 0) return !0;
    const r = e.prototype;
    return !(
      Ui(r) === !1 ||
      Object.prototype.hasOwnProperty.call(r, "isPrototypeOf") === !1
    );
  }
  const Lk = new Set(["string", "number", "symbol"]);
  function zs(t) {
    return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function Hn(t, e, r) {
    const a = new t._zod.constr(e ?? t._zod.def);
    return (!e || (r != null && r.parent)) && (a._zod.parent = t), a;
  }
  function de(t) {
    const e = t;
    if (!e) return {};
    if (typeof e == "string") return { error: () => e };
    if ((e == null ? void 0 : e.message) !== void 0) {
      if ((e == null ? void 0 : e.error) !== void 0)
        throw new Error("Cannot specify both `message` and `error` params");
      e.error = e.message;
    }
    return (
      delete e.message,
      typeof e.error == "string" ? { ...e, error: () => e.error } : e
    );
  }
  function zk(t) {
    return Object.keys(t).filter(
      (e) => t[e]._zod.optin === "optional" && t[e]._zod.optout === "optional"
    );
  }
  const qk = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-34028234663852886e22, 34028234663852886e22],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
  };
  function Uk(t, e) {
    const r = {},
      a = t._zod.def;
    for (const n in e) {
      if (!(n in a.shape)) throw new Error(`Unrecognized key: "${n}"`);
      e[n] && (r[n] = a.shape[n]);
    }
    return Hn(t, { ...t._zod.def, shape: r, checks: [] });
  }
  function Fk(t, e) {
    const r = { ...t._zod.def.shape },
      a = t._zod.def;
    for (const n in e) {
      if (!(n in a.shape)) throw new Error(`Unrecognized key: "${n}"`);
      e[n] && delete r[n];
    }
    return Hn(t, { ...t._zod.def, shape: r, checks: [] });
  }
  function Vk(t, e) {
    if (!Fi(e))
      throw new Error("Invalid input to extend: expected a plain object");
    const r = {
      ...t._zod.def,
      get shape() {
        const a = { ...t._zod.def.shape, ...e };
        return Ds(this, "shape", a), a;
      },
      checks: [],
    };
    return Hn(t, r);
  }
  function Zk(t, e) {
    return Hn(t, {
      ...t._zod.def,
      get shape() {
        const r = { ...t._zod.def.shape, ...e._zod.def.shape };
        return Ds(this, "shape", r), r;
      },
      catchall: e._zod.def.catchall,
      checks: [],
    });
  }
  function Hk(t, e, r) {
    const a = e._zod.def.shape,
      n = { ...a };
    if (r)
      for (const s in r) {
        if (!(s in a)) throw new Error(`Unrecognized key: "${s}"`);
        r[s] &&
          (n[s] = t ? new t({ type: "optional", innerType: a[s] }) : a[s]);
      }
    else
      for (const s in a)
        n[s] = t ? new t({ type: "optional", innerType: a[s] }) : a[s];
    return Hn(e, { ...e._zod.def, shape: n, checks: [] });
  }
  function Bk(t, e, r) {
    const a = e._zod.def.shape,
      n = { ...a };
    if (r)
      for (const s in r) {
        if (!(s in n)) throw new Error(`Unrecognized key: "${s}"`);
        r[s] && (n[s] = new t({ type: "nonoptional", innerType: a[s] }));
      }
    else
      for (const s in a) n[s] = new t({ type: "nonoptional", innerType: a[s] });
    return Hn(e, { ...e._zod.def, shape: n, checks: [] });
  }
  function qs(t, e = 0) {
    var r;
    for (let a = e; a < t.issues.length; a++)
      if (((r = t.issues[a]) == null ? void 0 : r.continue) !== !0) return !0;
    return !1;
  }
  function Bn(t, e) {
    return e.map((r) => {
      var a;
      return (a = r).path ?? (a.path = []), r.path.unshift(t), r;
    });
  }
  function Vi(t) {
    return typeof t == "string" ? t : t == null ? void 0 : t.message;
  }
  function Pn(t, e, r) {
    var n, s, o, i, l, c;
    const a = { ...t, path: t.path ?? [] };
    if (!t.message) {
      const u =
        Vi(
          (o =
            (s = (n = t.inst) == null ? void 0 : n._zod.def) == null
              ? void 0
              : s.error) == null
            ? void 0
            : o.call(s, t)
        ) ??
        Vi(
          (i = e == null ? void 0 : e.error) == null ? void 0 : i.call(e, t)
        ) ??
        Vi((l = r.customError) == null ? void 0 : l.call(r, t)) ??
        Vi((c = r.localeError) == null ? void 0 : c.call(r, t)) ??
        "Invalid input";
      a.message = u;
    }
    return (
      delete a.inst,
      delete a.continue,
      (e != null && e.reportInput) || delete a.input,
      a
    );
  }
  function vd(t) {
    return Array.isArray(t)
      ? "array"
      : typeof t == "string"
      ? "string"
      : "unknown";
  }
  function Us(...t) {
    const [e, r, a] = t;
    return typeof e == "string"
      ? { message: e, code: "custom", input: r, inst: a }
      : { ...e };
  }
  const eg = (t, e) => {
      (t.name = "$ZodError"),
        Object.defineProperty(t, "_zod", { value: t._zod, enumerable: !1 }),
        Object.defineProperty(t, "issues", { value: e, enumerable: !1 }),
        Object.defineProperty(t, "message", {
          get() {
            return JSON.stringify(e, Mk, 2);
          },
          enumerable: !0,
        }),
        Object.defineProperty(t, "toString", {
          value: () => t.message,
          enumerable: !1,
        });
    },
    tg = B("$ZodError", eg),
    rg = B("$ZodError", eg, { Parent: Error });
  function Jk(t, e = (r) => r.message) {
    const r = {},
      a = [];
    for (const n of t.issues)
      n.path.length > 0
        ? ((r[n.path[0]] = r[n.path[0]] || []), r[n.path[0]].push(e(n)))
        : a.push(e(n));
    return { formErrors: a, fieldErrors: r };
  }
  function Kk(t, e) {
    const r =
        e ||
        function (s) {
          return s.message;
        },
      a = { _errors: [] },
      n = (s) => {
        for (const o of s.issues)
          if (o.code === "invalid_union" && o.errors.length)
            o.errors.map((i) => n({ issues: i }));
          else if (o.code === "invalid_key") n({ issues: o.issues });
          else if (o.code === "invalid_element") n({ issues: o.issues });
          else if (o.path.length === 0) a._errors.push(r(o));
          else {
            let i = a,
              l = 0;
            for (; l < o.path.length; ) {
              const c = o.path[l];
              l === o.path.length - 1
                ? ((i[c] = i[c] || { _errors: [] }), i[c]._errors.push(r(o)))
                : (i[c] = i[c] || { _errors: [] }),
                (i = i[c]),
                l++;
            }
          }
      };
    return n(t), a;
  }
  const Gk = (t) => (e, r, a, n) => {
      const s = a ? Object.assign(a, { async: !1 }) : { async: !1 },
        o = e._zod.run({ value: r, issues: [] }, s);
      if (o instanceof Promise) throw new js();
      if (o.issues.length) {
        const i = new ((n == null ? void 0 : n.Err) ?? t)(
          o.issues.map((l) => Pn(l, s, $n()))
        );
        throw (Xv(i, n == null ? void 0 : n.callee), i);
      }
      return o.value;
    },
    Wk = (t) => async (e, r, a, n) => {
      const s = a ? Object.assign(a, { async: !0 }) : { async: !0 };
      let o = e._zod.run({ value: r, issues: [] }, s);
      if ((o instanceof Promise && (o = await o), o.issues.length)) {
        const i = new ((n == null ? void 0 : n.Err) ?? t)(
          o.issues.map((l) => Pn(l, s, $n()))
        );
        throw (Xv(i, n == null ? void 0 : n.callee), i);
      }
      return o.value;
    },
    ng = (t) => (e, r, a) => {
      const n = a ? { ...a, async: !1 } : { async: !1 },
        s = e._zod.run({ value: r, issues: [] }, n);
      if (s instanceof Promise) throw new js();
      return s.issues.length
        ? {
            success: !1,
            error: new (t ?? tg)(s.issues.map((o) => Pn(o, n, $n()))),
          }
        : { success: !0, data: s.value };
    },
    Qk = ng(rg),
    ag = (t) => async (e, r, a) => {
      const n = a ? Object.assign(a, { async: !0 }) : { async: !0 };
      let s = e._zod.run({ value: r, issues: [] }, n);
      return (
        s instanceof Promise && (s = await s),
        s.issues.length
          ? { success: !1, error: new t(s.issues.map((o) => Pn(o, n, $n()))) }
          : { success: !0, data: s.value }
      );
    },
    Yk = ag(rg),
    Xk = /^[cC][^\s-]{8,}$/,
    eC = /^[0-9a-z]+$/,
    tC = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,
    rC = /^[0-9a-vA-V]{20}$/,
    nC = /^[A-Za-z0-9]{27}$/,
    aC = /^[a-zA-Z0-9_-]{21}$/,
    sC =
      /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/,
    oC =
      /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,
    sg = (t) =>
      t
        ? new RegExp(
            `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${t}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`
          )
        : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/,
    iC =
      /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,
    lC = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
  function cC() {
    return new RegExp(lC, "u");
  }
  const uC =
      /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    dC =
      /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/,
    fC =
      /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,
    pC =
      /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    hC =
      /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,
    og = /^[A-Za-z0-9_-]*$/,
    mC = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/,
    vC = /^\+(?:[0-9]){6,14}[0-9]$/,
    ig =
      "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))",
    gC = new RegExp(`^${ig}$`);
  function lg(t) {
    const e = "(?:[01]\\d|2[0-3]):[0-5]\\d";
    return typeof t.precision == "number"
      ? t.precision === -1
        ? `${e}`
        : t.precision === 0
        ? `${e}:[0-5]\\d`
        : `${e}:[0-5]\\d\\.\\d{${t.precision}}`
      : `${e}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  }
  function yC(t) {
    return new RegExp(`^${lg(t)}$`);
  }
  function _C(t) {
    const e = lg({ precision: t.precision }),
      r = ["Z"];
    t.local && r.push(""), t.offset && r.push("([+-]\\d{2}:\\d{2})");
    const a = `${e}(?:${r.join("|")})`;
    return new RegExp(`^${ig}T(?:${a})$`);
  }
  const wC = (t) => {
      const e = t
        ? `[\\s\\S]{${(t == null ? void 0 : t.minimum) ?? 0},${
            (t == null ? void 0 : t.maximum) ?? ""
          }}`
        : "[\\s\\S]*";
      return new RegExp(`^${e}$`);
    },
    bC = /^\d+$/,
    EC = /^-?\d+(?:\.\d+)?/i,
    SC = /true|false/i,
    $C = /null/i,
    PC = /^[^A-Z]*$/,
    TC = /^[^a-z]*$/,
    Yt = B("$ZodCheck", (t, e) => {
      var r;
      t._zod ?? (t._zod = {}),
        (t._zod.def = e),
        (r = t._zod).onattach ?? (r.onattach = []);
    }),
    cg = { number: "number", bigint: "bigint", object: "date" },
    ug = B("$ZodCheckLessThan", (t, e) => {
      Yt.init(t, e);
      const r = cg[typeof e.value];
      t._zod.onattach.push((a) => {
        const n = a._zod.bag,
          s =
            (e.inclusive ? n.maximum : n.exclusiveMaximum) ??
            Number.POSITIVE_INFINITY;
        e.value < s &&
          (e.inclusive
            ? (n.maximum = e.value)
            : (n.exclusiveMaximum = e.value));
      }),
        (t._zod.check = (a) => {
          (e.inclusive ? a.value <= e.value : a.value < e.value) ||
            a.issues.push({
              origin: r,
              code: "too_big",
              maximum: e.value,
              input: a.value,
              inclusive: e.inclusive,
              inst: t,
              continue: !e.abort,
            });
        });
    }),
    dg = B("$ZodCheckGreaterThan", (t, e) => {
      Yt.init(t, e);
      const r = cg[typeof e.value];
      t._zod.onattach.push((a) => {
        const n = a._zod.bag,
          s =
            (e.inclusive ? n.minimum : n.exclusiveMinimum) ??
            Number.NEGATIVE_INFINITY;
        e.value > s &&
          (e.inclusive
            ? (n.minimum = e.value)
            : (n.exclusiveMinimum = e.value));
      }),
        (t._zod.check = (a) => {
          (e.inclusive ? a.value >= e.value : a.value > e.value) ||
            a.issues.push({
              origin: r,
              code: "too_small",
              minimum: e.value,
              input: a.value,
              inclusive: e.inclusive,
              inst: t,
              continue: !e.abort,
            });
        });
    }),
    xC = B("$ZodCheckMultipleOf", (t, e) => {
      Yt.init(t, e),
        t._zod.onattach.push((r) => {
          var a;
          (a = r._zod.bag).multipleOf ?? (a.multipleOf = e.value);
        }),
        (t._zod.check = (r) => {
          if (typeof r.value != typeof e.value)
            throw new Error(
              "Cannot mix number and bigint in multiple_of check."
            );
          (typeof r.value == "bigint"
            ? r.value % e.value === BigInt(0)
            : jk(r.value, e.value) === 0) ||
            r.issues.push({
              origin: typeof r.value,
              code: "not_multiple_of",
              divisor: e.value,
              input: r.value,
              inst: t,
              continue: !e.abort,
            });
        });
    }),
    IC = B("$ZodCheckNumberFormat", (t, e) => {
      var o;
      Yt.init(t, e), (e.format = e.format || "float64");
      const r = (o = e.format) == null ? void 0 : o.includes("int"),
        a = r ? "int" : "number",
        [n, s] = qk[e.format];
      t._zod.onattach.push((i) => {
        const l = i._zod.bag;
        (l.format = e.format),
          (l.minimum = n),
          (l.maximum = s),
          r && (l.pattern = bC);
      }),
        (t._zod.check = (i) => {
          const l = i.value;
          if (r) {
            if (!Number.isInteger(l)) {
              i.issues.push({
                expected: a,
                format: e.format,
                code: "invalid_type",
                input: l,
                inst: t,
              });
              return;
            }
            if (!Number.isSafeInteger(l)) {
              l > 0
                ? i.issues.push({
                    input: l,
                    code: "too_big",
                    maximum: Number.MAX_SAFE_INTEGER,
                    note: "Integers must be within the safe integer range.",
                    inst: t,
                    origin: a,
                    continue: !e.abort,
                  })
                : i.issues.push({
                    input: l,
                    code: "too_small",
                    minimum: Number.MIN_SAFE_INTEGER,
                    note: "Integers must be within the safe integer range.",
                    inst: t,
                    origin: a,
                    continue: !e.abort,
                  });
              return;
            }
          }
          l < n &&
            i.issues.push({
              origin: "number",
              input: l,
              code: "too_small",
              minimum: n,
              inclusive: !0,
              inst: t,
              continue: !e.abort,
            }),
            l > s &&
              i.issues.push({
                origin: "number",
                input: l,
                code: "too_big",
                maximum: s,
                inst: t,
              });
        });
    }),
    kC = B("$ZodCheckMaxLength", (t, e) => {
      var r;
      Yt.init(t, e),
        (r = t._zod.def).when ??
          (r.when = (a) => {
            const n = a.value;
            return !hd(n) && n.length !== void 0;
          }),
        t._zod.onattach.push((a) => {
          const n = a._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
          e.maximum < n && (a._zod.bag.maximum = e.maximum);
        }),
        (t._zod.check = (a) => {
          const n = a.value;
          if (n.length <= e.maximum) return;
          const o = vd(n);
          a.issues.push({
            origin: o,
            code: "too_big",
            maximum: e.maximum,
            inclusive: !0,
            input: n,
            inst: t,
            continue: !e.abort,
          });
        });
    }),
    CC = B("$ZodCheckMinLength", (t, e) => {
      var r;
      Yt.init(t, e),
        (r = t._zod.def).when ??
          (r.when = (a) => {
            const n = a.value;
            return !hd(n) && n.length !== void 0;
          }),
        t._zod.onattach.push((a) => {
          const n = a._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
          e.minimum > n && (a._zod.bag.minimum = e.minimum);
        }),
        (t._zod.check = (a) => {
          const n = a.value;
          if (n.length >= e.minimum) return;
          const o = vd(n);
          a.issues.push({
            origin: o,
            code: "too_small",
            minimum: e.minimum,
            inclusive: !0,
            input: n,
            inst: t,
            continue: !e.abort,
          });
        });
    }),
    RC = B("$ZodCheckLengthEquals", (t, e) => {
      var r;
      Yt.init(t, e),
        (r = t._zod.def).when ??
          (r.when = (a) => {
            const n = a.value;
            return !hd(n) && n.length !== void 0;
          }),
        t._zod.onattach.push((a) => {
          const n = a._zod.bag;
          (n.minimum = e.length), (n.maximum = e.length), (n.length = e.length);
        }),
        (t._zod.check = (a) => {
          const n = a.value,
            s = n.length;
          if (s === e.length) return;
          const o = vd(n),
            i = s > e.length;
          a.issues.push({
            origin: o,
            ...(i
              ? { code: "too_big", maximum: e.length }
              : { code: "too_small", minimum: e.length }),
            inclusive: !0,
            exact: !0,
            input: a.value,
            inst: t,
            continue: !e.abort,
          });
        });
    }),
    Zi = B("$ZodCheckStringFormat", (t, e) => {
      var r, a;
      Yt.init(t, e),
        t._zod.onattach.push((n) => {
          const s = n._zod.bag;
          (s.format = e.format),
            e.pattern &&
              (s.patterns ?? (s.patterns = new Set()),
              s.patterns.add(e.pattern));
        }),
        e.pattern
          ? (r = t._zod).check ??
            (r.check = (n) => {
              (e.pattern.lastIndex = 0),
                !e.pattern.test(n.value) &&
                  n.issues.push({
                    origin: "string",
                    code: "invalid_format",
                    format: e.format,
                    input: n.value,
                    ...(e.pattern ? { pattern: e.pattern.toString() } : {}),
                    inst: t,
                    continue: !e.abort,
                  });
            })
          : (a = t._zod).check ?? (a.check = () => {});
    }),
    OC = B("$ZodCheckRegex", (t, e) => {
      Zi.init(t, e),
        (t._zod.check = (r) => {
          (e.pattern.lastIndex = 0),
            !e.pattern.test(r.value) &&
              r.issues.push({
                origin: "string",
                code: "invalid_format",
                format: "regex",
                input: r.value,
                pattern: e.pattern.toString(),
                inst: t,
                continue: !e.abort,
              });
        });
    }),
    AC = B("$ZodCheckLowerCase", (t, e) => {
      e.pattern ?? (e.pattern = PC), Zi.init(t, e);
    }),
    NC = B("$ZodCheckUpperCase", (t, e) => {
      e.pattern ?? (e.pattern = TC), Zi.init(t, e);
    }),
    MC = B("$ZodCheckIncludes", (t, e) => {
      Yt.init(t, e);
      const r = zs(e.includes),
        a = new RegExp(
          typeof e.position == "number" ? `^.{${e.position}}${r}` : r
        );
      (e.pattern = a),
        t._zod.onattach.push((n) => {
          const s = n._zod.bag;
          s.patterns ?? (s.patterns = new Set()), s.patterns.add(a);
        }),
        (t._zod.check = (n) => {
          n.value.includes(e.includes, e.position) ||
            n.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "includes",
              includes: e.includes,
              input: n.value,
              inst: t,
              continue: !e.abort,
            });
        });
    }),
    jC = B("$ZodCheckStartsWith", (t, e) => {
      Yt.init(t, e);
      const r = new RegExp(`^${zs(e.prefix)}.*`);
      e.pattern ?? (e.pattern = r),
        t._zod.onattach.push((a) => {
          const n = a._zod.bag;
          n.patterns ?? (n.patterns = new Set()), n.patterns.add(r);
        }),
        (t._zod.check = (a) => {
          a.value.startsWith(e.prefix) ||
            a.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "starts_with",
              prefix: e.prefix,
              input: a.value,
              inst: t,
              continue: !e.abort,
            });
        });
    }),
    DC = B("$ZodCheckEndsWith", (t, e) => {
      Yt.init(t, e);
      const r = new RegExp(`.*${zs(e.suffix)}$`);
      e.pattern ?? (e.pattern = r),
        t._zod.onattach.push((a) => {
          const n = a._zod.bag;
          n.patterns ?? (n.patterns = new Set()), n.patterns.add(r);
        }),
        (t._zod.check = (a) => {
          a.value.endsWith(e.suffix) ||
            a.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "ends_with",
              suffix: e.suffix,
              input: a.value,
              inst: t,
              continue: !e.abort,
            });
        });
    }),
    LC = B("$ZodCheckOverwrite", (t, e) => {
      Yt.init(t, e),
        (t._zod.check = (r) => {
          r.value = e.tx(r.value);
        });
    });
  class zC {
    constructor(e = []) {
      (this.content = []), (this.indent = 0), this && (this.args = e);
    }
    indented(e) {
      (this.indent += 1), e(this), (this.indent -= 1);
    }
    write(e) {
      if (typeof e == "function") {
        e(this, { execution: "sync" }), e(this, { execution: "async" });
        return;
      }
      const a = e
          .split(
            `
`
          )
          .filter((o) => o),
        n = Math.min(...a.map((o) => o.length - o.trimStart().length)),
        s = a
          .map((o) => o.slice(n))
          .map((o) => " ".repeat(this.indent * 2) + o);
      for (const o of s) this.content.push(o);
    }
    compile() {
      const e = Function,
        r = this == null ? void 0 : this.args,
        n = [
          ...((this == null ? void 0 : this.content) ?? [""]).map(
            (s) => `  ${s}`
          ),
        ];
      return new e(
        ...r,
        n.join(`
`)
      );
    }
  }
  const qC = { major: 4, minor: 0, patch: 0 },
    et = B("$ZodType", (t, e) => {
      var n;
      var r;
      t ?? (t = {}),
        (t._zod.def = e),
        (t._zod.bag = t._zod.bag || {}),
        (t._zod.version = qC);
      const a = [...(t._zod.def.checks ?? [])];
      t._zod.traits.has("$ZodCheck") && a.unshift(t);
      for (const s of a) for (const o of s._zod.onattach) o(t);
      if (a.length === 0)
        (r = t._zod).deferred ?? (r.deferred = []),
          (n = t._zod.deferred) == null ||
            n.push(() => {
              t._zod.run = t._zod.parse;
            });
      else {
        const s = (o, i, l) => {
          let c = qs(o),
            u;
          for (const f of i) {
            if (f._zod.def.when) {
              if (!f._zod.def.when(o)) continue;
            } else if (c) continue;
            const v = o.issues.length,
              d = f._zod.check(o);
            if (d instanceof Promise && (l == null ? void 0 : l.async) === !1)
              throw new js();
            if (u || d instanceof Promise)
              u = (u ?? Promise.resolve()).then(async () => {
                await d, o.issues.length !== v && (c || (c = qs(o, v)));
              });
            else {
              if (o.issues.length === v) continue;
              c || (c = qs(o, v));
            }
          }
          return u ? u.then(() => o) : o;
        };
        t._zod.run = (o, i) => {
          const l = t._zod.parse(o, i);
          if (l instanceof Promise) {
            if (i.async === !1) throw new js();
            return l.then((c) => s(c, a, i));
          }
          return s(l, a, i);
        };
      }
      t["~standard"] = {
        validate: (s) => {
          var o;
          try {
            const i = Qk(t, s);
            return i.success
              ? { value: i.data }
              : { issues: (o = i.error) == null ? void 0 : o.issues };
          } catch {
            return Yk(t, s).then((l) => {
              var c;
              return l.success
                ? { value: l.data }
                : { issues: (c = l.error) == null ? void 0 : c.issues };
            });
          }
        },
        vendor: "zod",
        version: 1,
      };
    }),
    gd = B("$ZodString", (t, e) => {
      var r;
      et.init(t, e),
        (t._zod.pattern =
          [
            ...(((r = t == null ? void 0 : t._zod.bag) == null
              ? void 0
              : r.patterns) ?? []),
          ].pop() ?? wC(t._zod.bag)),
        (t._zod.parse = (a, n) => {
          if (e.coerce)
            try {
              a.value = String(a.value);
            } catch {}
          return (
            typeof a.value == "string" ||
              a.issues.push({
                expected: "string",
                code: "invalid_type",
                input: a.value,
                inst: t,
              }),
            a
          );
        });
    }),
    ut = B("$ZodStringFormat", (t, e) => {
      Zi.init(t, e), gd.init(t, e);
    }),
    UC = B("$ZodGUID", (t, e) => {
      e.pattern ?? (e.pattern = oC), ut.init(t, e);
    }),
    FC = B("$ZodUUID", (t, e) => {
      if (e.version) {
        const a = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[
          e.version
        ];
        if (a === void 0)
          throw new Error(`Invalid UUID version: "${e.version}"`);
        e.pattern ?? (e.pattern = sg(a));
      } else e.pattern ?? (e.pattern = sg());
      ut.init(t, e);
    }),
    VC = B("$ZodEmail", (t, e) => {
      e.pattern ?? (e.pattern = iC), ut.init(t, e);
    }),
    ZC = B("$ZodURL", (t, e) => {
      ut.init(t, e),
        (t._zod.check = (r) => {
          try {
            const a = r.value,
              n = new URL(a),
              s = n.href;
            e.hostname &&
              ((e.hostname.lastIndex = 0),
              e.hostname.test(n.hostname) ||
                r.issues.push({
                  code: "invalid_format",
                  format: "url",
                  note: "Invalid hostname",
                  pattern: mC.source,
                  input: r.value,
                  inst: t,
                  continue: !e.abort,
                })),
              e.protocol &&
                ((e.protocol.lastIndex = 0),
                e.protocol.test(
                  n.protocol.endsWith(":")
                    ? n.protocol.slice(0, -1)
                    : n.protocol
                ) ||
                  r.issues.push({
                    code: "invalid_format",
                    format: "url",
                    note: "Invalid protocol",
                    pattern: e.protocol.source,
                    input: r.value,
                    inst: t,
                    continue: !e.abort,
                  })),
              !a.endsWith("/") && s.endsWith("/")
                ? (r.value = s.slice(0, -1))
                : (r.value = s);
            return;
          } catch {
            r.issues.push({
              code: "invalid_format",
              format: "url",
              input: r.value,
              inst: t,
              continue: !e.abort,
            });
          }
        });
    }),
    HC = B("$ZodEmoji", (t, e) => {
      e.pattern ?? (e.pattern = cC()), ut.init(t, e);
    }),
    BC = B("$ZodNanoID", (t, e) => {
      e.pattern ?? (e.pattern = aC), ut.init(t, e);
    }),
    JC = B("$ZodCUID", (t, e) => {
      e.pattern ?? (e.pattern = Xk), ut.init(t, e);
    }),
    KC = B("$ZodCUID2", (t, e) => {
      e.pattern ?? (e.pattern = eC), ut.init(t, e);
    }),
    GC = B("$ZodULID", (t, e) => {
      e.pattern ?? (e.pattern = tC), ut.init(t, e);
    }),
    WC = B("$ZodXID", (t, e) => {
      e.pattern ?? (e.pattern = rC), ut.init(t, e);
    }),
    QC = B("$ZodKSUID", (t, e) => {
      e.pattern ?? (e.pattern = nC), ut.init(t, e);
    }),
    YC = B("$ZodISODateTime", (t, e) => {
      e.pattern ?? (e.pattern = _C(e)), ut.init(t, e);
    }),
    XC = B("$ZodISODate", (t, e) => {
      e.pattern ?? (e.pattern = gC), ut.init(t, e);
    }),
    eR = B("$ZodISOTime", (t, e) => {
      e.pattern ?? (e.pattern = yC(e)), ut.init(t, e);
    }),
    tR = B("$ZodISODuration", (t, e) => {
      e.pattern ?? (e.pattern = sC), ut.init(t, e);
    }),
    rR = B("$ZodIPv4", (t, e) => {
      e.pattern ?? (e.pattern = uC),
        ut.init(t, e),
        t._zod.onattach.push((r) => {
          const a = r._zod.bag;
          a.format = "ipv4";
        });
    }),
    nR = B("$ZodIPv6", (t, e) => {
      e.pattern ?? (e.pattern = dC),
        ut.init(t, e),
        t._zod.onattach.push((r) => {
          const a = r._zod.bag;
          a.format = "ipv6";
        }),
        (t._zod.check = (r) => {
          try {
            new URL(`http://[${r.value}]`);
          } catch {
            r.issues.push({
              code: "invalid_format",
              format: "ipv6",
              input: r.value,
              inst: t,
              continue: !e.abort,
            });
          }
        });
    }),
    aR = B("$ZodCIDRv4", (t, e) => {
      e.pattern ?? (e.pattern = fC), ut.init(t, e);
    }),
    sR = B("$ZodCIDRv6", (t, e) => {
      e.pattern ?? (e.pattern = pC),
        ut.init(t, e),
        (t._zod.check = (r) => {
          const [a, n] = r.value.split("/");
          try {
            if (!n) throw new Error();
            const s = Number(n);
            if (`${s}` !== n) throw new Error();
            if (s < 0 || s > 128) throw new Error();
            new URL(`http://[${a}]`);
          } catch {
            r.issues.push({
              code: "invalid_format",
              format: "cidrv6",
              input: r.value,
              inst: t,
              continue: !e.abort,
            });
          }
        });
    });
  function fg(t) {
    if (t === "") return !0;
    if (t.length % 4 !== 0) return !1;
    try {
      return atob(t), !0;
    } catch {
      return !1;
    }
  }
  const oR = B("$ZodBase64", (t, e) => {
    e.pattern ?? (e.pattern = hC),
      ut.init(t, e),
      t._zod.onattach.push((r) => {
        r._zod.bag.contentEncoding = "base64";
      }),
      (t._zod.check = (r) => {
        fg(r.value) ||
          r.issues.push({
            code: "invalid_format",
            format: "base64",
            input: r.value,
            inst: t,
            continue: !e.abort,
          });
      });
  });
  function iR(t) {
    if (!og.test(t)) return !1;
    const e = t.replace(/[-_]/g, (a) => (a === "-" ? "+" : "/")),
      r = e.padEnd(Math.ceil(e.length / 4) * 4, "=");
    return fg(r);
  }
  const lR = B("$ZodBase64URL", (t, e) => {
      e.pattern ?? (e.pattern = og),
        ut.init(t, e),
        t._zod.onattach.push((r) => {
          r._zod.bag.contentEncoding = "base64url";
        }),
        (t._zod.check = (r) => {
          iR(r.value) ||
            r.issues.push({
              code: "invalid_format",
              format: "base64url",
              input: r.value,
              inst: t,
              continue: !e.abort,
            });
        });
    }),
    cR = B("$ZodE164", (t, e) => {
      e.pattern ?? (e.pattern = vC), ut.init(t, e);
    });
  function uR(t, e = null) {
    try {
      const r = t.split(".");
      if (r.length !== 3) return !1;
      const [a] = r;
      if (!a) return !1;
      const n = JSON.parse(atob(a));
      return !(
        ("typ" in n && (n == null ? void 0 : n.typ) !== "JWT") ||
        !n.alg ||
        (e && (!("alg" in n) || n.alg !== e))
      );
    } catch {
      return !1;
    }
  }
  const dR = B("$ZodJWT", (t, e) => {
      ut.init(t, e),
        (t._zod.check = (r) => {
          uR(r.value, e.alg) ||
            r.issues.push({
              code: "invalid_format",
              format: "jwt",
              input: r.value,
              inst: t,
              continue: !e.abort,
            });
        });
    }),
    pg = B("$ZodNumber", (t, e) => {
      et.init(t, e),
        (t._zod.pattern = t._zod.bag.pattern ?? EC),
        (t._zod.parse = (r, a) => {
          if (e.coerce)
            try {
              r.value = Number(r.value);
            } catch {}
          const n = r.value;
          if (typeof n == "number" && !Number.isNaN(n) && Number.isFinite(n))
            return r;
          const s =
            typeof n == "number"
              ? Number.isNaN(n)
                ? "NaN"
                : Number.isFinite(n)
                ? void 0
                : "Infinity"
              : void 0;
          return (
            r.issues.push({
              expected: "number",
              code: "invalid_type",
              input: n,
              inst: t,
              ...(s ? { received: s } : {}),
            }),
            r
          );
        });
    }),
    fR = B("$ZodNumber", (t, e) => {
      IC.init(t, e), pg.init(t, e);
    }),
    pR = B("$ZodBoolean", (t, e) => {
      et.init(t, e),
        (t._zod.pattern = SC),
        (t._zod.parse = (r, a) => {
          if (e.coerce)
            try {
              r.value = !!r.value;
            } catch {}
          const n = r.value;
          return (
            typeof n == "boolean" ||
              r.issues.push({
                expected: "boolean",
                code: "invalid_type",
                input: n,
                inst: t,
              }),
            r
          );
        });
    }),
    hR = B("$ZodNull", (t, e) => {
      et.init(t, e),
        (t._zod.pattern = $C),
        (t._zod.values = new Set([null])),
        (t._zod.parse = (r, a) => {
          const n = r.value;
          return (
            n === null ||
              r.issues.push({
                expected: "null",
                code: "invalid_type",
                input: n,
                inst: t,
              }),
            r
          );
        });
    }),
    mR = B("$ZodAny", (t, e) => {
      et.init(t, e), (t._zod.parse = (r) => r);
    }),
    vR = B("$ZodUnknown", (t, e) => {
      et.init(t, e), (t._zod.parse = (r) => r);
    }),
    gR = B("$ZodNever", (t, e) => {
      et.init(t, e),
        (t._zod.parse = (r, a) => (
          r.issues.push({
            expected: "never",
            code: "invalid_type",
            input: r.value,
            inst: t,
          }),
          r
        ));
    });
  function hg(t, e, r) {
    t.issues.length && e.issues.push(...Bn(r, t.issues)),
      (e.value[r] = t.value);
  }
  const yR = B("$ZodArray", (t, e) => {
    et.init(t, e),
      (t._zod.parse = (r, a) => {
        const n = r.value;
        if (!Array.isArray(n))
          return (
            r.issues.push({
              expected: "array",
              code: "invalid_type",
              input: n,
              inst: t,
            }),
            r
          );
        r.value = Array(n.length);
        const s = [];
        for (let o = 0; o < n.length; o++) {
          const i = n[o],
            l = e.element._zod.run({ value: i, issues: [] }, a);
          l instanceof Promise
            ? s.push(l.then((c) => hg(c, r, o)))
            : hg(l, r, o);
        }
        return s.length ? Promise.all(s).then(() => r) : r;
      });
  });
  function Hi(t, e, r) {
    t.issues.length && e.issues.push(...Bn(r, t.issues)),
      (e.value[r] = t.value);
  }
  function mg(t, e, r, a) {
    t.issues.length
      ? a[r] === void 0
        ? r in a
          ? (e.value[r] = void 0)
          : (e.value[r] = t.value)
        : e.issues.push(...Bn(r, t.issues))
      : t.value === void 0
      ? r in a && (e.value[r] = void 0)
      : (e.value[r] = t.value);
  }
  const _R = B("$ZodObject", (t, e) => {
    et.init(t, e);
    const r = pd(() => {
      const f = Object.keys(e.shape);
      for (const d of f)
        if (!(e.shape[d] instanceof et))
          throw new Error(
            `Invalid element at key "${d}": expected a Zod schema`
          );
      const v = zk(e.shape);
      return {
        shape: e.shape,
        keys: f,
        keySet: new Set(f),
        numKeys: f.length,
        optionalKeys: new Set(v),
      };
    });
    Be(t._zod, "propValues", () => {
      const f = e.shape,
        v = {};
      for (const d in f) {
        const p = f[d]._zod;
        if (p.values) {
          v[d] ?? (v[d] = new Set());
          for (const g of p.values) v[d].add(g);
        }
      }
      return v;
    });
    const a = (f) => {
      const v = new zC(["shape", "payload", "ctx"]),
        d = r.value,
        p = (y) => {
          const _ = Ls(y);
          return `shape[${_}]._zod.run({ value: input[${_}], issues: [] }, ctx)`;
        };
      v.write("const input = payload.value;");
      const g = Object.create(null);
      let m = 0;
      for (const y of d.keys) g[y] = `key_${m++}`;
      v.write("const newResult = {}");
      for (const y of d.keys)
        if (d.optionalKeys.has(y)) {
          const _ = g[y];
          v.write(`const ${_} = ${p(y)};`);
          const w = Ls(y);
          v.write(`
        if (${_}.issues.length) {
          if (input[${w}] === undefined) {
            if (${w} in input) {
              newResult[${w}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${_}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${w}, ...iss.path] : [${w}],
              }))
            );
          }
        } else if (${_}.value === undefined) {
          if (${w} in input) newResult[${w}] = undefined;
        } else {
          newResult[${w}] = ${_}.value;
        }
        `);
        } else {
          const _ = g[y];
          v.write(`const ${_} = ${p(y)};`),
            v.write(`
          if (${_}.issues.length) payload.issues = payload.issues.concat(${_}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${Ls(y)}, ...iss.path] : [${Ls(y)}]
          })));`),
            v.write(`newResult[${Ls(y)}] = ${_}.value`);
        }
      v.write("payload.value = newResult;"), v.write("return payload;");
      const h = v.compile();
      return (y, _) => h(f, y, _);
    };
    let n;
    const s = Ui,
      o = !Qv.jitless,
      l = o && Dk.value,
      c = e.catchall;
    let u;
    t._zod.parse = (f, v) => {
      u ?? (u = r.value);
      const d = f.value;
      if (!s(d))
        return (
          f.issues.push({
            expected: "object",
            code: "invalid_type",
            input: d,
            inst: t,
          }),
          f
        );
      const p = [];
      if (o && l && (v == null ? void 0 : v.async) === !1 && v.jitless !== !0)
        n || (n = a(e.shape)), (f = n(f, v));
      else {
        f.value = {};
        const _ = u.shape;
        for (const w of u.keys) {
          const E = _[w],
            P = E._zod.run({ value: d[w], issues: [] }, v),
            x = E._zod.optin === "optional" && E._zod.optout === "optional";
          P instanceof Promise
            ? p.push(P.then((A) => (x ? mg(A, f, w, d) : Hi(A, f, w))))
            : x
            ? mg(P, f, w, d)
            : Hi(P, f, w);
        }
      }
      if (!c) return p.length ? Promise.all(p).then(() => f) : f;
      const g = [],
        m = u.keySet,
        h = c._zod,
        y = h.def.type;
      for (const _ of Object.keys(d)) {
        if (m.has(_)) continue;
        if (y === "never") {
          g.push(_);
          continue;
        }
        const w = h.run({ value: d[_], issues: [] }, v);
        w instanceof Promise ? p.push(w.then((E) => Hi(E, f, _))) : Hi(w, f, _);
      }
      return (
        g.length &&
          f.issues.push({
            code: "unrecognized_keys",
            keys: g,
            input: d,
            inst: t,
          }),
        p.length ? Promise.all(p).then(() => f) : f
      );
    };
  });
  function vg(t, e, r, a) {
    for (const n of t) if (n.issues.length === 0) return (e.value = n.value), e;
    return (
      e.issues.push({
        code: "invalid_union",
        input: e.value,
        inst: r,
        errors: t.map((n) => n.issues.map((s) => Pn(s, a, $n()))),
      }),
      e
    );
  }
  const gg = B("$ZodUnion", (t, e) => {
      et.init(t, e),
        Be(t._zod, "optin", () =>
          e.options.some((r) => r._zod.optin === "optional")
            ? "optional"
            : void 0
        ),
        Be(t._zod, "optout", () =>
          e.options.some((r) => r._zod.optout === "optional")
            ? "optional"
            : void 0
        ),
        Be(t._zod, "values", () => {
          if (e.options.every((r) => r._zod.values))
            return new Set(e.options.flatMap((r) => Array.from(r._zod.values)));
        }),
        Be(t._zod, "pattern", () => {
          if (e.options.every((r) => r._zod.pattern)) {
            const r = e.options.map((a) => a._zod.pattern);
            return new RegExp(`^(${r.map((a) => md(a.source)).join("|")})$`);
          }
        }),
        (t._zod.parse = (r, a) => {
          let n = !1;
          const s = [];
          for (const o of e.options) {
            const i = o._zod.run({ value: r.value, issues: [] }, a);
            if (i instanceof Promise) s.push(i), (n = !0);
            else {
              if (i.issues.length === 0) return i;
              s.push(i);
            }
          }
          return n
            ? Promise.all(s).then((o) => vg(o, r, t, a))
            : vg(s, r, t, a);
        });
    }),
    wR = B("$ZodDiscriminatedUnion", (t, e) => {
      gg.init(t, e);
      const r = t._zod.parse;
      Be(t._zod, "propValues", () => {
        const n = {};
        for (const s of e.options) {
          const o = s._zod.propValues;
          if (!o || Object.keys(o).length === 0)
            throw new Error(
              `Invalid discriminated union option at index "${e.options.indexOf(
                s
              )}"`
            );
          for (const [i, l] of Object.entries(o)) {
            n[i] || (n[i] = new Set());
            for (const c of l) n[i].add(c);
          }
        }
        return n;
      });
      const a = pd(() => {
        const n = e.options,
          s = new Map();
        for (const o of n) {
          const i = o._zod.propValues[e.discriminator];
          if (!i || i.size === 0)
            throw new Error(
              `Invalid discriminated union option at index "${e.options.indexOf(
                o
              )}"`
            );
          for (const l of i) {
            if (s.has(l))
              throw new Error(`Duplicate discriminator value "${String(l)}"`);
            s.set(l, o);
          }
        }
        return s;
      });
      t._zod.parse = (n, s) => {
        const o = n.value;
        if (!Ui(o))
          return (
            n.issues.push({
              code: "invalid_type",
              expected: "object",
              input: o,
              inst: t,
            }),
            n
          );
        const i = a.value.get(o == null ? void 0 : o[e.discriminator]);
        return i
          ? i._zod.run(n, s)
          : e.unionFallback
          ? r(n, s)
          : (n.issues.push({
              code: "invalid_union",
              errors: [],
              note: "No matching discriminator",
              input: o,
              path: [e.discriminator],
              inst: t,
            }),
            n);
      };
    }),
    bR = B("$ZodIntersection", (t, e) => {
      et.init(t, e),
        (t._zod.parse = (r, a) => {
          const n = r.value,
            s = e.left._zod.run({ value: n, issues: [] }, a),
            o = e.right._zod.run({ value: n, issues: [] }, a);
          return s instanceof Promise || o instanceof Promise
            ? Promise.all([s, o]).then(([l, c]) => yg(r, l, c))
            : yg(r, s, o);
        });
    });
  function yd(t, e) {
    if (t === e) return { valid: !0, data: t };
    if (t instanceof Date && e instanceof Date && +t == +e)
      return { valid: !0, data: t };
    if (Fi(t) && Fi(e)) {
      const r = Object.keys(e),
        a = Object.keys(t).filter((s) => r.indexOf(s) !== -1),
        n = { ...t, ...e };
      for (const s of a) {
        const o = yd(t[s], e[s]);
        if (!o.valid)
          return { valid: !1, mergeErrorPath: [s, ...o.mergeErrorPath] };
        n[s] = o.data;
      }
      return { valid: !0, data: n };
    }
    if (Array.isArray(t) && Array.isArray(e)) {
      if (t.length !== e.length) return { valid: !1, mergeErrorPath: [] };
      const r = [];
      for (let a = 0; a < t.length; a++) {
        const n = t[a],
          s = e[a],
          o = yd(n, s);
        if (!o.valid)
          return { valid: !1, mergeErrorPath: [a, ...o.mergeErrorPath] };
        r.push(o.data);
      }
      return { valid: !0, data: r };
    }
    return { valid: !1, mergeErrorPath: [] };
  }
  function yg(t, e, r) {
    if (
      (e.issues.length && t.issues.push(...e.issues),
      r.issues.length && t.issues.push(...r.issues),
      qs(t))
    )
      return t;
    const a = yd(e.value, r.value);
    if (!a.valid)
      throw new Error(
        `Unmergable intersection. Error path: ${JSON.stringify(
          a.mergeErrorPath
        )}`
      );
    return (t.value = a.data), t;
  }
  const ER = B("$ZodRecord", (t, e) => {
      et.init(t, e),
        (t._zod.parse = (r, a) => {
          const n = r.value;
          if (!Fi(n))
            return (
              r.issues.push({
                expected: "record",
                code: "invalid_type",
                input: n,
                inst: t,
              }),
              r
            );
          const s = [];
          if (e.keyType._zod.values) {
            const o = e.keyType._zod.values;
            r.value = {};
            for (const l of o)
              if (
                typeof l == "string" ||
                typeof l == "number" ||
                typeof l == "symbol"
              ) {
                const c = e.valueType._zod.run({ value: n[l], issues: [] }, a);
                c instanceof Promise
                  ? s.push(
                      c.then((u) => {
                        u.issues.length && r.issues.push(...Bn(l, u.issues)),
                          (r.value[l] = u.value);
                      })
                    )
                  : (c.issues.length && r.issues.push(...Bn(l, c.issues)),
                    (r.value[l] = c.value));
              }
            let i;
            for (const l in n) o.has(l) || ((i = i ?? []), i.push(l));
            i &&
              i.length > 0 &&
              r.issues.push({
                code: "unrecognized_keys",
                input: n,
                inst: t,
                keys: i,
              });
          } else {
            r.value = {};
            for (const o of Reflect.ownKeys(n)) {
              if (o === "__proto__") continue;
              const i = e.keyType._zod.run({ value: o, issues: [] }, a);
              if (i instanceof Promise)
                throw new Error(
                  "Async schemas not supported in object keys currently"
                );
              if (i.issues.length) {
                r.issues.push({
                  origin: "record",
                  code: "invalid_key",
                  issues: i.issues.map((c) => Pn(c, a, $n())),
                  input: o,
                  path: [o],
                  inst: t,
                }),
                  (r.value[i.value] = i.value);
                continue;
              }
              const l = e.valueType._zod.run({ value: n[o], issues: [] }, a);
              l instanceof Promise
                ? s.push(
                    l.then((c) => {
                      c.issues.length && r.issues.push(...Bn(o, c.issues)),
                        (r.value[i.value] = c.value);
                    })
                  )
                : (l.issues.length && r.issues.push(...Bn(o, l.issues)),
                  (r.value[i.value] = l.value));
            }
          }
          return s.length ? Promise.all(s).then(() => r) : r;
        });
    }),
    SR = B("$ZodEnum", (t, e) => {
      et.init(t, e);
      const r = Yv(e.entries);
      (t._zod.values = new Set(r)),
        (t._zod.pattern = new RegExp(
          `^(${r
            .filter((a) => Lk.has(typeof a))
            .map((a) => (typeof a == "string" ? zs(a) : a.toString()))
            .join("|")})$`
        )),
        (t._zod.parse = (a, n) => {
          const s = a.value;
          return (
            t._zod.values.has(s) ||
              a.issues.push({
                code: "invalid_value",
                values: r,
                input: s,
                inst: t,
              }),
            a
          );
        });
    }),
    $R = B("$ZodLiteral", (t, e) => {
      et.init(t, e),
        (t._zod.values = new Set(e.values)),
        (t._zod.pattern = new RegExp(
          `^(${e.values
            .map((r) =>
              typeof r == "string" ? zs(r) : r ? r.toString() : String(r)
            )
            .join("|")})$`
        )),
        (t._zod.parse = (r, a) => {
          const n = r.value;
          return (
            t._zod.values.has(n) ||
              r.issues.push({
                code: "invalid_value",
                values: e.values,
                input: n,
                inst: t,
              }),
            r
          );
        });
    }),
    PR = B("$ZodTransform", (t, e) => {
      et.init(t, e),
        (t._zod.parse = (r, a) => {
          const n = e.transform(r.value, r);
          if (a.async)
            return (n instanceof Promise ? n : Promise.resolve(n)).then(
              (o) => ((r.value = o), r)
            );
          if (n instanceof Promise) throw new js();
          return (r.value = n), r;
        });
    }),
    TR = B("$ZodOptional", (t, e) => {
      et.init(t, e),
        (t._zod.optin = "optional"),
        (t._zod.optout = "optional"),
        Be(t._zod, "values", () =>
          e.innerType._zod.values
            ? new Set([...e.innerType._zod.values, void 0])
            : void 0
        ),
        Be(t._zod, "pattern", () => {
          const r = e.innerType._zod.pattern;
          return r ? new RegExp(`^(${md(r.source)})?$`) : void 0;
        }),
        (t._zod.parse = (r, a) =>
          e.innerType._zod.optin === "optional"
            ? e.innerType._zod.run(r, a)
            : r.value === void 0
            ? r
            : e.innerType._zod.run(r, a));
    }),
    xR = B("$ZodNullable", (t, e) => {
      et.init(t, e),
        Be(t._zod, "optin", () => e.innerType._zod.optin),
        Be(t._zod, "optout", () => e.innerType._zod.optout),
        Be(t._zod, "pattern", () => {
          const r = e.innerType._zod.pattern;
          return r ? new RegExp(`^(${md(r.source)}|null)$`) : void 0;
        }),
        Be(t._zod, "values", () =>
          e.innerType._zod.values
            ? new Set([...e.innerType._zod.values, null])
            : void 0
        ),
        (t._zod.parse = (r, a) =>
          r.value === null ? r : e.innerType._zod.run(r, a));
    }),
    IR = B("$ZodDefault", (t, e) => {
      et.init(t, e),
        (t._zod.optin = "optional"),
        Be(t._zod, "values", () => e.innerType._zod.values),
        (t._zod.parse = (r, a) => {
          if (r.value === void 0) return (r.value = e.defaultValue), r;
          const n = e.innerType._zod.run(r, a);
          return n instanceof Promise ? n.then((s) => _g(s, e)) : _g(n, e);
        });
    });
  function _g(t, e) {
    return t.value === void 0 && (t.value = e.defaultValue), t;
  }
  const kR = B("$ZodPrefault", (t, e) => {
      et.init(t, e),
        (t._zod.optin = "optional"),
        Be(t._zod, "values", () => e.innerType._zod.values),
        (t._zod.parse = (r, a) => (
          r.value === void 0 && (r.value = e.defaultValue),
          e.innerType._zod.run(r, a)
        ));
    }),
    CR = B("$ZodNonOptional", (t, e) => {
      et.init(t, e),
        Be(t._zod, "values", () => {
          const r = e.innerType._zod.values;
          return r ? new Set([...r].filter((a) => a !== void 0)) : void 0;
        }),
        (t._zod.parse = (r, a) => {
          const n = e.innerType._zod.run(r, a);
          return n instanceof Promise ? n.then((s) => wg(s, t)) : wg(n, t);
        });
    });
  function wg(t, e) {
    return (
      !t.issues.length &&
        t.value === void 0 &&
        t.issues.push({
          code: "invalid_type",
          expected: "nonoptional",
          input: t.value,
          inst: e,
        }),
      t
    );
  }
  const RR = B("$ZodCatch", (t, e) => {
      et.init(t, e),
        (t._zod.optin = "optional"),
        Be(t._zod, "optout", () => e.innerType._zod.optout),
        Be(t._zod, "values", () => e.innerType._zod.values),
        (t._zod.parse = (r, a) => {
          const n = e.innerType._zod.run(r, a);
          return n instanceof Promise
            ? n.then(
                (s) => (
                  (r.value = s.value),
                  s.issues.length &&
                    ((r.value = e.catchValue({
                      ...r,
                      error: { issues: s.issues.map((o) => Pn(o, a, $n())) },
                      input: r.value,
                    })),
                    (r.issues = [])),
                  r
                )
              )
            : ((r.value = n.value),
              n.issues.length &&
                ((r.value = e.catchValue({
                  ...r,
                  error: { issues: n.issues.map((s) => Pn(s, a, $n())) },
                  input: r.value,
                })),
                (r.issues = [])),
              r);
        });
    }),
    OR = B("$ZodPipe", (t, e) => {
      et.init(t, e),
        Be(t._zod, "values", () => e.in._zod.values),
        Be(t._zod, "optin", () => e.in._zod.optin),
        Be(t._zod, "optout", () => e.out._zod.optout),
        (t._zod.parse = (r, a) => {
          const n = e.in._zod.run(r, a);
          return n instanceof Promise
            ? n.then((s) => bg(s, e, a))
            : bg(n, e, a);
        });
    });
  function bg(t, e, r) {
    return qs(t) ? t : e.out._zod.run({ value: t.value, issues: t.issues }, r);
  }
  const AR = B("$ZodReadonly", (t, e) => {
    et.init(t, e),
      Be(t._zod, "propValues", () => e.innerType._zod.propValues),
      Be(t._zod, "values", () => e.innerType._zod.values),
      Be(t._zod, "optin", () => e.innerType._zod.optin),
      Be(t._zod, "optout", () => e.innerType._zod.optout),
      (t._zod.parse = (r, a) => {
        const n = e.innerType._zod.run(r, a);
        return n instanceof Promise ? n.then(Eg) : Eg(n);
      });
  });
  function Eg(t) {
    return (t.value = Object.freeze(t.value)), t;
  }
  const NR = B("$ZodLazy", (t, e) => {
      et.init(t, e),
        Be(t._zod, "innerType", () => e.getter()),
        Be(t._zod, "pattern", () => t._zod.innerType._zod.pattern),
        Be(t._zod, "propValues", () => t._zod.innerType._zod.propValues),
        Be(t._zod, "optin", () => t._zod.innerType._zod.optin),
        Be(t._zod, "optout", () => t._zod.innerType._zod.optout),
        (t._zod.parse = (r, a) => t._zod.innerType._zod.run(r, a));
    }),
    MR = B("$ZodCustom", (t, e) => {
      Yt.init(t, e),
        et.init(t, e),
        (t._zod.parse = (r, a) => r),
        (t._zod.check = (r) => {
          const a = r.value,
            n = e.fn(a);
          if (n instanceof Promise) return n.then((s) => Sg(s, r, a, t));
          Sg(n, r, a, t);
        });
    });
  function Sg(t, e, r, a) {
    if (!t) {
      const n = {
        code: "custom",
        input: r,
        inst: a,
        path: [...(a._zod.def.path ?? [])],
        continue: !a._zod.def.abort,
      };
      a._zod.def.params && (n.params = a._zod.def.params), e.issues.push(Us(n));
    }
  }
  class $g {
    constructor() {
      (this._map = new Map()), (this._idmap = new Map());
    }
    add(e, ...r) {
      const a = r[0];
      if ((this._map.set(e, a), a && typeof a == "object" && "id" in a)) {
        if (this._idmap.has(a.id))
          throw new Error(`ID ${a.id} already exists in the registry`);
        this._idmap.set(a.id, e);
      }
      return this;
    }
    clear() {
      return (this._map = new Map()), (this._idmap = new Map()), this;
    }
    remove(e) {
      const r = this._map.get(e);
      return (
        r && typeof r == "object" && "id" in r && this._idmap.delete(r.id),
        this._map.delete(e),
        this
      );
    }
    get(e) {
      const r = e._zod.parent;
      if (r) {
        const a = { ...(this.get(r) ?? {}) };
        return delete a.id, { ...a, ...this._map.get(e) };
      }
      return this._map.get(e);
    }
    has(e) {
      return this._map.has(e);
    }
  }
  function jR() {
    return new $g();
  }
  const Fs = jR();
  function DR(t, e) {
    return new t({ type: "string", ...de(e) });
  }
  function LR(t, e) {
    return new t({
      type: "string",
      format: "email",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function Pg(t, e) {
    return new t({
      type: "string",
      format: "guid",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function zR(t, e) {
    return new t({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function qR(t, e) {
    return new t({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: !1,
      version: "v4",
      ...de(e),
    });
  }
  function UR(t, e) {
    return new t({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: !1,
      version: "v6",
      ...de(e),
    });
  }
  function FR(t, e) {
    return new t({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: !1,
      version: "v7",
      ...de(e),
    });
  }
  function VR(t, e) {
    return new t({
      type: "string",
      format: "url",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function ZR(t, e) {
    return new t({
      type: "string",
      format: "emoji",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function HR(t, e) {
    return new t({
      type: "string",
      format: "nanoid",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function BR(t, e) {
    return new t({
      type: "string",
      format: "cuid",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function JR(t, e) {
    return new t({
      type: "string",
      format: "cuid2",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function KR(t, e) {
    return new t({
      type: "string",
      format: "ulid",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function GR(t, e) {
    return new t({
      type: "string",
      format: "xid",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function WR(t, e) {
    return new t({
      type: "string",
      format: "ksuid",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function QR(t, e) {
    return new t({
      type: "string",
      format: "ipv4",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function YR(t, e) {
    return new t({
      type: "string",
      format: "ipv6",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function XR(t, e) {
    return new t({
      type: "string",
      format: "cidrv4",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function eO(t, e) {
    return new t({
      type: "string",
      format: "cidrv6",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function Tg(t, e) {
    return new t({
      type: "string",
      format: "base64",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function tO(t, e) {
    return new t({
      type: "string",
      format: "base64url",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function rO(t, e) {
    return new t({
      type: "string",
      format: "e164",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function nO(t, e) {
    return new t({
      type: "string",
      format: "jwt",
      check: "string_format",
      abort: !1,
      ...de(e),
    });
  }
  function aO(t, e) {
    return new t({
      type: "string",
      format: "datetime",
      check: "string_format",
      offset: !1,
      local: !1,
      precision: null,
      ...de(e),
    });
  }
  function sO(t, e) {
    return new t({
      type: "string",
      format: "date",
      check: "string_format",
      ...de(e),
    });
  }
  function oO(t, e) {
    return new t({
      type: "string",
      format: "time",
      check: "string_format",
      precision: null,
      ...de(e),
    });
  }
  function iO(t, e) {
    return new t({
      type: "string",
      format: "duration",
      check: "string_format",
      ...de(e),
    });
  }
  function lO(t, e) {
    return new t({ type: "number", checks: [], ...de(e) });
  }
  function cO(t, e) {
    return new t({ type: "number", coerce: !0, checks: [], ...de(e) });
  }
  function uO(t, e) {
    return new t({
      type: "number",
      check: "number_format",
      abort: !1,
      format: "safeint",
      ...de(e),
    });
  }
  function dO(t, e) {
    return new t({ type: "boolean", ...de(e) });
  }
  function fO(t, e) {
    return new t({ type: "null", ...de(e) });
  }
  function pO(t) {
    return new t({ type: "any" });
  }
  function hO(t) {
    return new t({ type: "unknown" });
  }
  function mO(t, e) {
    return new t({ type: "never", ...de(e) });
  }
  function xg(t, e) {
    return new ug({ check: "less_than", ...de(e), value: t, inclusive: !1 });
  }
  function _d(t, e) {
    return new ug({ check: "less_than", ...de(e), value: t, inclusive: !0 });
  }
  function Ig(t, e) {
    return new dg({ check: "greater_than", ...de(e), value: t, inclusive: !1 });
  }
  function wd(t, e) {
    return new dg({ check: "greater_than", ...de(e), value: t, inclusive: !0 });
  }
  function kg(t, e) {
    return new xC({ check: "multiple_of", ...de(e), value: t });
  }
  function Cg(t, e) {
    return new kC({ check: "max_length", ...de(e), maximum: t });
  }
  function Bi(t, e) {
    return new CC({ check: "min_length", ...de(e), minimum: t });
  }
  function Rg(t, e) {
    return new RC({ check: "length_equals", ...de(e), length: t });
  }
  function vO(t, e) {
    return new OC({
      check: "string_format",
      format: "regex",
      ...de(e),
      pattern: t,
    });
  }
  function gO(t) {
    return new AC({ check: "string_format", format: "lowercase", ...de(t) });
  }
  function yO(t) {
    return new NC({ check: "string_format", format: "uppercase", ...de(t) });
  }
  function _O(t, e) {
    return new MC({
      check: "string_format",
      format: "includes",
      ...de(e),
      includes: t,
    });
  }
  function wO(t, e) {
    return new jC({
      check: "string_format",
      format: "starts_with",
      ...de(e),
      prefix: t,
    });
  }
  function bO(t, e) {
    return new DC({
      check: "string_format",
      format: "ends_with",
      ...de(e),
      suffix: t,
    });
  }
  function Vs(t) {
    return new LC({ check: "overwrite", tx: t });
  }
  function EO(t) {
    return Vs((e) => e.normalize(t));
  }
  function SO() {
    return Vs((t) => t.trim());
  }
  function $O() {
    return Vs((t) => t.toLowerCase());
  }
  function PO() {
    return Vs((t) => t.toUpperCase());
  }
  function TO(t, e, r) {
    return new t({ type: "array", element: e, ...de(r) });
  }
  function xO(t, e, r) {
    const a = de(r);
    return (
      a.abort ?? (a.abort = !0),
      new t({ type: "custom", check: "custom", fn: e, ...a })
    );
  }
  function IO(t, e, r) {
    return new t({ type: "custom", check: "custom", fn: e, ...de(r) });
  }
  class Og {
    constructor(e) {
      (this.counter = 0),
        (this.metadataRegistry = (e == null ? void 0 : e.metadata) ?? Fs),
        (this.target = (e == null ? void 0 : e.target) ?? "draft-2020-12"),
        (this.unrepresentable =
          (e == null ? void 0 : e.unrepresentable) ?? "throw"),
        (this.override = (e == null ? void 0 : e.override) ?? (() => {})),
        (this.io = (e == null ? void 0 : e.io) ?? "output"),
        (this.seen = new Map());
    }
    process(e, r = { path: [], schemaPath: [] }) {
      var f, v, d;
      var a;
      const n = e._zod.def,
        s = {
          guid: "uuid",
          url: "uri",
          datetime: "date-time",
          json_string: "json-string",
          regex: "",
        },
        o = this.seen.get(e);
      if (o)
        return (
          o.count++, r.schemaPath.includes(e) && (o.cycle = r.path), o.schema
        );
      const i = { schema: {}, count: 1, cycle: void 0, path: r.path };
      this.seen.set(e, i);
      const l = (v = (f = e._zod).toJSONSchema) == null ? void 0 : v.call(f);
      if (l) i.schema = l;
      else {
        const p = { ...r, schemaPath: [...r.schemaPath, e], path: r.path },
          g = e._zod.parent;
        if (g)
          (i.ref = g), this.process(g, p), (this.seen.get(g).isParent = !0);
        else {
          const m = i.schema;
          switch (n.type) {
            case "string": {
              const h = m;
              h.type = "string";
              const {
                minimum: y,
                maximum: _,
                format: w,
                patterns: E,
                contentEncoding: P,
              } = e._zod.bag;
              if (
                (typeof y == "number" && (h.minLength = y),
                typeof _ == "number" && (h.maxLength = _),
                w &&
                  ((h.format = s[w] ?? w), h.format === "" && delete h.format),
                P && (h.contentEncoding = P),
                E && E.size > 0)
              ) {
                const x = [...E];
                x.length === 1
                  ? (h.pattern = x[0].source)
                  : x.length > 1 &&
                    (i.schema.allOf = [
                      ...x.map((A) => ({
                        ...(this.target === "draft-7"
                          ? { type: "string" }
                          : {}),
                        pattern: A.source,
                      })),
                    ]);
              }
              break;
            }
            case "number": {
              const h = m,
                {
                  minimum: y,
                  maximum: _,
                  format: w,
                  multipleOf: E,
                  exclusiveMaximum: P,
                  exclusiveMinimum: x,
                } = e._zod.bag;
              typeof w == "string" && w.includes("int")
                ? (h.type = "integer")
                : (h.type = "number"),
                typeof x == "number" && (h.exclusiveMinimum = x),
                typeof y == "number" &&
                  ((h.minimum = y),
                  typeof x == "number" &&
                    (x >= y ? delete h.minimum : delete h.exclusiveMinimum)),
                typeof P == "number" && (h.exclusiveMaximum = P),
                typeof _ == "number" &&
                  ((h.maximum = _),
                  typeof P == "number" &&
                    (P <= _ ? delete h.maximum : delete h.exclusiveMaximum)),
                typeof E == "number" && (h.multipleOf = E);
              break;
            }
            case "boolean": {
              const h = m;
              h.type = "boolean";
              break;
            }
            case "bigint": {
              if (this.unrepresentable === "throw")
                throw new Error("BigInt cannot be represented in JSON Schema");
              break;
            }
            case "symbol": {
              if (this.unrepresentable === "throw")
                throw new Error("Symbols cannot be represented in JSON Schema");
              break;
            }
            case "null": {
              m.type = "null";
              break;
            }
            case "any":
              break;
            case "unknown":
              break;
            case "undefined": {
              if (this.unrepresentable === "throw")
                throw new Error(
                  "Undefined cannot be represented in JSON Schema"
                );
              break;
            }
            case "void": {
              if (this.unrepresentable === "throw")
                throw new Error("Void cannot be represented in JSON Schema");
              break;
            }
            case "never": {
              m.not = {};
              break;
            }
            case "date": {
              if (this.unrepresentable === "throw")
                throw new Error("Date cannot be represented in JSON Schema");
              break;
            }
            case "array": {
              const h = m,
                { minimum: y, maximum: _ } = e._zod.bag;
              typeof y == "number" && (h.minItems = y),
                typeof _ == "number" && (h.maxItems = _),
                (h.type = "array"),
                (h.items = this.process(n.element, {
                  ...p,
                  path: [...p.path, "items"],
                }));
              break;
            }
            case "object": {
              const h = m;
              (h.type = "object"), (h.properties = {});
              const y = n.shape;
              for (const E in y)
                h.properties[E] = this.process(y[E], {
                  ...p,
                  path: [...p.path, "properties", E],
                });
              const _ = new Set(Object.keys(y)),
                w = new Set(
                  [..._].filter((E) => {
                    const P = n.shape[E]._zod;
                    return this.io === "input"
                      ? P.optin === void 0
                      : P.optout === void 0;
                  })
                );
              w.size > 0 && (h.required = Array.from(w)),
                ((d = n.catchall) == null ? void 0 : d._zod.def.type) ===
                "never"
                  ? (h.additionalProperties = !1)
                  : n.catchall
                  ? n.catchall &&
                    (h.additionalProperties = this.process(n.catchall, {
                      ...p,
                      path: [...p.path, "additionalProperties"],
                    }))
                  : this.io === "output" && (h.additionalProperties = !1);
              break;
            }
            case "union": {
              const h = m;
              h.anyOf = n.options.map((y, _) =>
                this.process(y, { ...p, path: [...p.path, "anyOf", _] })
              );
              break;
            }
            case "intersection": {
              const h = m,
                y = this.process(n.left, {
                  ...p,
                  path: [...p.path, "allOf", 0],
                }),
                _ = this.process(n.right, {
                  ...p,
                  path: [...p.path, "allOf", 1],
                }),
                w = (P) => "allOf" in P && Object.keys(P).length === 1,
                E = [...(w(y) ? y.allOf : [y]), ...(w(_) ? _.allOf : [_])];
              h.allOf = E;
              break;
            }
            case "tuple": {
              const h = m;
              h.type = "array";
              const y = n.items.map((E, P) =>
                this.process(E, { ...p, path: [...p.path, "prefixItems", P] })
              );
              if (
                (this.target === "draft-2020-12"
                  ? (h.prefixItems = y)
                  : (h.items = y),
                n.rest)
              ) {
                const E = this.process(n.rest, {
                  ...p,
                  path: [...p.path, "items"],
                });
                this.target === "draft-2020-12"
                  ? (h.items = E)
                  : (h.additionalItems = E);
              }
              n.rest &&
                (h.items = this.process(n.rest, {
                  ...p,
                  path: [...p.path, "items"],
                }));
              const { minimum: _, maximum: w } = e._zod.bag;
              typeof _ == "number" && (h.minItems = _),
                typeof w == "number" && (h.maxItems = w);
              break;
            }
            case "record": {
              const h = m;
              (h.type = "object"),
                (h.propertyNames = this.process(n.keyType, {
                  ...p,
                  path: [...p.path, "propertyNames"],
                })),
                (h.additionalProperties = this.process(n.valueType, {
                  ...p,
                  path: [...p.path, "additionalProperties"],
                }));
              break;
            }
            case "map": {
              if (this.unrepresentable === "throw")
                throw new Error("Map cannot be represented in JSON Schema");
              break;
            }
            case "set": {
              if (this.unrepresentable === "throw")
                throw new Error("Set cannot be represented in JSON Schema");
              break;
            }
            case "enum": {
              const h = m,
                y = Yv(n.entries);
              y.every((_) => typeof _ == "number") && (h.type = "number"),
                y.every((_) => typeof _ == "string") && (h.type = "string"),
                (h.enum = y);
              break;
            }
            case "literal": {
              const h = m,
                y = [];
              for (const _ of n.values)
                if (_ === void 0) {
                  if (this.unrepresentable === "throw")
                    throw new Error(
                      "Literal `undefined` cannot be represented in JSON Schema"
                    );
                } else if (typeof _ == "bigint") {
                  if (this.unrepresentable === "throw")
                    throw new Error(
                      "BigInt literals cannot be represented in JSON Schema"
                    );
                  y.push(Number(_));
                } else y.push(_);
              if (y.length !== 0)
                if (y.length === 1) {
                  const _ = y[0];
                  (h.type = _ === null ? "null" : typeof _), (h.const = _);
                } else
                  y.every((_) => typeof _ == "number") && (h.type = "number"),
                    y.every((_) => typeof _ == "string") && (h.type = "string"),
                    y.every((_) => typeof _ == "boolean") &&
                      (h.type = "string"),
                    y.every((_) => _ === null) && (h.type = "null"),
                    (h.enum = y);
              break;
            }
            case "file": {
              const h = m,
                y = {
                  type: "string",
                  format: "binary",
                  contentEncoding: "binary",
                },
                { minimum: _, maximum: w, mime: E } = e._zod.bag;
              _ !== void 0 && (y.minLength = _),
                w !== void 0 && (y.maxLength = w),
                E
                  ? E.length === 1
                    ? ((y.contentMediaType = E[0]), Object.assign(h, y))
                    : (h.anyOf = E.map((P) => ({ ...y, contentMediaType: P })))
                  : Object.assign(h, y);
              break;
            }
            case "transform": {
              if (this.unrepresentable === "throw")
                throw new Error(
                  "Transforms cannot be represented in JSON Schema"
                );
              break;
            }
            case "nullable": {
              const h = this.process(n.innerType, p);
              m.anyOf = [h, { type: "null" }];
              break;
            }
            case "nonoptional": {
              this.process(n.innerType, p), (i.ref = n.innerType);
              break;
            }
            case "success": {
              const h = m;
              h.type = "boolean";
              break;
            }
            case "default": {
              this.process(n.innerType, p),
                (i.ref = n.innerType),
                (m.default = JSON.parse(JSON.stringify(n.defaultValue)));
              break;
            }
            case "prefault": {
              this.process(n.innerType, p),
                (i.ref = n.innerType),
                this.io === "input" &&
                  (m._prefault = JSON.parse(JSON.stringify(n.defaultValue)));
              break;
            }
            case "catch": {
              this.process(n.innerType, p), (i.ref = n.innerType);
              let h;
              try {
                h = n.catchValue(void 0);
              } catch {
                throw new Error(
                  "Dynamic catch values are not supported in JSON Schema"
                );
              }
              m.default = h;
              break;
            }
            case "nan": {
              if (this.unrepresentable === "throw")
                throw new Error("NaN cannot be represented in JSON Schema");
              break;
            }
            case "template_literal": {
              const h = m,
                y = e._zod.pattern;
              if (!y) throw new Error("Pattern not found in template literal");
              (h.type = "string"), (h.pattern = y.source);
              break;
            }
            case "pipe": {
              const h =
                this.io === "input"
                  ? n.in._zod.def.type === "transform"
                    ? n.out
                    : n.in
                  : n.out;
              this.process(h, p), (i.ref = h);
              break;
            }
            case "readonly": {
              this.process(n.innerType, p),
                (i.ref = n.innerType),
                (m.readOnly = !0);
              break;
            }
            case "promise": {
              this.process(n.innerType, p), (i.ref = n.innerType);
              break;
            }
            case "optional": {
              this.process(n.innerType, p), (i.ref = n.innerType);
              break;
            }
            case "lazy": {
              const h = e._zod.innerType;
              this.process(h, p), (i.ref = h);
              break;
            }
            case "custom": {
              if (this.unrepresentable === "throw")
                throw new Error(
                  "Custom types cannot be represented in JSON Schema"
                );
              break;
            }
          }
        }
      }
      const c = this.metadataRegistry.get(e);
      return (
        c && Object.assign(i.schema, c),
        this.io === "input" &&
          It(e) &&
          (delete i.schema.examples, delete i.schema.default),
        this.io === "input" &&
          i.schema._prefault &&
          ((a = i.schema).default ?? (a.default = i.schema._prefault)),
        delete i.schema._prefault,
        this.seen.get(e).schema
      );
    }
    emit(e, r) {
      var u, f, v, d, p, g;
      const a = {
          cycles: (r == null ? void 0 : r.cycles) ?? "ref",
          reused: (r == null ? void 0 : r.reused) ?? "inline",
          external: (r == null ? void 0 : r.external) ?? void 0,
        },
        n = this.seen.get(e);
      if (!n) throw new Error("Unprocessed schema. This is a bug in Zod.");
      const s = (m) => {
          var E;
          const h = this.target === "draft-2020-12" ? "$defs" : "definitions";
          if (a.external) {
            const P =
                (E = a.external.registry.get(m[0])) == null ? void 0 : E.id,
              x = a.external.uri ?? ((M) => M);
            if (P) return { ref: x(P) };
            const A = m[1].defId ?? m[1].schema.id ?? `schema${this.counter++}`;
            return (
              (m[1].defId = A), { defId: A, ref: `${x("__shared")}#/${h}/${A}` }
            );
          }
          if (m[1] === n) return { ref: "#" };
          const _ = `#/${h}/`,
            w = m[1].schema.id ?? `__schema${this.counter++}`;
          return { defId: w, ref: _ + w };
        },
        o = (m) => {
          if (m[1].schema.$ref) return;
          const h = m[1],
            { ref: y, defId: _ } = s(m);
          (h.def = { ...h.schema }), _ && (h.defId = _);
          const w = h.schema;
          for (const E in w) delete w[E];
          w.$ref = y;
        };
      if (a.cycles === "throw")
        for (const m of this.seen.entries()) {
          const h = m[1];
          if (h.cycle)
            throw new Error(`Cycle detected: #/${
              (u = h.cycle) == null ? void 0 : u.join("/")
            }/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      for (const m of this.seen.entries()) {
        const h = m[1];
        if (e === m[0]) {
          o(m);
          continue;
        }
        if (a.external) {
          const _ = (f = a.external.registry.get(m[0])) == null ? void 0 : f.id;
          if (e !== m[0] && _) {
            o(m);
            continue;
          }
        }
        if ((v = this.metadataRegistry.get(m[0])) == null ? void 0 : v.id) {
          o(m);
          continue;
        }
        if (h.cycle) {
          o(m);
          continue;
        }
        if (h.count > 1 && a.reused === "ref") {
          o(m);
          continue;
        }
      }
      const i = (m, h) => {
        const y = this.seen.get(m),
          _ = y.def ?? y.schema,
          w = { ..._ };
        if (y.ref === null) return;
        const E = y.ref;
        if (((y.ref = null), E)) {
          i(E, h);
          const P = this.seen.get(E).schema;
          P.$ref && h.target === "draft-7"
            ? ((_.allOf = _.allOf ?? []), _.allOf.push(P))
            : (Object.assign(_, P), Object.assign(_, w));
        }
        y.isParent ||
          this.override({ zodSchema: m, jsonSchema: _, path: y.path ?? [] });
      };
      for (const m of [...this.seen.entries()].reverse())
        i(m[0], { target: this.target });
      const l = {};
      if (
        (this.target === "draft-2020-12"
          ? (l.$schema = "https://json-schema.org/draft/2020-12/schema")
          : this.target === "draft-7"
          ? (l.$schema = "http://json-schema.org/draft-07/schema#")
          : console.warn(`Invalid target: ${this.target}`),
        (d = a.external) != null && d.uri)
      ) {
        const m = (p = a.external.registry.get(e)) == null ? void 0 : p.id;
        if (!m) throw new Error("Schema is missing an `id` property");
        l.$id = a.external.uri(m);
      }
      Object.assign(l, n.def);
      const c = ((g = a.external) == null ? void 0 : g.defs) ?? {};
      for (const m of this.seen.entries()) {
        const h = m[1];
        h.def && h.defId && (c[h.defId] = h.def);
      }
      a.external ||
        (Object.keys(c).length > 0 &&
          (this.target === "draft-2020-12"
            ? (l.$defs = c)
            : (l.definitions = c)));
      try {
        return JSON.parse(JSON.stringify(l));
      } catch {
        throw new Error("Error converting schema to JSON.");
      }
    }
  }
  function kO(t, e) {
    if (t instanceof $g) {
      const a = new Og(e),
        n = {};
      for (const i of t._idmap.entries()) {
        const [l, c] = i;
        a.process(c);
      }
      const s = {},
        o = { registry: t, uri: e == null ? void 0 : e.uri, defs: n };
      for (const i of t._idmap.entries()) {
        const [l, c] = i;
        s[l] = a.emit(c, { ...e, external: o });
      }
      if (Object.keys(n).length > 0) {
        const i = a.target === "draft-2020-12" ? "$defs" : "definitions";
        s.__shared = { [i]: n };
      }
      return { schemas: s };
    }
    const r = new Og(e);
    return r.process(t), r.emit(t, e);
  }
  function It(t, e) {
    const r = e ?? { seen: new Set() };
    if (r.seen.has(t)) return !1;
    r.seen.add(t);
    const n = t._zod.def;
    switch (n.type) {
      case "string":
      case "number":
      case "bigint":
      case "boolean":
      case "date":
      case "symbol":
      case "undefined":
      case "null":
      case "any":
      case "unknown":
      case "never":
      case "void":
      case "literal":
      case "enum":
      case "nan":
      case "file":
      case "template_literal":
        return !1;
      case "array":
        return It(n.element, r);
      case "object": {
        for (const s in n.shape) if (It(n.shape[s], r)) return !0;
        return !1;
      }
      case "union": {
        for (const s of n.options) if (It(s, r)) return !0;
        return !1;
      }
      case "intersection":
        return It(n.left, r) || It(n.right, r);
      case "tuple": {
        for (const s of n.items) if (It(s, r)) return !0;
        return !!(n.rest && It(n.rest, r));
      }
      case "record":
        return It(n.keyType, r) || It(n.valueType, r);
      case "map":
        return It(n.keyType, r) || It(n.valueType, r);
      case "set":
        return It(n.valueType, r);
      case "promise":
      case "optional":
      case "nonoptional":
      case "nullable":
      case "readonly":
        return It(n.innerType, r);
      case "lazy":
        return It(n.getter(), r);
      case "default":
        return It(n.innerType, r);
      case "prefault":
        return It(n.innerType, r);
      case "custom":
        return !1;
      case "transform":
        return !0;
      case "pipe":
        return It(n.in, r) || It(n.out, r);
      case "success":
        return !1;
      case "catch":
        return !1;
    }
    throw new Error(`Unknown schema type: ${n.type}`);
  }
  const CO = B("ZodISODateTime", (t, e) => {
    YC.init(t, e), pt.init(t, e);
  });
  function RO(t) {
    return aO(CO, t);
  }
  const OO = B("ZodISODate", (t, e) => {
    XC.init(t, e), pt.init(t, e);
  });
  function AO(t) {
    return sO(OO, t);
  }
  const NO = B("ZodISOTime", (t, e) => {
    eR.init(t, e), pt.init(t, e);
  });
  function MO(t) {
    return oO(NO, t);
  }
  const jO = B("ZodISODuration", (t, e) => {
    tR.init(t, e), pt.init(t, e);
  });
  function DO(t) {
    return iO(jO, t);
  }
  const Ji = B(
      "ZodError",
      (t, e) => {
        tg.init(t, e),
          (t.name = "ZodError"),
          Object.defineProperties(t, {
            format: { value: (r) => Kk(t, r) },
            flatten: { value: (r) => Jk(t, r) },
            addIssue: { value: (r) => t.issues.push(r) },
            addIssues: { value: (r) => t.issues.push(...r) },
            isEmpty: {
              get() {
                return t.issues.length === 0;
              },
            },
          });
      },
      { Parent: Error }
    ),
    LO = Gk(Ji),
    zO = Wk(Ji),
    qO = ng(Ji),
    Ag = ag(Ji),
    ot = B(
      "ZodType",
      (t, e) => (
        et.init(t, e),
        (t.def = e),
        Object.defineProperty(t, "_def", { value: e }),
        (t.check = (...r) =>
          t.clone({
            ...e,
            checks: [
              ...(e.checks ?? []),
              ...r.map((a) =>
                typeof a == "function"
                  ? {
                      _zod: {
                        check: a,
                        def: { check: "custom" },
                        onattach: [],
                      },
                    }
                  : a
              ),
            ],
          })),
        (t.clone = (r, a) => Hn(t, r, a)),
        (t.brand = () => t),
        (t.register = (r, a) => (r.add(t, a), t)),
        (t.parse = (r, a) => LO(t, r, a, { callee: t.parse })),
        (t.safeParse = (r, a) => qO(t, r, a)),
        (t.parseAsync = async (r, a) => zO(t, r, a, { callee: t.parseAsync })),
        (t.safeParseAsync = async (r, a) => Ag(t, r, a)),
        (t.spa = t.safeParseAsync),
        (t.refine = (r, a) => t.check(A2(r, a))),
        (t.superRefine = (r) => t.check(N2(r))),
        (t.overwrite = (r) => t.check(Vs(r))),
        (t.optional = () => $t(t)),
        (t.nullable = () => Fg(t)),
        (t.nullish = () => $t(Fg(t))),
        (t.nonoptional = (r) => $2(t, r)),
        (t.array = () => ce(t)),
        (t.or = (r) => Fe([t, r])),
        (t.and = (r) => h2(t, r)),
        (t.transform = (r) => Zg(t, y2(r))),
        (t.default = (r) => b2(t, r)),
        (t.prefault = (r) => S2(t, r)),
        (t.catch = (r) => T2(t, r)),
        (t.pipe = (r) => Zg(t, r)),
        (t.readonly = () => k2(t)),
        (t.describe = (r) => {
          const a = t.clone();
          return Fs.add(a, { description: r }), a;
        }),
        Object.defineProperty(t, "description", {
          get() {
            var r;
            return (r = Fs.get(t)) == null ? void 0 : r.description;
          },
          configurable: !0,
        }),
        (t.meta = (...r) => {
          if (r.length === 0) return Fs.get(t);
          const a = t.clone();
          return Fs.add(a, r[0]), a;
        }),
        (t.isOptional = () => t.safeParse(void 0).success),
        (t.isNullable = () => t.safeParse(null).success),
        t
      )
    ),
    Ng = B("_ZodString", (t, e) => {
      gd.init(t, e), ot.init(t, e);
      const r = t._zod.bag;
      (t.format = r.format ?? null),
        (t.minLength = r.minimum ?? null),
        (t.maxLength = r.maximum ?? null),
        (t.regex = (...a) => t.check(vO(...a))),
        (t.includes = (...a) => t.check(_O(...a))),
        (t.startsWith = (...a) => t.check(wO(...a))),
        (t.endsWith = (...a) => t.check(bO(...a))),
        (t.min = (...a) => t.check(Bi(...a))),
        (t.max = (...a) => t.check(Cg(...a))),
        (t.length = (...a) => t.check(Rg(...a))),
        (t.nonempty = (...a) => t.check(Bi(1, ...a))),
        (t.lowercase = (a) => t.check(gO(a))),
        (t.uppercase = (a) => t.check(yO(a))),
        (t.trim = () => t.check(SO())),
        (t.normalize = (...a) => t.check(EO(...a))),
        (t.toLowerCase = () => t.check($O())),
        (t.toUpperCase = () => t.check(PO()));
    }),
    UO = B("ZodString", (t, e) => {
      gd.init(t, e),
        Ng.init(t, e),
        (t.email = (r) => t.check(LR(FO, r))),
        (t.url = (r) => t.check(VR(VO, r))),
        (t.jwt = (r) => t.check(nO(n2, r))),
        (t.emoji = (r) => t.check(ZR(ZO, r))),
        (t.guid = (r) => t.check(Pg(Mg, r))),
        (t.uuid = (r) => t.check(zR(Ki, r))),
        (t.uuidv4 = (r) => t.check(qR(Ki, r))),
        (t.uuidv6 = (r) => t.check(UR(Ki, r))),
        (t.uuidv7 = (r) => t.check(FR(Ki, r))),
        (t.nanoid = (r) => t.check(HR(HO, r))),
        (t.guid = (r) => t.check(Pg(Mg, r))),
        (t.cuid = (r) => t.check(BR(BO, r))),
        (t.cuid2 = (r) => t.check(JR(JO, r))),
        (t.ulid = (r) => t.check(KR(KO, r))),
        (t.base64 = (r) => t.check(Tg(jg, r))),
        (t.base64url = (r) => t.check(tO(t2, r))),
        (t.xid = (r) => t.check(GR(GO, r))),
        (t.ksuid = (r) => t.check(WR(WO, r))),
        (t.ipv4 = (r) => t.check(QR(QO, r))),
        (t.ipv6 = (r) => t.check(YR(YO, r))),
        (t.cidrv4 = (r) => t.check(XR(XO, r))),
        (t.cidrv6 = (r) => t.check(eO(e2, r))),
        (t.e164 = (r) => t.check(rO(r2, r))),
        (t.datetime = (r) => t.check(RO(r))),
        (t.date = (r) => t.check(AO(r))),
        (t.time = (r) => t.check(MO(r))),
        (t.duration = (r) => t.check(DO(r)));
    });
  function S(t) {
    return DR(UO, t);
  }
  const pt = B("ZodStringFormat", (t, e) => {
      ut.init(t, e), Ng.init(t, e);
    }),
    FO = B("ZodEmail", (t, e) => {
      VC.init(t, e), pt.init(t, e);
    }),
    Mg = B("ZodGUID", (t, e) => {
      UC.init(t, e), pt.init(t, e);
    }),
    Ki = B("ZodUUID", (t, e) => {
      FC.init(t, e), pt.init(t, e);
    }),
    VO = B("ZodURL", (t, e) => {
      ZC.init(t, e), pt.init(t, e);
    }),
    ZO = B("ZodEmoji", (t, e) => {
      HC.init(t, e), pt.init(t, e);
    }),
    HO = B("ZodNanoID", (t, e) => {
      BC.init(t, e), pt.init(t, e);
    }),
    BO = B("ZodCUID", (t, e) => {
      JC.init(t, e), pt.init(t, e);
    }),
    JO = B("ZodCUID2", (t, e) => {
      KC.init(t, e), pt.init(t, e);
    }),
    KO = B("ZodULID", (t, e) => {
      GC.init(t, e), pt.init(t, e);
    }),
    GO = B("ZodXID", (t, e) => {
      WC.init(t, e), pt.init(t, e);
    }),
    WO = B("ZodKSUID", (t, e) => {
      QC.init(t, e), pt.init(t, e);
    }),
    QO = B("ZodIPv4", (t, e) => {
      rR.init(t, e), pt.init(t, e);
    }),
    YO = B("ZodIPv6", (t, e) => {
      nR.init(t, e), pt.init(t, e);
    }),
    XO = B("ZodCIDRv4", (t, e) => {
      aR.init(t, e), pt.init(t, e);
    }),
    e2 = B("ZodCIDRv6", (t, e) => {
      sR.init(t, e), pt.init(t, e);
    }),
    jg = B("ZodBase64", (t, e) => {
      oR.init(t, e), pt.init(t, e);
    });
  function Dg(t) {
    return Tg(jg, t);
  }
  const t2 = B("ZodBase64URL", (t, e) => {
      lR.init(t, e), pt.init(t, e);
    }),
    r2 = B("ZodE164", (t, e) => {
      cR.init(t, e), pt.init(t, e);
    }),
    n2 = B("ZodJWT", (t, e) => {
      dR.init(t, e), pt.init(t, e);
    }),
    bd = B("ZodNumber", (t, e) => {
      pg.init(t, e),
        ot.init(t, e),
        (t.gt = (a, n) => t.check(Ig(a, n))),
        (t.gte = (a, n) => t.check(wd(a, n))),
        (t.min = (a, n) => t.check(wd(a, n))),
        (t.lt = (a, n) => t.check(xg(a, n))),
        (t.lte = (a, n) => t.check(_d(a, n))),
        (t.max = (a, n) => t.check(_d(a, n))),
        (t.int = (a) => t.check(Lg(a))),
        (t.safe = (a) => t.check(Lg(a))),
        (t.positive = (a) => t.check(Ig(0, a))),
        (t.nonnegative = (a) => t.check(wd(0, a))),
        (t.negative = (a) => t.check(xg(0, a))),
        (t.nonpositive = (a) => t.check(_d(0, a))),
        (t.multipleOf = (a, n) => t.check(kg(a, n))),
        (t.step = (a, n) => t.check(kg(a, n))),
        (t.finite = () => t);
      const r = t._zod.bag;
      (t.minValue =
        Math.max(
          r.minimum ?? Number.NEGATIVE_INFINITY,
          r.exclusiveMinimum ?? Number.NEGATIVE_INFINITY
        ) ?? null),
        (t.maxValue =
          Math.min(
            r.maximum ?? Number.POSITIVE_INFINITY,
            r.exclusiveMaximum ?? Number.POSITIVE_INFINITY
          ) ?? null),
        (t.isInt =
          (r.format ?? "").includes("int") ||
          Number.isSafeInteger(r.multipleOf ?? 0.5)),
        (t.isFinite = !0),
        (t.format = r.format ?? null);
    });
  function K(t) {
    return lO(bd, t);
  }
  const a2 = B("ZodNumberFormat", (t, e) => {
    fR.init(t, e), bd.init(t, e);
  });
  function Lg(t) {
    return uO(a2, t);
  }
  const s2 = B("ZodBoolean", (t, e) => {
    pR.init(t, e), ot.init(t, e);
  });
  function Ve(t) {
    return dO(s2, t);
  }
  const o2 = B("ZodNull", (t, e) => {
    hR.init(t, e), ot.init(t, e);
  });
  function i2(t) {
    return fO(o2, t);
  }
  const l2 = B("ZodAny", (t, e) => {
    mR.init(t, e), ot.init(t, e);
  });
  function Tr() {
    return pO(l2);
  }
  const c2 = B("ZodUnknown", (t, e) => {
    vR.init(t, e), ot.init(t, e);
  });
  function Ft() {
    return hO(c2);
  }
  const u2 = B("ZodNever", (t, e) => {
    gR.init(t, e), ot.init(t, e);
  });
  function zg(t) {
    return mO(u2, t);
  }
  const d2 = B("ZodArray", (t, e) => {
    yR.init(t, e),
      ot.init(t, e),
      (t.element = e.element),
      (t.min = (r, a) => t.check(Bi(r, a))),
      (t.nonempty = (r) => t.check(Bi(1, r))),
      (t.max = (r, a) => t.check(Cg(r, a))),
      (t.length = (r, a) => t.check(Rg(r, a))),
      (t.unwrap = () => t.element);
  });
  function ce(t, e) {
    return TO(d2, t, e);
  }
  const Ed = B("ZodObject", (t, e) => {
    _R.init(t, e),
      ot.init(t, e),
      Be(t, "shape", () => e.shape),
      (t.keyof = () => Vt(Object.keys(t._zod.def.shape))),
      (t.catchall = (r) => t.clone({ ...t._zod.def, catchall: r })),
      (t.passthrough = () => t.clone({ ...t._zod.def, catchall: Ft() })),
      (t.loose = () => t.clone({ ...t._zod.def, catchall: Ft() })),
      (t.strict = () => t.clone({ ...t._zod.def, catchall: zg() })),
      (t.strip = () => t.clone({ ...t._zod.def, catchall: void 0 })),
      (t.extend = (r) => Vk(t, r)),
      (t.merge = (r) => Zk(t, r)),
      (t.pick = (r) => Uk(t, r)),
      (t.omit = (r) => Fk(t, r)),
      (t.partial = (...r) => Hk(Ug, t, r[0])),
      (t.required = (...r) => Bk(Vg, t, r[0]));
  });
  function O(t, e) {
    const r = {
      type: "object",
      get shape() {
        return Ds(this, "shape", { ...t }), this.shape;
      },
      ...de(e),
    };
    return new Ed(r);
  }
  function it(t, e) {
    return new Ed({
      type: "object",
      get shape() {
        return Ds(this, "shape", { ...t }), this.shape;
      },
      catchall: zg(),
      ...de(e),
    });
  }
  function za(t, e) {
    return new Ed({
      type: "object",
      get shape() {
        return Ds(this, "shape", { ...t }), this.shape;
      },
      catchall: Ft(),
      ...de(e),
    });
  }
  const qg = B("ZodUnion", (t, e) => {
    gg.init(t, e), ot.init(t, e), (t.options = e.options);
  });
  function Fe(t, e) {
    return new qg({ type: "union", options: t, ...de(e) });
  }
  const f2 = B("ZodDiscriminatedUnion", (t, e) => {
    qg.init(t, e), wR.init(t, e);
  });
  function qa(t, e, r) {
    return new f2({ type: "union", options: e, discriminator: t, ...de(r) });
  }
  const p2 = B("ZodIntersection", (t, e) => {
    bR.init(t, e), ot.init(t, e);
  });
  function h2(t, e) {
    return new p2({ type: "intersection", left: t, right: e });
  }
  const m2 = B("ZodRecord", (t, e) => {
    ER.init(t, e),
      ot.init(t, e),
      (t.keyType = e.keyType),
      (t.valueType = e.valueType);
  });
  function Xt(t, e, r) {
    return new m2({ type: "record", keyType: t, valueType: e, ...de(r) });
  }
  const Sd = B("ZodEnum", (t, e) => {
    SR.init(t, e),
      ot.init(t, e),
      (t.enum = e.entries),
      (t.options = Object.values(e.entries));
    const r = new Set(Object.keys(e.entries));
    (t.extract = (a, n) => {
      const s = {};
      for (const o of a)
        if (r.has(o)) s[o] = e.entries[o];
        else throw new Error(`Key ${o} not found in enum`);
      return new Sd({ ...e, checks: [], ...de(n), entries: s });
    }),
      (t.exclude = (a, n) => {
        const s = { ...e.entries };
        for (const o of a)
          if (r.has(o)) delete s[o];
          else throw new Error(`Key ${o} not found in enum`);
        return new Sd({ ...e, checks: [], ...de(n), entries: s });
      });
  });
  function Vt(t, e) {
    const r = Array.isArray(t) ? Object.fromEntries(t.map((a) => [a, a])) : t;
    return new Sd({ type: "enum", entries: r, ...de(e) });
  }
  const v2 = B("ZodLiteral", (t, e) => {
    $R.init(t, e),
      ot.init(t, e),
      (t.values = new Set(e.values)),
      Object.defineProperty(t, "value", {
        get() {
          if (e.values.length > 1)
            throw new Error(
              "This schema contains multiple valid literal values. Use `.values` instead."
            );
          return e.values[0];
        },
      });
  });
  function W(t, e) {
    return new v2({
      type: "literal",
      values: Array.isArray(t) ? t : [t],
      ...de(e),
    });
  }
  const g2 = B("ZodTransform", (t, e) => {
    PR.init(t, e),
      ot.init(t, e),
      (t._zod.parse = (r, a) => {
        r.addIssue = (s) => {
          if (typeof s == "string") r.issues.push(Us(s, r.value, e));
          else {
            const o = s;
            o.fatal && (o.continue = !1),
              o.code ?? (o.code = "custom"),
              o.input ?? (o.input = r.value),
              o.inst ?? (o.inst = t),
              o.continue ?? (o.continue = !0),
              r.issues.push(Us(o));
          }
        };
        const n = e.transform(r.value, r);
        return n instanceof Promise
          ? n.then((s) => ((r.value = s), r))
          : ((r.value = n), r);
      });
  });
  function y2(t) {
    return new g2({ type: "transform", transform: t });
  }
  const Ug = B("ZodOptional", (t, e) => {
    TR.init(t, e), ot.init(t, e), (t.unwrap = () => t._zod.def.innerType);
  });
  function $t(t) {
    return new Ug({ type: "optional", innerType: t });
  }
  const _2 = B("ZodNullable", (t, e) => {
    xR.init(t, e), ot.init(t, e), (t.unwrap = () => t._zod.def.innerType);
  });
  function Fg(t) {
    return new _2({ type: "nullable", innerType: t });
  }
  const w2 = B("ZodDefault", (t, e) => {
    IR.init(t, e),
      ot.init(t, e),
      (t.unwrap = () => t._zod.def.innerType),
      (t.removeDefault = t.unwrap);
  });
  function b2(t, e) {
    return new w2({
      type: "default",
      innerType: t,
      get defaultValue() {
        return typeof e == "function" ? e() : e;
      },
    });
  }
  const E2 = B("ZodPrefault", (t, e) => {
    kR.init(t, e), ot.init(t, e), (t.unwrap = () => t._zod.def.innerType);
  });
  function S2(t, e) {
    return new E2({
      type: "prefault",
      innerType: t,
      get defaultValue() {
        return typeof e == "function" ? e() : e;
      },
    });
  }
  const Vg = B("ZodNonOptional", (t, e) => {
    CR.init(t, e), ot.init(t, e), (t.unwrap = () => t._zod.def.innerType);
  });
  function $2(t, e) {
    return new Vg({ type: "nonoptional", innerType: t, ...de(e) });
  }
  const P2 = B("ZodCatch", (t, e) => {
    RR.init(t, e),
      ot.init(t, e),
      (t.unwrap = () => t._zod.def.innerType),
      (t.removeCatch = t.unwrap);
  });
  function T2(t, e) {
    return new P2({
      type: "catch",
      innerType: t,
      catchValue: typeof e == "function" ? e : () => e,
    });
  }
  const x2 = B("ZodPipe", (t, e) => {
    OR.init(t, e), ot.init(t, e), (t.in = e.in), (t.out = e.out);
  });
  function Zg(t, e) {
    return new x2({ type: "pipe", in: t, out: e });
  }
  const I2 = B("ZodReadonly", (t, e) => {
    AR.init(t, e), ot.init(t, e);
  });
  function k2(t) {
    return new I2({ type: "readonly", innerType: t });
  }
  const C2 = B("ZodLazy", (t, e) => {
    NR.init(t, e), ot.init(t, e), (t.unwrap = () => t._zod.def.getter());
  });
  function Hg(t) {
    return new C2({ type: "lazy", getter: t });
  }
  const $d = B("ZodCustom", (t, e) => {
    MR.init(t, e), ot.init(t, e);
  });
  function R2(t) {
    const e = new Yt({ check: "custom" });
    return (e._zod.check = t), e;
  }
  function O2(t, e) {
    return xO($d, t ?? (() => !0), e);
  }
  function A2(t, e = {}) {
    return IO($d, t, e);
  }
  function N2(t) {
    const e = R2(
      (r) => (
        (r.addIssue = (a) => {
          if (typeof a == "string") r.issues.push(Us(a, r.value, e._zod.def));
          else {
            const n = a;
            n.fatal && (n.continue = !1),
              n.code ?? (n.code = "custom"),
              n.input ?? (n.input = r.value),
              n.inst ?? (n.inst = e),
              n.continue ?? (n.continue = !e._zod.def.abort),
              r.issues.push(Us(n));
          }
        }),
        t(r.value, r)
      )
    );
    return e;
  }
  function Gi(t, e = { error: `Input not instance of ${t.name}` }) {
    const r = new $d({
      type: "custom",
      check: "custom",
      fn: (a) => a instanceof t,
      abort: !0,
      ...de(e),
    });
    return (r._zod.bag.Class = t), r;
  }
  function M2(t) {
    return cO(bd, t);
  }
  function Pd(...t) {
    return t.reduce((e, r) => ({ ...e, ...(r ?? {}) }), {});
  }
  async function j2(t, e) {
    if (t == null) return Promise.resolve();
    const r = e == null ? void 0 : e.abortSignal;
    return new Promise((a, n) => {
      if (r != null && r.aborted) {
        n(Bg());
        return;
      }
      const s = setTimeout(() => {
          o(), a();
        }, t),
        o = () => {
          clearTimeout(s), r == null || r.removeEventListener("abort", i);
        },
        i = () => {
          o(), n(Bg());
        };
      r == null || r.addEventListener("abort", i);
    });
  }
  function Bg() {
    return new DOMException("Delay was aborted", "AbortError");
  }
  function Zs(t) {
    return Object.fromEntries([...t.headers]);
  }
  var Hs = ({
      prefix: t,
      size: e = 16,
      alphabet:
        r = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      separator: a = "-",
    } = {}) => {
      const n = () => {
        const s = r.length,
          o = new Array(e);
        for (let i = 0; i < e; i++) o[i] = r[(Math.random() * s) | 0];
        return o.join("");
      };
      if (t == null) return n;
      if (r.includes(a))
        throw new dd({
          argument: "separator",
          message: `The separator "${a}" must not be part of the alphabet "${r}".`,
        });
      return () => `${t}${a}${n()}`;
    },
    D2 = Hs();
  function Td(t) {
    return t == null
      ? "unknown error"
      : typeof t == "string"
      ? t
      : t instanceof Error
      ? t.message
      : JSON.stringify(t);
  }
  function Jn(t) {
    return (
      (t instanceof Error || t instanceof DOMException) &&
      (t.name === "AbortError" ||
        t.name === "ResponseAborted" ||
        t.name === "TimeoutError")
    );
  }
  var L2 = ["fetch failed", "failed to fetch"];
  function Jg({ error: t, url: e, requestBodyValues: r }) {
    if (Jn(t)) return t;
    if (t instanceof TypeError && L2.includes(t.message.toLowerCase())) {
      const a = t.cause;
      if (a != null)
        return new Xe({
          message: `Cannot connect to API: ${a.message}`,
          cause: a,
          url: e,
          requestBodyValues: r,
          isRetryable: !0,
        });
    }
    return t;
  }
  function Kg(t) {
    return Object.fromEntries(Object.entries(t).filter(([e, r]) => r != null));
  }
  var z2 = () => globalThis.fetch,
    q2 = async ({
      url: t,
      headers: e = {},
      successfulResponseHandler: r,
      failedResponseHandler: a,
      abortSignal: n,
      fetch: s = z2(),
    }) => {
      try {
        const o = await s(t, { method: "GET", headers: Kg(e), signal: n }),
          i = Zs(o);
        if (!o.ok) {
          let l;
          try {
            l = await a({ response: o, url: t, requestBodyValues: {} });
          } catch (c) {
            throw Jn(c) || Xe.isInstance(c)
              ? c
              : new Xe({
                  message: "Failed to process error response",
                  cause: c,
                  statusCode: o.status,
                  url: t,
                  responseHeaders: i,
                  requestBodyValues: {},
                });
          }
          throw l.value;
        }
        try {
          return await r({ response: o, url: t, requestBodyValues: {} });
        } catch (l) {
          throw l instanceof Error && (Jn(l) || Xe.isInstance(l))
            ? l
            : new Xe({
                message: "Failed to process successful response",
                cause: l,
                statusCode: o.status,
                url: t,
                responseHeaders: i,
                requestBodyValues: {},
              });
        }
      } catch (o) {
        throw Jg({ error: o, url: t, requestBodyValues: {} });
      }
    };
  function U2({ mediaType: t, url: e, supportedUrls: r }) {
    return (
      (e = e.toLowerCase()),
      (t = t.toLowerCase()),
      Object.entries(r)
        .map(([a, n]) => {
          const s = a.toLowerCase();
          return s === "*" || s === "*/*"
            ? { mediaTypePrefix: "", regexes: n }
            : { mediaTypePrefix: s.replace(/\*/, ""), regexes: n };
        })
        .filter(({ mediaTypePrefix: a }) => t.startsWith(a))
        .flatMap(({ regexes: a }) => a)
        .some((a) => a.test(e))
    );
  }
  function Wi({ settingValue: t, environmentVariableName: e }) {
    if (typeof t == "string") return t;
    if (
      !(t != null || typeof process > "u") &&
      ((t = process.env[e]), !(t == null || typeof t != "string"))
    )
      return t;
  }
  var F2 = /"__proto__"\s*:/,
    V2 = /"constructor"\s*:/;
  function Z2(t) {
    const e = JSON.parse(t);
    return e === null ||
      typeof e != "object" ||
      (F2.test(t) === !1 && V2.test(t) === !1)
      ? e
      : H2(e);
  }
  function H2(t) {
    let e = [t];
    for (; e.length; ) {
      const r = e;
      e = [];
      for (const a of r) {
        if (Object.prototype.hasOwnProperty.call(a, "__proto__"))
          throw new SyntaxError("Object contains forbidden prototype property");
        if (
          Object.prototype.hasOwnProperty.call(a, "constructor") &&
          Object.prototype.hasOwnProperty.call(a.constructor, "prototype")
        )
          throw new SyntaxError("Object contains forbidden prototype property");
        for (const n in a) {
          const s = a[n];
          s && typeof s == "object" && e.push(s);
        }
      }
    }
    return t;
  }
  function Gg(t) {
    const { stackTraceLimit: e } = Error;
    Error.stackTraceLimit = 0;
    try {
      return Z2(t);
    } finally {
      Error.stackTraceLimit = e;
    }
  }
  var Qi = Symbol.for("vercel.ai.validator");
  function B2(t) {
    return { [Qi]: !0, validate: t };
  }
  function J2(t) {
    return (
      typeof t == "object" &&
      t !== null &&
      Qi in t &&
      t[Qi] === !0 &&
      "validate" in t
    );
  }
  function K2(t) {
    return J2(t) ? t : G2(t);
  }
  function G2(t) {
    return B2(async (e) => {
      const r = await t["~standard"].validate(e);
      return r.issues == null
        ? { success: !0, value: r.value }
        : { success: !1, error: new Vr({ value: e, cause: r.issues }) };
    });
  }
  async function xd({ value: t, schema: e }) {
    const r = await Bs({ value: t, schema: e });
    if (!r.success) throw Vr.wrap({ value: t, cause: r.error });
    return r.value;
  }
  async function Bs({ value: t, schema: e }) {
    const r = K2(e);
    try {
      if (r.validate == null) return { success: !0, value: t, rawValue: t };
      const a = await r.validate(t);
      return a.success
        ? { success: !0, value: a.value, rawValue: t }
        : {
            success: !1,
            error: Vr.wrap({ value: t, cause: a.error }),
            rawValue: t,
          };
    } catch (a) {
      return {
        success: !1,
        error: Vr.wrap({ value: t, cause: a }),
        rawValue: t,
      };
    }
  }
  async function W2({ text: t, schema: e }) {
    try {
      const r = Gg(t);
      return e == null ? r : xd({ value: r, schema: e });
    } catch (r) {
      throw Sn.isInstance(r) || Vr.isInstance(r)
        ? r
        : new Sn({ text: t, cause: r });
    }
  }
  async function Ua({ text: t, schema: e }) {
    try {
      const r = Gg(t);
      return e == null
        ? { success: !0, value: r, rawValue: r }
        : await Bs({ value: r, schema: e });
    } catch (r) {
      return {
        success: !1,
        error: Sn.isInstance(r) ? r : new Sn({ text: t, cause: r }),
        rawValue: void 0,
      };
    }
  }
  function Q2({ stream: t, schema: e }) {
    return t
      .pipeThrough(new TextDecoderStream())
      .pipeThrough(new wi())
      .pipeThrough(
        new TransformStream({
          async transform({ data: r }, a) {
            r !== "[DONE]" && a.enqueue(await Ua({ text: r, schema: e }));
          },
        })
      );
  }
  var Y2 = () => globalThis.fetch,
    Id = async ({
      url: t,
      headers: e,
      body: r,
      failedResponseHandler: a,
      successfulResponseHandler: n,
      abortSignal: s,
      fetch: o,
    }) =>
      X2({
        url: t,
        headers: { "Content-Type": "application/json", ...e },
        body: { content: JSON.stringify(r), values: r },
        failedResponseHandler: a,
        successfulResponseHandler: n,
        abortSignal: s,
        fetch: o,
      }),
    X2 = async ({
      url: t,
      headers: e = {},
      body: r,
      successfulResponseHandler: a,
      failedResponseHandler: n,
      abortSignal: s,
      fetch: o = Y2(),
    }) => {
      try {
        const i = await o(t, {
            method: "POST",
            headers: Kg(e),
            body: r.content,
            signal: s,
          }),
          l = Zs(i);
        if (!i.ok) {
          let c;
          try {
            c = await n({ response: i, url: t, requestBodyValues: r.values });
          } catch (u) {
            throw Jn(u) || Xe.isInstance(u)
              ? u
              : new Xe({
                  message: "Failed to process error response",
                  cause: u,
                  statusCode: i.status,
                  url: t,
                  responseHeaders: l,
                  requestBodyValues: r.values,
                });
          }
          throw c.value;
        }
        try {
          return await a({ response: i, url: t, requestBodyValues: r.values });
        } catch (c) {
          throw c instanceof Error && (Jn(c) || Xe.isInstance(c))
            ? c
            : new Xe({
                message: "Failed to process successful response",
                cause: c,
                statusCode: i.status,
                url: t,
                responseHeaders: l,
                requestBodyValues: r.values,
              });
        }
      } catch (i) {
        throw Jg({ error: i, url: t, requestBodyValues: r.values });
      }
    };
  function x9(t) {
    return t;
  }
  function Wg(t) {
    return { ...t, type: "dynamic" };
  }
  async function Kn(t) {
    return typeof t == "function" && (t = t()), Promise.resolve(t);
  }
  var Yi =
      ({ errorSchema: t, errorToMessage: e, isRetryable: r }) =>
      async ({ response: a, url: n, requestBodyValues: s }) => {
        const o = await a.text(),
          i = Zs(a);
        if (o.trim() === "")
          return {
            responseHeaders: i,
            value: new Xe({
              message: a.statusText,
              url: n,
              requestBodyValues: s,
              statusCode: a.status,
              responseHeaders: i,
              responseBody: o,
              isRetryable: r == null ? void 0 : r(a),
            }),
          };
        try {
          const l = await W2({ text: o, schema: t });
          return {
            responseHeaders: i,
            value: new Xe({
              message: e(l),
              url: n,
              requestBodyValues: s,
              statusCode: a.status,
              responseHeaders: i,
              responseBody: o,
              data: l,
              isRetryable: r == null ? void 0 : r(a, l),
            }),
          };
        } catch {
          return {
            responseHeaders: i,
            value: new Xe({
              message: a.statusText,
              url: n,
              requestBodyValues: s,
              statusCode: a.status,
              responseHeaders: i,
              responseBody: o,
              isRetryable: r == null ? void 0 : r(a),
            }),
          };
        }
      },
    eA =
      (t) =>
      async ({ response: e }) => {
        const r = Zs(e);
        if (e.body == null) throw new Sv({});
        return { responseHeaders: r, value: Q2({ stream: e.body, schema: t }) };
      },
    kd =
      (t) =>
      async ({ response: e, url: r, requestBodyValues: a }) => {
        const n = await e.text(),
          s = await Ua({ text: n, schema: t }),
          o = Zs(e);
        if (!s.success)
          throw new Xe({
            message: "Invalid JSON response",
            cause: s.error,
            statusCode: e.status,
            responseHeaders: o,
            responseBody: n,
            url: r,
            requestBodyValues: a,
          });
        return { responseHeaders: o, value: s.value, rawValue: s.rawValue };
      };
  function tA(t, e) {
    var r;
    const a = (r = void 0) != null ? r : !1;
    return Js(
      Ku(t, { $refStrategy: a ? "root" : "none", target: "jsonSchema7" }),
      {
        validate: async (n) => {
          const s = await t.safeParseAsync(n);
          return s.success
            ? { success: !0, value: s.data }
            : { success: !1, error: s.error };
        },
      }
    );
  }
  function rA(t, e) {
    var r;
    const a = (r = void 0) != null ? r : !1,
      n = kO(t, {
        target: "draft-7",
        io: "output",
        reused: a ? "ref" : "inline",
      });
    return Js(n, {
      validate: async (s) => {
        const o = await Ag(t, s);
        return o.success
          ? { success: !0, value: o.data }
          : { success: !1, error: o.error };
      },
    });
  }
  function nA(t) {
    return "_zod" in t;
  }
  function aA(t, e) {
    return nA(t) ? rA(t) : tA(t);
  }
  var Cd = Symbol.for("vercel.ai.schema");
  function Js(t, { validate: e } = {}) {
    return { [Cd]: !0, _type: void 0, [Qi]: !0, jsonSchema: t, validate: e };
  }
  function sA(t) {
    return (
      typeof t == "object" &&
      t !== null &&
      Cd in t &&
      t[Cd] === !0 &&
      "jsonSchema" in t &&
      "validate" in t
    );
  }
  function Xi(t) {
    return t == null
      ? Js({ properties: {}, additionalProperties: !1 })
      : sA(t)
      ? t
      : aA(t);
  }
  var { btoa: oA, atob: iA } = globalThis;
  function Qg(t) {
    const e = t.replace(/-/g, "+").replace(/_/g, "/"),
      r = iA(e);
    return Uint8Array.from(r, (a) => a.codePointAt(0));
  }
  function Rd(t) {
    let e = "";
    for (let r = 0; r < t.length; r++) e += String.fromCodePoint(t[r]);
    return oA(e);
  }
  function lA(t) {
    return t == null ? void 0 : t.replace(/\/$/, "");
  }
  function cA(t) {
    return t != null && typeof t[Symbol.asyncIterator] == "function";
  }
  async function* Yg({ execute: t, input: e, options: r }) {
    const a = t(e, r);
    if (cA(a)) {
      let n;
      for await (const s of a)
        (n = s), yield { type: "preliminary", output: s };
      yield { type: "final", output: n };
    } else yield { type: "final", output: await a };
  }
  var uA = "vercel.ai.gateway.error",
    Od = Symbol.for(uA),
    Xg,
    ey,
    nr = class L0 extends ((ey = Error), (Xg = Od), ey) {
      constructor({ message: e, statusCode: r = 500, cause: a }) {
        super(e), (this[Xg] = !0), (this.statusCode = r), (this.cause = a);
      }
      static isInstance(e) {
        return L0.hasMarker(e);
      }
      static hasMarker(e) {
        return typeof e == "object" && e !== null && Od in e && e[Od] === !0;
      }
    },
    ty = "GatewayAuthenticationError",
    dA = `vercel.ai.gateway.error.${ty}`,
    ry = Symbol.for(dA),
    ny,
    ay,
    el = class z0 extends ((ay = nr), (ny = ry), ay) {
      constructor({
        message: e = "Authentication failed",
        statusCode: r = 401,
        cause: a,
      } = {}) {
        super({ message: e, statusCode: r, cause: a }),
          (this[ny] = !0),
          (this.name = ty),
          (this.type = "authentication_error");
      }
      static isInstance(e) {
        return nr.hasMarker(e) && ry in e;
      }
      static createContextualError({
        apiKeyProvided: e,
        oidcTokenProvided: r,
        message: a = "Authentication failed",
        statusCode: n = 401,
        cause: s,
      }) {
        let o;
        return (
          e
            ? (o = `AI Gateway authentication failed: Invalid API key provided.

The token is expected to be provided via the 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`)
            : r
            ? (o = `AI Gateway authentication failed: Invalid OIDC token provided.

The token is expected to be provided via the 'VERCEL_OIDC_TOKEN' environment variable. It expires every 12 hours.
- make sure your Vercel project settings have OIDC enabled
- if running locally with 'vercel dev', the token is automatically obtained and refreshed
- if running locally with your own dev server, run 'vercel env pull' to fetch the token
- in production/preview, the token is automatically obtained and refreshed

Alternative: Provide an API key via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`)
            : (o = `AI Gateway authentication failed: No authentication provided.

Provide either an API key or OIDC token.

API key instructions:

The token is expected to be provided via the 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

OIDC token instructions:

The token is expected to be provided via the 'VERCEL_OIDC_TOKEN' environment variable. It expires every 12 hours.
- make sure your Vercel project settings have OIDC enabled
- if running locally with 'vercel dev', the token is automatically obtained and refreshed
- if running locally with your own dev server, run 'vercel env pull' to fetch the token
- in production/preview, the token is automatically obtained and refreshed`),
          new z0({ message: o, statusCode: n, cause: s })
        );
      }
    },
    sy = "GatewayInvalidRequestError",
    fA = `vercel.ai.gateway.error.${sy}`,
    oy = Symbol.for(fA),
    iy,
    ly,
    pA = class extends ((ly = nr), (iy = oy), ly) {
      constructor({
        message: t = "Invalid request",
        statusCode: e = 400,
        cause: r,
      } = {}) {
        super({ message: t, statusCode: e, cause: r }),
          (this[iy] = !0),
          (this.name = sy),
          (this.type = "invalid_request_error");
      }
      static isInstance(t) {
        return nr.hasMarker(t) && oy in t;
      }
    },
    cy = "GatewayRateLimitError",
    hA = `vercel.ai.gateway.error.${cy}`,
    uy = Symbol.for(hA),
    dy,
    fy,
    mA = class extends ((fy = nr), (dy = uy), fy) {
      constructor({
        message: t = "Rate limit exceeded",
        statusCode: e = 429,
        cause: r,
      } = {}) {
        super({ message: t, statusCode: e, cause: r }),
          (this[dy] = !0),
          (this.name = cy),
          (this.type = "rate_limit_exceeded");
      }
      static isInstance(t) {
        return nr.hasMarker(t) && uy in t;
      }
    },
    py = "GatewayModelNotFoundError",
    vA = `vercel.ai.gateway.error.${py}`,
    hy = Symbol.for(vA),
    gA = O({ modelId: S() }),
    my,
    vy,
    gy = class extends ((vy = nr), (my = hy), vy) {
      constructor({
        message: t = "Model not found",
        statusCode: e = 404,
        modelId: r,
        cause: a,
      } = {}) {
        super({ message: t, statusCode: e, cause: a }),
          (this[my] = !0),
          (this.name = py),
          (this.type = "model_not_found"),
          (this.modelId = r);
      }
      static isInstance(t) {
        return nr.hasMarker(t) && hy in t;
      }
    },
    yy = "GatewayInternalServerError",
    yA = `vercel.ai.gateway.error.${yy}`,
    _y = Symbol.for(yA),
    wy,
    by,
    Ey = class extends ((by = nr), (wy = _y), by) {
      constructor({
        message: t = "Internal server error",
        statusCode: e = 500,
        cause: r,
      } = {}) {
        super({ message: t, statusCode: e, cause: r }),
          (this[wy] = !0),
          (this.name = yy),
          (this.type = "internal_server_error");
      }
      static isInstance(t) {
        return nr.hasMarker(t) && _y in t;
      }
    },
    Sy = "GatewayResponseError",
    _A = `vercel.ai.gateway.error.${Sy}`,
    $y = Symbol.for(_A),
    Py,
    Ty,
    wA = class extends ((Ty = nr), (Py = $y), Ty) {
      constructor({
        message: t = "Invalid response from Gateway",
        statusCode: e = 502,
        response: r,
        validationError: a,
        cause: n,
      } = {}) {
        super({ message: t, statusCode: e, cause: n }),
          (this[Py] = !0),
          (this.name = Sy),
          (this.type = "response_error"),
          (this.response = r),
          (this.validationError = a);
      }
      static isInstance(t) {
        return nr.hasMarker(t) && $y in t;
      }
    };
  function xy({
    response: t,
    statusCode: e,
    defaultMessage: r = "Gateway request failed",
    cause: a,
    authMethod: n,
  }) {
    const s = bA.safeParse(t);
    if (!s.success)
      return new wA({
        message: `Invalid error response format: ${r}`,
        statusCode: e,
        response: t,
        validationError: s.error,
        cause: a,
      });
    const o = s.data,
      i = o.error.type,
      l = o.error.message;
    switch (i) {
      case "authentication_error":
        return el.createContextualError({
          apiKeyProvided: n === "api-key",
          oidcTokenProvided: n === "oidc",
          statusCode: e,
          cause: a,
        });
      case "invalid_request_error":
        return new pA({ message: l, statusCode: e, cause: a });
      case "rate_limit_exceeded":
        return new mA({ message: l, statusCode: e, cause: a });
      case "model_not_found": {
        const c = gA.safeParse(o.error.param);
        return new gy({
          message: l,
          statusCode: e,
          modelId: c.success ? c.data.modelId : void 0,
          cause: a,
        });
      }
      case "internal_server_error":
        return new Ey({ message: l, statusCode: e, cause: a });
      default:
        return new Ey({ message: l, statusCode: e, cause: a });
    }
  }
  var bA = O({
    error: O({
      message: S(),
      type: S().nullish(),
      param: Ft().nullish(),
      code: Fe([S(), K()]).nullish(),
    }),
  });
  function Ks(t, e) {
    var r;
    return nr.isInstance(t)
      ? t
      : Xe.isInstance(t)
      ? xy({
          response: EA(t),
          statusCode: (r = t.statusCode) != null ? r : 500,
          defaultMessage: "Gateway request failed",
          cause: t,
          authMethod: e,
        })
      : xy({
          response: {},
          statusCode: 500,
          defaultMessage:
            t instanceof Error
              ? `Gateway request failed: ${t.message}`
              : "Unknown Gateway error",
          cause: t,
          authMethod: e,
        });
  }
  function EA(t) {
    if (t.data !== void 0) return t.data;
    if (t.responseBody != null)
      try {
        return JSON.parse(t.responseBody);
      } catch {
        return t.responseBody;
      }
    return {};
  }
  var Iy = "ai-gateway-auth-method";
  function tl(t) {
    const e = SA.safeParse(t[Iy]);
    return e.success ? e.data : void 0;
  }
  var SA = Fe([W("api-key"), W("oidc")]),
    $A = class {
      constructor(t) {
        this.config = t;
      }
      async getAvailableModels() {
        try {
          const { value: t } = await q2({
            url: `${this.config.baseURL}/config`,
            headers: await Kn(this.config.headers()),
            successfulResponseHandler: kd(IA),
            failedResponseHandler: Yi({
              errorSchema: Tr(),
              errorToMessage: (e) => e,
            }),
            fetch: this.config.fetch,
          });
          return t;
        } catch (t) {
          throw Ks(t);
        }
      }
    },
    PA = O({ specificationVersion: W("v2"), provider: S(), modelId: S() }),
    TA = O({ input: S(), output: S() }),
    xA = O({
      id: S(),
      name: S(),
      description: S().nullish(),
      pricing: TA.nullish(),
      specification: PA,
    }),
    IA = O({ models: ce(xA) }),
    kA = class {
      constructor(t, e) {
        (this.modelId = t),
          (this.config = e),
          (this.specificationVersion = "v2"),
          (this.supportedUrls = { "*/*": [/.*/] });
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs(t) {
        const { abortSignal: e, ...r } = t;
        return { args: this.maybeEncodeFileParts(r), warnings: [] };
      }
      async doGenerate(t) {
        const { args: e, warnings: r } = await this.getArgs(t),
          { abortSignal: a } = t,
          n = await Kn(this.config.headers());
        try {
          const {
            responseHeaders: s,
            value: o,
            rawValue: i,
          } = await Id({
            url: this.getUrl(),
            headers: Pd(
              n,
              t.headers,
              this.getModelConfigHeaders(this.modelId, !1),
              await Kn(this.config.o11yHeaders)
            ),
            body: e,
            successfulResponseHandler: kd(Tr()),
            failedResponseHandler: Yi({
              errorSchema: Tr(),
              errorToMessage: (l) => l,
            }),
            ...(a && { abortSignal: a }),
            fetch: this.config.fetch,
          });
          return {
            ...o,
            request: { body: e },
            response: { headers: s, body: i },
            warnings: r,
          };
        } catch (s) {
          throw Ks(s, tl(n));
        }
      }
      async doStream(t) {
        const { args: e, warnings: r } = await this.getArgs(t),
          { abortSignal: a } = t,
          n = await Kn(this.config.headers());
        try {
          const { value: s, responseHeaders: o } = await Id({
            url: this.getUrl(),
            headers: Pd(
              n,
              t.headers,
              this.getModelConfigHeaders(this.modelId, !0),
              await Kn(this.config.o11yHeaders)
            ),
            body: e,
            successfulResponseHandler: eA(Tr()),
            failedResponseHandler: Yi({
              errorSchema: Tr(),
              errorToMessage: (i) => i,
            }),
            ...(a && { abortSignal: a }),
            fetch: this.config.fetch,
          });
          return {
            stream: s.pipeThrough(
              new TransformStream({
                start(i) {
                  r.length > 0 &&
                    i.enqueue({ type: "stream-start", warnings: r });
                },
                transform(i, l) {
                  if (i.success) {
                    const c = i.value;
                    if (c.type === "raw" && !t.includeRawChunks) return;
                    c.type === "response-metadata" &&
                      c.timestamp &&
                      typeof c.timestamp == "string" &&
                      (c.timestamp = new Date(c.timestamp)),
                      l.enqueue(c);
                  } else l.error(i.error);
                },
              })
            ),
            request: { body: e },
            response: { headers: o },
          };
        } catch (s) {
          throw Ks(s, tl(n));
        }
      }
      isFilePart(t) {
        return t && typeof t == "object" && "type" in t && t.type === "file";
      }
      maybeEncodeFileParts(t) {
        for (const e of t.prompt)
          for (const r of e.content)
            if (this.isFilePart(r)) {
              const a = r;
              if (a.data instanceof Uint8Array) {
                const n = Uint8Array.from(a.data),
                  s = Buffer.from(n).toString("base64");
                a.data = new URL(
                  `data:${
                    a.mediaType || "application/octet-stream"
                  };base64,${s}`
                );
              }
            }
        return t;
      }
      getUrl() {
        return `${this.config.baseURL}/language-model`;
      }
      getModelConfigHeaders(t, e) {
        return {
          "ai-language-model-specification-version": "2",
          "ai-language-model-id": t,
          "ai-language-model-streaming": String(e),
        };
      }
    },
    CA = class {
      constructor(t, e) {
        (this.modelId = t),
          (this.config = e),
          (this.specificationVersion = "v2"),
          (this.maxEmbeddingsPerCall = 2048),
          (this.supportsParallelCalls = !0);
      }
      get provider() {
        return this.config.provider;
      }
      async doEmbed({
        values: t,
        headers: e,
        abortSignal: r,
        providerOptions: a,
      }) {
        var n;
        const s = await Kn(this.config.headers());
        try {
          const {
            responseHeaders: o,
            value: i,
            rawValue: l,
          } = await Id({
            url: this.getUrl(),
            headers: Pd(
              s,
              e ?? {},
              this.getModelConfigHeaders(),
              await Kn(this.config.o11yHeaders)
            ),
            body: { input: t.length === 1 ? t[0] : t, ...(a ?? {}) },
            successfulResponseHandler: kd(RA),
            failedResponseHandler: Yi({
              errorSchema: Tr(),
              errorToMessage: (c) => c,
            }),
            ...(r && { abortSignal: r }),
            fetch: this.config.fetch,
          });
          return {
            embeddings: i.embeddings,
            usage: (n = i.usage) != null ? n : void 0,
            providerMetadata: i.providerMetadata,
            response: { headers: o, body: l },
          };
        } catch (o) {
          throw Ks(o, tl(s));
        }
      }
      getUrl() {
        return `${this.config.baseURL}/embedding-model`;
      }
      getModelConfigHeaders() {
        return {
          "ai-embedding-model-specification-version": "2",
          "ai-model-id": this.modelId,
        };
      }
    },
    RA = O({
      embeddings: ce(ce(K())),
      usage: O({ tokens: K() }).nullish(),
      providerMetadata: Xt(S(), Xt(S(), Ft())).optional(),
    });
  async function OA() {
    var t, e;
    const r =
      (e = (t = ky().headers) == null ? void 0 : t["x-vercel-oidc-token"]) !=
      null
        ? e
        : process.env.VERCEL_OIDC_TOKEN;
    if (!r)
      throw new el({ message: "OIDC token not available", statusCode: 401 });
    return r;
  }
  async function AA() {
    var t;
    return (t = ky().headers) == null ? void 0 : t["x-vercel-id"];
  }
  var NA = Symbol.for("@vercel/request-context");
  function ky() {
    var t, e, r;
    return (r =
      (e = (t = globalThis[NA]) == null ? void 0 : t.get) == null
        ? void 0
        : e.call(t)) != null
      ? r
      : {};
  }
  var MA = "0.0.1";
  function jA(t = {}) {
    var e, r;
    let a = null,
      n = null;
    const s = (e = t.metadataCacheRefreshMillis) != null ? e : 1e3 * 60 * 5;
    let o = 0;
    const i =
        (r = lA(t.baseURL)) != null ? r : "https://ai-gateway.vercel.sh/v1/ai",
      l = async () => {
        const d = await LA(t);
        if (d)
          return {
            Authorization: `Bearer ${d.token}`,
            "ai-gateway-protocol-version": MA,
            [Iy]: d.authMethod,
            ...t.headers,
          };
        throw el.createContextualError({
          apiKeyProvided: !1,
          oidcTokenProvided: !1,
          statusCode: 401,
        });
      },
      c = () => {
        const d = Wi({
            settingValue: void 0,
            environmentVariableName: "VERCEL_DEPLOYMENT_ID",
          }),
          p = Wi({
            settingValue: void 0,
            environmentVariableName: "VERCEL_ENV",
          }),
          g = Wi({
            settingValue: void 0,
            environmentVariableName: "VERCEL_REGION",
          });
        return async () => {
          const m = await AA();
          return {
            ...(d && { "ai-o11y-deployment-id": d }),
            ...(p && { "ai-o11y-environment": p }),
            ...(g && { "ai-o11y-region": g }),
            ...(m && { "ai-o11y-request-id": m }),
          };
        };
      },
      u = (d) =>
        new kA(d, {
          provider: "gateway",
          baseURL: i,
          headers: l,
          fetch: t.fetch,
          o11yHeaders: c(),
        }),
      f = async () => {
        var d, p, g;
        const m =
          (g =
            (p = (d = t._internal) == null ? void 0 : d.currentDate) == null
              ? void 0
              : p.call(d).getTime()) != null
            ? g
            : Date.now();
        return (
          (!a || m - o > s) &&
            ((o = m),
            (a = new $A({ baseURL: i, headers: l, fetch: t.fetch })
              .getAvailableModels()
              .then((h) => ((n = h), h))
              .catch(async (h) => {
                throw Ks(h, tl(await l()));
              }))),
          n ? Promise.resolve(n) : a
        );
      },
      v = function (d) {
        if (new.target)
          throw new Error(
            "The Gateway Provider model function cannot be called with the new keyword."
          );
        return u(d);
      };
    return (
      (v.getAvailableModels = f),
      (v.imageModel = (d) => {
        throw new fd({ modelId: d, modelType: "imageModel" });
      }),
      (v.languageModel = u),
      (v.textEmbeddingModel = (d) =>
        new CA(d, {
          provider: "gateway",
          baseURL: i,
          headers: l,
          fetch: t.fetch,
          o11yHeaders: c(),
        })),
      v
    );
  }
  var DA = jA();
  async function LA(t) {
    const e = Wi({
      settingValue: t.apiKey,
      environmentVariableName: "AI_GATEWAY_API_KEY",
    });
    if (e) return { token: e, authMethod: "api-key" };
    try {
      return { token: await OA(), authMethod: "oidc" };
    } catch {
      return null;
    }
  }
  var zA =
      typeof globalThis == "object"
        ? globalThis
        : typeof self == "object"
        ? self
        : typeof window == "object"
        ? window
        : typeof global == "object"
        ? global
        : {},
    Gn = "1.9.0",
    Cy = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function qA(t) {
    var e = new Set([t]),
      r = new Set(),
      a = t.match(Cy);
    if (!a)
      return function () {
        return !1;
      };
    var n = { major: +a[1], minor: +a[2], patch: +a[3], prerelease: a[4] };
    if (n.prerelease != null)
      return function (l) {
        return l === t;
      };
    function s(i) {
      return r.add(i), !1;
    }
    function o(i) {
      return e.add(i), !0;
    }
    return function (l) {
      if (e.has(l)) return !0;
      if (r.has(l)) return !1;
      var c = l.match(Cy);
      if (!c) return s(l);
      var u = { major: +c[1], minor: +c[2], patch: +c[3], prerelease: c[4] };
      return u.prerelease != null || n.major !== u.major
        ? s(l)
        : n.major === 0
        ? n.minor === u.minor && n.patch <= u.patch
          ? o(l)
          : s(l)
        : n.minor <= u.minor
        ? o(l)
        : s(l);
    };
  }
  var UA = qA(Gn),
    FA = Gn.split(".")[0],
    Gs = Symbol.for("opentelemetry.js.api." + FA),
    Ws = zA;
  function Qs(t, e, r, a) {
    var n;
    a === void 0 && (a = !1);
    var s = (Ws[Gs] =
      (n = Ws[Gs]) !== null && n !== void 0 ? n : { version: Gn });
    if (!a && s[t]) {
      var o = new Error(
        "@opentelemetry/api: Attempted duplicate registration of API: " + t
      );
      return r.error(o.stack || o.message), !1;
    }
    if (s.version !== Gn) {
      var o = new Error(
        "@opentelemetry/api: Registration of version v" +
          s.version +
          " for " +
          t +
          " does not match previously registered API v" +
          Gn
      );
      return r.error(o.stack || o.message), !1;
    }
    return (
      (s[t] = e),
      r.debug(
        "@opentelemetry/api: Registered a global for " + t + " v" + Gn + "."
      ),
      !0
    );
  }
  function Wn(t) {
    var e,
      r,
      a = (e = Ws[Gs]) === null || e === void 0 ? void 0 : e.version;
    if (!(!a || !UA(a)))
      return (r = Ws[Gs]) === null || r === void 0 ? void 0 : r[t];
  }
  function Ys(t, e) {
    e.debug(
      "@opentelemetry/api: Unregistering a global for " + t + " v" + Gn + "."
    );
    var r = Ws[Gs];
    r && delete r[t];
  }
  var VA = function (t, e) {
      var r = typeof Symbol == "function" && t[Symbol.iterator];
      if (!r) return t;
      var a = r.call(t),
        n,
        s = [],
        o;
      try {
        for (; (e === void 0 || e-- > 0) && !(n = a.next()).done; )
          s.push(n.value);
      } catch (i) {
        o = { error: i };
      } finally {
        try {
          n && !n.done && (r = a.return) && r.call(a);
        } finally {
          if (o) throw o.error;
        }
      }
      return s;
    },
    ZA = function (t, e, r) {
      if (r || arguments.length === 2)
        for (var a = 0, n = e.length, s; a < n; a++)
          (s || !(a in e)) &&
            (s || (s = Array.prototype.slice.call(e, 0, a)), (s[a] = e[a]));
      return t.concat(s || Array.prototype.slice.call(e));
    },
    HA = (function () {
      function t(e) {
        this._namespace = e.namespace || "DiagComponentLogger";
      }
      return (
        (t.prototype.debug = function () {
          for (var e = [], r = 0; r < arguments.length; r++)
            e[r] = arguments[r];
          return Xs("debug", this._namespace, e);
        }),
        (t.prototype.error = function () {
          for (var e = [], r = 0; r < arguments.length; r++)
            e[r] = arguments[r];
          return Xs("error", this._namespace, e);
        }),
        (t.prototype.info = function () {
          for (var e = [], r = 0; r < arguments.length; r++)
            e[r] = arguments[r];
          return Xs("info", this._namespace, e);
        }),
        (t.prototype.warn = function () {
          for (var e = [], r = 0; r < arguments.length; r++)
            e[r] = arguments[r];
          return Xs("warn", this._namespace, e);
        }),
        (t.prototype.verbose = function () {
          for (var e = [], r = 0; r < arguments.length; r++)
            e[r] = arguments[r];
          return Xs("verbose", this._namespace, e);
        }),
        t
      );
    })();
  function Xs(t, e, r) {
    var a = Wn("diag");
    if (a) return r.unshift(e), a[t].apply(a, ZA([], VA(r), !1));
  }
  var ar;
  (function (t) {
    (t[(t.NONE = 0)] = "NONE"),
      (t[(t.ERROR = 30)] = "ERROR"),
      (t[(t.WARN = 50)] = "WARN"),
      (t[(t.INFO = 60)] = "INFO"),
      (t[(t.DEBUG = 70)] = "DEBUG"),
      (t[(t.VERBOSE = 80)] = "VERBOSE"),
      (t[(t.ALL = 9999)] = "ALL");
  })(ar || (ar = {}));
  function BA(t, e) {
    t < ar.NONE ? (t = ar.NONE) : t > ar.ALL && (t = ar.ALL), (e = e || {});
    function r(a, n) {
      var s = e[a];
      return typeof s == "function" && t >= n ? s.bind(e) : function () {};
    }
    return {
      error: r("error", ar.ERROR),
      warn: r("warn", ar.WARN),
      info: r("info", ar.INFO),
      debug: r("debug", ar.DEBUG),
      verbose: r("verbose", ar.VERBOSE),
    };
  }
  var JA = function (t, e) {
      var r = typeof Symbol == "function" && t[Symbol.iterator];
      if (!r) return t;
      var a = r.call(t),
        n,
        s = [],
        o;
      try {
        for (; (e === void 0 || e-- > 0) && !(n = a.next()).done; )
          s.push(n.value);
      } catch (i) {
        o = { error: i };
      } finally {
        try {
          n && !n.done && (r = a.return) && r.call(a);
        } finally {
          if (o) throw o.error;
        }
      }
      return s;
    },
    KA = function (t, e, r) {
      if (r || arguments.length === 2)
        for (var a = 0, n = e.length, s; a < n; a++)
          (s || !(a in e)) &&
            (s || (s = Array.prototype.slice.call(e, 0, a)), (s[a] = e[a]));
      return t.concat(s || Array.prototype.slice.call(e));
    },
    GA = "diag",
    Zr = (function () {
      function t() {
        function e(n) {
          return function () {
            for (var s = [], o = 0; o < arguments.length; o++)
              s[o] = arguments[o];
            var i = Wn("diag");
            if (i) return i[n].apply(i, KA([], JA(s), !1));
          };
        }
        var r = this,
          a = function (n, s) {
            var o, i, l;
            if ((s === void 0 && (s = { logLevel: ar.INFO }), n === r)) {
              var c = new Error(
                "Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation"
              );
              return (
                r.error((o = c.stack) !== null && o !== void 0 ? o : c.message),
                !1
              );
            }
            typeof s == "number" && (s = { logLevel: s });
            var u = Wn("diag"),
              f = BA(
                (i = s.logLevel) !== null && i !== void 0 ? i : ar.INFO,
                n
              );
            if (u && !s.suppressOverrideMessage) {
              var v =
                (l = new Error().stack) !== null && l !== void 0
                  ? l
                  : "<failed to generate stacktrace>";
              u.warn("Current logger will be overwritten from " + v),
                f.warn(
                  "Current logger will overwrite one already registered from " +
                    v
                );
            }
            return Qs("diag", f, r, !0);
          };
        (r.setLogger = a),
          (r.disable = function () {
            Ys(GA, r);
          }),
          (r.createComponentLogger = function (n) {
            return new HA(n);
          }),
          (r.verbose = e("verbose")),
          (r.debug = e("debug")),
          (r.info = e("info")),
          (r.warn = e("warn")),
          (r.error = e("error"));
      }
      return (
        (t.instance = function () {
          return this._instance || (this._instance = new t()), this._instance;
        }),
        t
      );
    })(),
    WA = function (t, e) {
      var r = typeof Symbol == "function" && t[Symbol.iterator];
      if (!r) return t;
      var a = r.call(t),
        n,
        s = [],
        o;
      try {
        for (; (e === void 0 || e-- > 0) && !(n = a.next()).done; )
          s.push(n.value);
      } catch (i) {
        o = { error: i };
      } finally {
        try {
          n && !n.done && (r = a.return) && r.call(a);
        } finally {
          if (o) throw o.error;
        }
      }
      return s;
    },
    QA = function (t) {
      var e = typeof Symbol == "function" && Symbol.iterator,
        r = e && t[e],
        a = 0;
      if (r) return r.call(t);
      if (t && typeof t.length == "number")
        return {
          next: function () {
            return (
              t && a >= t.length && (t = void 0),
              { value: t && t[a++], done: !t }
            );
          },
        };
      throw new TypeError(
        e ? "Object is not iterable." : "Symbol.iterator is not defined."
      );
    },
    YA = (function () {
      function t(e) {
        this._entries = e ? new Map(e) : new Map();
      }
      return (
        (t.prototype.getEntry = function (e) {
          var r = this._entries.get(e);
          if (r) return Object.assign({}, r);
        }),
        (t.prototype.getAllEntries = function () {
          return Array.from(this._entries.entries()).map(function (e) {
            var r = WA(e, 2),
              a = r[0],
              n = r[1];
            return [a, n];
          });
        }),
        (t.prototype.setEntry = function (e, r) {
          var a = new t(this._entries);
          return a._entries.set(e, r), a;
        }),
        (t.prototype.removeEntry = function (e) {
          var r = new t(this._entries);
          return r._entries.delete(e), r;
        }),
        (t.prototype.removeEntries = function () {
          for (var e, r, a = [], n = 0; n < arguments.length; n++)
            a[n] = arguments[n];
          var s = new t(this._entries);
          try {
            for (var o = QA(a), i = o.next(); !i.done; i = o.next()) {
              var l = i.value;
              s._entries.delete(l);
            }
          } catch (c) {
            e = { error: c };
          } finally {
            try {
              i && !i.done && (r = o.return) && r.call(o);
            } finally {
              if (e) throw e.error;
            }
          }
          return s;
        }),
        (t.prototype.clear = function () {
          return new t();
        }),
        t
      );
    })();
  Zr.instance();
  function XA(t) {
    return t === void 0 && (t = {}), new YA(new Map(Object.entries(t)));
  }
  function Ry(t) {
    return Symbol.for(t);
  }
  var eN = (function () {
      function t(e) {
        var r = this;
        (r._currentContext = e ? new Map(e) : new Map()),
          (r.getValue = function (a) {
            return r._currentContext.get(a);
          }),
          (r.setValue = function (a, n) {
            var s = new t(r._currentContext);
            return s._currentContext.set(a, n), s;
          }),
          (r.deleteValue = function (a) {
            var n = new t(r._currentContext);
            return n._currentContext.delete(a), n;
          });
      }
      return t;
    })(),
    tN = new eN(),
    Qn = (function () {
      var t = function (e, r) {
        return (
          (t =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (a, n) {
                a.__proto__ = n;
              }) ||
            function (a, n) {
              for (var s in n)
                Object.prototype.hasOwnProperty.call(n, s) && (a[s] = n[s]);
            }),
          t(e, r)
        );
      };
      return function (e, r) {
        if (typeof r != "function" && r !== null)
          throw new TypeError(
            "Class extends value " + String(r) + " is not a constructor or null"
          );
        t(e, r);
        function a() {
          this.constructor = e;
        }
        e.prototype =
          r === null
            ? Object.create(r)
            : ((a.prototype = r.prototype), new a());
      };
    })(),
    rN = (function () {
      function t() {}
      return (
        (t.prototype.createGauge = function (e, r) {
          return fN;
        }),
        (t.prototype.createHistogram = function (e, r) {
          return pN;
        }),
        (t.prototype.createCounter = function (e, r) {
          return dN;
        }),
        (t.prototype.createUpDownCounter = function (e, r) {
          return hN;
        }),
        (t.prototype.createObservableGauge = function (e, r) {
          return vN;
        }),
        (t.prototype.createObservableCounter = function (e, r) {
          return mN;
        }),
        (t.prototype.createObservableUpDownCounter = function (e, r) {
          return gN;
        }),
        (t.prototype.addBatchObservableCallback = function (e, r) {}),
        (t.prototype.removeBatchObservableCallback = function (e) {}),
        t
      );
    })(),
    rl = (function () {
      function t() {}
      return t;
    })(),
    nN = (function (t) {
      Qn(e, t);
      function e() {
        return (t !== null && t.apply(this, arguments)) || this;
      }
      return (e.prototype.add = function (r, a) {}), e;
    })(rl),
    aN = (function (t) {
      Qn(e, t);
      function e() {
        return (t !== null && t.apply(this, arguments)) || this;
      }
      return (e.prototype.add = function (r, a) {}), e;
    })(rl),
    sN = (function (t) {
      Qn(e, t);
      function e() {
        return (t !== null && t.apply(this, arguments)) || this;
      }
      return (e.prototype.record = function (r, a) {}), e;
    })(rl),
    oN = (function (t) {
      Qn(e, t);
      function e() {
        return (t !== null && t.apply(this, arguments)) || this;
      }
      return (e.prototype.record = function (r, a) {}), e;
    })(rl),
    Ad = (function () {
      function t() {}
      return (
        (t.prototype.addCallback = function (e) {}),
        (t.prototype.removeCallback = function (e) {}),
        t
      );
    })(),
    iN = (function (t) {
      Qn(e, t);
      function e() {
        return (t !== null && t.apply(this, arguments)) || this;
      }
      return e;
    })(Ad),
    lN = (function (t) {
      Qn(e, t);
      function e() {
        return (t !== null && t.apply(this, arguments)) || this;
      }
      return e;
    })(Ad),
    cN = (function (t) {
      Qn(e, t);
      function e() {
        return (t !== null && t.apply(this, arguments)) || this;
      }
      return e;
    })(Ad),
    uN = new rN(),
    dN = new nN(),
    fN = new sN(),
    pN = new oN(),
    hN = new aN(),
    mN = new iN(),
    vN = new lN(),
    gN = new cN(),
    yN = {
      get: function (t, e) {
        if (t != null) return t[e];
      },
      keys: function (t) {
        return t == null ? [] : Object.keys(t);
      },
    },
    _N = {
      set: function (t, e, r) {
        t != null && (t[e] = r);
      },
    },
    wN = function (t, e) {
      var r = typeof Symbol == "function" && t[Symbol.iterator];
      if (!r) return t;
      var a = r.call(t),
        n,
        s = [],
        o;
      try {
        for (; (e === void 0 || e-- > 0) && !(n = a.next()).done; )
          s.push(n.value);
      } catch (i) {
        o = { error: i };
      } finally {
        try {
          n && !n.done && (r = a.return) && r.call(a);
        } finally {
          if (o) throw o.error;
        }
      }
      return s;
    },
    bN = function (t, e, r) {
      if (r || arguments.length === 2)
        for (var a = 0, n = e.length, s; a < n; a++)
          (s || !(a in e)) &&
            (s || (s = Array.prototype.slice.call(e, 0, a)), (s[a] = e[a]));
      return t.concat(s || Array.prototype.slice.call(e));
    },
    EN = (function () {
      function t() {}
      return (
        (t.prototype.active = function () {
          return tN;
        }),
        (t.prototype.with = function (e, r, a) {
          for (var n = [], s = 3; s < arguments.length; s++)
            n[s - 3] = arguments[s];
          return r.call.apply(r, bN([a], wN(n), !1));
        }),
        (t.prototype.bind = function (e, r) {
          return r;
        }),
        (t.prototype.enable = function () {
          return this;
        }),
        (t.prototype.disable = function () {
          return this;
        }),
        t
      );
    })(),
    SN = function (t, e) {
      var r = typeof Symbol == "function" && t[Symbol.iterator];
      if (!r) return t;
      var a = r.call(t),
        n,
        s = [],
        o;
      try {
        for (; (e === void 0 || e-- > 0) && !(n = a.next()).done; )
          s.push(n.value);
      } catch (i) {
        o = { error: i };
      } finally {
        try {
          n && !n.done && (r = a.return) && r.call(a);
        } finally {
          if (o) throw o.error;
        }
      }
      return s;
    },
    $N = function (t, e, r) {
      if (r || arguments.length === 2)
        for (var a = 0, n = e.length, s; a < n; a++)
          (s || !(a in e)) &&
            (s || (s = Array.prototype.slice.call(e, 0, a)), (s[a] = e[a]));
      return t.concat(s || Array.prototype.slice.call(e));
    },
    Nd = "context",
    PN = new EN(),
    nl = (function () {
      function t() {}
      return (
        (t.getInstance = function () {
          return this._instance || (this._instance = new t()), this._instance;
        }),
        (t.prototype.setGlobalContextManager = function (e) {
          return Qs(Nd, e, Zr.instance());
        }),
        (t.prototype.active = function () {
          return this._getContextManager().active();
        }),
        (t.prototype.with = function (e, r, a) {
          for (var n, s = [], o = 3; o < arguments.length; o++)
            s[o - 3] = arguments[o];
          return (n = this._getContextManager()).with.apply(
            n,
            $N([e, r, a], SN(s), !1)
          );
        }),
        (t.prototype.bind = function (e, r) {
          return this._getContextManager().bind(e, r);
        }),
        (t.prototype._getContextManager = function () {
          return Wn(Nd) || PN;
        }),
        (t.prototype.disable = function () {
          this._getContextManager().disable(), Ys(Nd, Zr.instance());
        }),
        t
      );
    })(),
    Md;
  (function (t) {
    (t[(t.NONE = 0)] = "NONE"), (t[(t.SAMPLED = 1)] = "SAMPLED");
  })(Md || (Md = {}));
  var Oy = "0000000000000000",
    Ay = "00000000000000000000000000000000",
    TN = { traceId: Ay, spanId: Oy, traceFlags: Md.NONE },
    eo = (function () {
      function t(e) {
        e === void 0 && (e = TN), (this._spanContext = e);
      }
      return (
        (t.prototype.spanContext = function () {
          return this._spanContext;
        }),
        (t.prototype.setAttribute = function (e, r) {
          return this;
        }),
        (t.prototype.setAttributes = function (e) {
          return this;
        }),
        (t.prototype.addEvent = function (e, r) {
          return this;
        }),
        (t.prototype.addLink = function (e) {
          return this;
        }),
        (t.prototype.addLinks = function (e) {
          return this;
        }),
        (t.prototype.setStatus = function (e) {
          return this;
        }),
        (t.prototype.updateName = function (e) {
          return this;
        }),
        (t.prototype.end = function (e) {}),
        (t.prototype.isRecording = function () {
          return !1;
        }),
        (t.prototype.recordException = function (e, r) {}),
        t
      );
    })(),
    jd = Ry("OpenTelemetry Context Key SPAN");
  function Dd(t) {
    return t.getValue(jd) || void 0;
  }
  function xN() {
    return Dd(nl.getInstance().active());
  }
  function Ld(t, e) {
    return t.setValue(jd, e);
  }
  function IN(t) {
    return t.deleteValue(jd);
  }
  function kN(t, e) {
    return Ld(t, new eo(e));
  }
  function Ny(t) {
    var e;
    return (e = Dd(t)) === null || e === void 0 ? void 0 : e.spanContext();
  }
  var CN = /^([0-9a-f]{32})$/i,
    RN = /^[0-9a-f]{16}$/i;
  function ON(t) {
    return CN.test(t) && t !== Ay;
  }
  function AN(t) {
    return RN.test(t) && t !== Oy;
  }
  function My(t) {
    return ON(t.traceId) && AN(t.spanId);
  }
  function NN(t) {
    return new eo(t);
  }
  var zd = nl.getInstance(),
    jy = (function () {
      function t() {}
      return (
        (t.prototype.startSpan = function (e, r, a) {
          a === void 0 && (a = zd.active());
          var n = !!(r != null && r.root);
          if (n) return new eo();
          var s = a && Ny(a);
          return MN(s) && My(s) ? new eo(s) : new eo();
        }),
        (t.prototype.startActiveSpan = function (e, r, a, n) {
          var s, o, i;
          if (!(arguments.length < 2)) {
            arguments.length === 2
              ? (i = r)
              : arguments.length === 3
              ? ((s = r), (i = a))
              : ((s = r), (o = a), (i = n));
            var l = o ?? zd.active(),
              c = this.startSpan(e, s, l),
              u = Ld(l, c);
            return zd.with(u, i, void 0, c);
          }
        }),
        t
      );
    })();
  function MN(t) {
    return (
      typeof t == "object" &&
      typeof t.spanId == "string" &&
      typeof t.traceId == "string" &&
      typeof t.traceFlags == "number"
    );
  }
  var jN = new jy(),
    DN = (function () {
      function t(e, r, a, n) {
        (this._provider = e),
          (this.name = r),
          (this.version = a),
          (this.options = n);
      }
      return (
        (t.prototype.startSpan = function (e, r, a) {
          return this._getTracer().startSpan(e, r, a);
        }),
        (t.prototype.startActiveSpan = function (e, r, a, n) {
          var s = this._getTracer();
          return Reflect.apply(s.startActiveSpan, s, arguments);
        }),
        (t.prototype._getTracer = function () {
          if (this._delegate) return this._delegate;
          var e = this._provider.getDelegateTracer(
            this.name,
            this.version,
            this.options
          );
          return e ? ((this._delegate = e), this._delegate) : jN;
        }),
        t
      );
    })(),
    LN = (function () {
      function t() {}
      return (
        (t.prototype.getTracer = function (e, r, a) {
          return new jy();
        }),
        t
      );
    })(),
    zN = new LN(),
    Dy = (function () {
      function t() {}
      return (
        (t.prototype.getTracer = function (e, r, a) {
          var n;
          return (n = this.getDelegateTracer(e, r, a)) !== null && n !== void 0
            ? n
            : new DN(this, e, r, a);
        }),
        (t.prototype.getDelegate = function () {
          var e;
          return (e = this._delegate) !== null && e !== void 0 ? e : zN;
        }),
        (t.prototype.setDelegate = function (e) {
          this._delegate = e;
        }),
        (t.prototype.getDelegateTracer = function (e, r, a) {
          var n;
          return (n = this._delegate) === null || n === void 0
            ? void 0
            : n.getTracer(e, r, a);
        }),
        t
      );
    })(),
    al;
  (function (t) {
    (t[(t.UNSET = 0)] = "UNSET"),
      (t[(t.OK = 1)] = "OK"),
      (t[(t.ERROR = 2)] = "ERROR");
  })(al || (al = {})),
    nl.getInstance(),
    Zr.instance();
  var qN = (function () {
      function t() {}
      return (
        (t.prototype.getMeter = function (e, r, a) {
          return uN;
        }),
        t
      );
    })(),
    UN = new qN(),
    qd = "metrics",
    FN = (function () {
      function t() {}
      return (
        (t.getInstance = function () {
          return this._instance || (this._instance = new t()), this._instance;
        }),
        (t.prototype.setGlobalMeterProvider = function (e) {
          return Qs(qd, e, Zr.instance());
        }),
        (t.prototype.getMeterProvider = function () {
          return Wn(qd) || UN;
        }),
        (t.prototype.getMeter = function (e, r, a) {
          return this.getMeterProvider().getMeter(e, r, a);
        }),
        (t.prototype.disable = function () {
          Ys(qd, Zr.instance());
        }),
        t
      );
    })();
  FN.getInstance();
  var VN = (function () {
      function t() {}
      return (
        (t.prototype.inject = function (e, r) {}),
        (t.prototype.extract = function (e, r) {
          return e;
        }),
        (t.prototype.fields = function () {
          return [];
        }),
        t
      );
    })(),
    Ud = Ry("OpenTelemetry Baggage Key");
  function Ly(t) {
    return t.getValue(Ud) || void 0;
  }
  function ZN() {
    return Ly(nl.getInstance().active());
  }
  function HN(t, e) {
    return t.setValue(Ud, e);
  }
  function BN(t) {
    return t.deleteValue(Ud);
  }
  var Fd = "propagation",
    JN = new VN(),
    KN = (function () {
      function t() {
        (this.createBaggage = XA),
          (this.getBaggage = Ly),
          (this.getActiveBaggage = ZN),
          (this.setBaggage = HN),
          (this.deleteBaggage = BN);
      }
      return (
        (t.getInstance = function () {
          return this._instance || (this._instance = new t()), this._instance;
        }),
        (t.prototype.setGlobalPropagator = function (e) {
          return Qs(Fd, e, Zr.instance());
        }),
        (t.prototype.inject = function (e, r, a) {
          return (
            a === void 0 && (a = _N),
            this._getGlobalPropagator().inject(e, r, a)
          );
        }),
        (t.prototype.extract = function (e, r, a) {
          return (
            a === void 0 && (a = yN),
            this._getGlobalPropagator().extract(e, r, a)
          );
        }),
        (t.prototype.fields = function () {
          return this._getGlobalPropagator().fields();
        }),
        (t.prototype.disable = function () {
          Ys(Fd, Zr.instance());
        }),
        (t.prototype._getGlobalPropagator = function () {
          return Wn(Fd) || JN;
        }),
        t
      );
    })();
  KN.getInstance();
  var Vd = "trace",
    GN = (function () {
      function t() {
        (this._proxyTracerProvider = new Dy()),
          (this.wrapSpanContext = NN),
          (this.isSpanContextValid = My),
          (this.deleteSpan = IN),
          (this.getSpan = Dd),
          (this.getActiveSpan = xN),
          (this.getSpanContext = Ny),
          (this.setSpan = Ld),
          (this.setSpanContext = kN);
      }
      return (
        (t.getInstance = function () {
          return this._instance || (this._instance = new t()), this._instance;
        }),
        (t.prototype.setGlobalTracerProvider = function (e) {
          var r = Qs(Vd, this._proxyTracerProvider, Zr.instance());
          return r && this._proxyTracerProvider.setDelegate(e), r;
        }),
        (t.prototype.getTracerProvider = function () {
          return Wn(Vd) || this._proxyTracerProvider;
        }),
        (t.prototype.getTracer = function (e, r) {
          return this.getTracerProvider().getTracer(e, r);
        }),
        (t.prototype.disable = function () {
          Ys(Vd, Zr.instance()), (this._proxyTracerProvider = new Dy());
        }),
        t
      );
    })(),
    WN = GN.getInstance(),
    QN = Object.defineProperty,
    YN = (t, e) => {
      for (var r in e) QN(t, r, { get: e[r], enumerable: !0 });
    },
    zy = "AI_NoOutputSpecifiedError",
    qy = `vercel.ai.error.${zy}`,
    XN = Symbol.for(qy),
    Uy,
    Fy = class extends Se {
      constructor({ message: t = "No output specified." } = {}) {
        super({ name: zy, message: t }), (this[Uy] = !0);
      }
      static isInstance(t) {
        return Se.hasMarker(t, qy);
      }
    };
  Uy = XN;
  var Vy = "AI_InvalidArgumentError",
    Zy = `vercel.ai.error.${Vy}`,
    eM = Symbol.for(Zy),
    Hy,
    Hr = class extends Se {
      constructor({ parameter: t, value: e, message: r }) {
        super({
          name: Vy,
          message: `Invalid argument for parameter ${t}: ${r}`,
        }),
          (this[Hy] = !0),
          (this.parameter = t),
          (this.value = e);
      }
      static isInstance(t) {
        return Se.hasMarker(t, Zy);
      }
    };
  Hy = eM;
  var By = "AI_InvalidToolInputError",
    Jy = `vercel.ai.error.${By}`,
    tM = Symbol.for(Jy),
    Ky,
    Gy = class extends Se {
      constructor({
        toolInput: t,
        toolName: e,
        cause: r,
        message: a = `Invalid input for tool ${e}: ${La(r)}`,
      }) {
        super({ name: By, message: a, cause: r }),
          (this[Ky] = !0),
          (this.toolInput = t),
          (this.toolName = e);
      }
      static isInstance(t) {
        return Se.hasMarker(t, Jy);
      }
    };
  Ky = tM;
  var rM = "AI_MCPClientError",
    Wy = `vercel.ai.error.${rM}`,
    nM = Symbol.for(Wy),
    Qy,
    Ct = class extends Se {
      constructor({ name: t = "MCPClientError", message: e, cause: r }) {
        super({ name: t, message: e, cause: r }), (this[Qy] = !0);
      }
      static isInstance(t) {
        return Se.hasMarker(t, Wy);
      }
    };
  Qy = nM;
  var Yy = "AI_NoObjectGeneratedError",
    Xy = `vercel.ai.error.${Yy}`,
    aM = Symbol.for(Xy),
    e_,
    t_ = class extends Se {
      constructor({
        message: t = "No object generated.",
        cause: e,
        text: r,
        response: a,
        usage: n,
        finishReason: s,
      }) {
        super({ name: Yy, message: t, cause: e }),
          (this[e_] = !0),
          (this.text = r),
          (this.response = a),
          (this.usage = n),
          (this.finishReason = s);
      }
      static isInstance(t) {
        return Se.hasMarker(t, Xy);
      }
    };
  e_ = aM;
  var r_ = "AI_NoOutputGeneratedError",
    n_ = `vercel.ai.error.${r_}`,
    sM = Symbol.for(n_),
    a_,
    oM = class extends Se {
      constructor({ message: t = "No output generated.", cause: e } = {}) {
        super({ name: r_, message: t, cause: e }), (this[a_] = !0);
      }
      static isInstance(t) {
        return Se.hasMarker(t, n_);
      }
    };
  a_ = sM;
  var s_ = "AI_NoSuchToolError",
    o_ = `vercel.ai.error.${s_}`,
    iM = Symbol.for(o_),
    i_,
    Zd = class extends Se {
      constructor({
        toolName: t,
        availableTools: e = void 0,
        message: r = `Model tried to call unavailable tool '${t}'. ${
          e === void 0
            ? "No tools are available."
            : `Available tools: ${e.join(", ")}.`
        }`,
      }) {
        super({ name: s_, message: r }),
          (this[i_] = !0),
          (this.toolName = t),
          (this.availableTools = e);
      }
      static isInstance(t) {
        return Se.hasMarker(t, o_);
      }
    };
  i_ = iM;
  var l_ = "AI_ToolCallRepairError",
    c_ = `vercel.ai.error.${l_}`,
    lM = Symbol.for(c_),
    u_,
    cM = class extends Se {
      constructor({
        cause: t,
        originalError: e,
        message: r = `Error repairing tool call: ${La(t)}`,
      }) {
        super({ name: l_, message: r, cause: t }),
          (this[u_] = !0),
          (this.originalError = e);
      }
      static isInstance(t) {
        return Se.hasMarker(t, c_);
      }
    };
  u_ = lM;
  var uM = class extends Se {
      constructor(t) {
        super({
          name: "AI_UnsupportedModelVersionError",
          message: `Unsupported model version ${t.version} for provider "${t.provider}" and model "${t.modelId}". AI SDK 5 only supports models that implement specification version "v2".`,
        }),
          (this.version = t.version),
          (this.provider = t.provider),
          (this.modelId = t.modelId);
      }
    },
    d_ = "AI_InvalidMessageRoleError",
    f_ = `vercel.ai.error.${d_}`,
    dM = Symbol.for(f_),
    p_,
    fM = class extends Se {
      constructor({
        role: t,
        message:
          e = `Invalid message role: '${t}'. Must be one of: "system", "user", "assistant", "tool".`,
      }) {
        super({ name: d_, message: e }), (this[p_] = !0), (this.role = t);
      }
      static isInstance(t) {
        return Se.hasMarker(t, f_);
      }
    };
  p_ = dM;
  var h_ = "AI_DownloadError",
    m_ = `vercel.ai.error.${h_}`,
    pM = Symbol.for(m_),
    v_,
    Hd = class extends Se {
      constructor({
        url: t,
        statusCode: e,
        statusText: r,
        cause: a,
        message: n = a == null
          ? `Failed to download ${t}: ${e} ${r}`
          : `Failed to download ${t}: ${a}`,
      }) {
        super({ name: h_, message: n, cause: a }),
          (this[v_] = !0),
          (this.url = t),
          (this.statusCode = e),
          (this.statusText = r);
      }
      static isInstance(t) {
        return Se.hasMarker(t, m_);
      }
    };
  v_ = pM;
  var g_ = "AI_RetryError",
    y_ = `vercel.ai.error.${g_}`,
    hM = Symbol.for(y_),
    __,
    w_ = class extends Se {
      constructor({ message: t, reason: e, errors: r }) {
        super({ name: g_, message: t }),
          (this[__] = !0),
          (this.reason = e),
          (this.errors = r),
          (this.lastError = r[r.length - 1]);
      }
      static isInstance(t) {
        return Se.hasMarker(t, y_);
      }
    };
  __ = hM;
  function sl(t) {
    if (typeof t != "string") {
      if (t.specificationVersion !== "v2")
        throw new uM({
          version: t.specificationVersion,
          provider: t.provider,
          modelId: t.modelId,
        });
      return t;
    }
    return mM().languageModel(t);
  }
  function mM() {
    var t;
    return (t = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? t : DA;
  }
  var vM = [
      {
        mediaType: "image/gif",
        bytesPrefix: [71, 73, 70],
        base64Prefix: "R0lG",
      },
      {
        mediaType: "image/png",
        bytesPrefix: [137, 80, 78, 71],
        base64Prefix: "iVBORw",
      },
      {
        mediaType: "image/jpeg",
        bytesPrefix: [255, 216],
        base64Prefix: "/9j/",
      },
      {
        mediaType: "image/webp",
        bytesPrefix: [82, 73, 70, 70],
        base64Prefix: "UklGRg",
      },
      { mediaType: "image/bmp", bytesPrefix: [66, 77], base64Prefix: "Qk" },
      {
        mediaType: "image/tiff",
        bytesPrefix: [73, 73, 42, 0],
        base64Prefix: "SUkqAA",
      },
      {
        mediaType: "image/tiff",
        bytesPrefix: [77, 77, 0, 42],
        base64Prefix: "TU0AKg",
      },
      {
        mediaType: "image/avif",
        bytesPrefix: [0, 0, 0, 32, 102, 116, 121, 112, 97, 118, 105, 102],
        base64Prefix: "AAAAIGZ0eXBhdmlm",
      },
      {
        mediaType: "image/heic",
        bytesPrefix: [0, 0, 0, 32, 102, 116, 121, 112, 104, 101, 105, 99],
        base64Prefix: "AAAAIGZ0eXBoZWlj",
      },
    ],
    gM = (t) => {
      const e = typeof t == "string" ? Qg(t) : t,
        r =
          ((e[6] & 127) << 21) |
          ((e[7] & 127) << 14) |
          ((e[8] & 127) << 7) |
          (e[9] & 127);
      return e.slice(r + 10);
    };
  function yM(t) {
    return (typeof t == "string" && t.startsWith("SUQz")) ||
      (typeof t != "string" &&
        t.length > 10 &&
        t[0] === 73 &&
        t[1] === 68 &&
        t[2] === 51)
      ? gM(t)
      : t;
  }
  function _M({ data: t, signatures: e }) {
    const r = yM(t);
    for (const a of e)
      if (
        typeof r == "string"
          ? r.startsWith(a.base64Prefix)
          : r.length >= a.bytesPrefix.length &&
            a.bytesPrefix.every((n, s) => r[s] === n)
      )
        return a.mediaType;
  }
  async function wM({ url: t }) {
    var e;
    const r = t.toString();
    try {
      const a = await fetch(r);
      if (!a.ok)
        throw new Hd({
          url: r,
          statusCode: a.status,
          statusText: a.statusText,
        });
      return {
        data: new Uint8Array(await a.arrayBuffer()),
        mediaType: (e = a.headers.get("content-type")) != null ? e : void 0,
      };
    } catch (a) {
      throw Hd.isInstance(a) ? a : new Hd({ url: r, cause: a });
    }
  }
  function bM(t) {
    try {
      const [e, r] = t.split(",");
      return { mediaType: e.split(";")[0].split(":")[1], base64Content: r };
    } catch {
      return { mediaType: void 0, base64Content: void 0 };
    }
  }
  var b_ = Fe([
    S(),
    Gi(Uint8Array),
    Gi(ArrayBuffer),
    O2(
      (t) => {
        var e, r;
        return (r = (e = globalThis.Buffer) == null ? void 0 : e.isBuffer(t)) !=
          null
          ? r
          : !1;
      },
      { message: "Must be a Buffer" }
    ),
  ]);
  function E_(t) {
    if (t instanceof Uint8Array) return { data: t, mediaType: void 0 };
    if (t instanceof ArrayBuffer)
      return { data: new Uint8Array(t), mediaType: void 0 };
    if (typeof t == "string")
      try {
        t = new URL(t);
      } catch {}
    if (t instanceof URL && t.protocol === "data:") {
      const { mediaType: e, base64Content: r } = bM(t.toString());
      if (e == null || r == null)
        throw new Se({
          name: "InvalidDataContentError",
          message: `Invalid data URL format in content ${t.toString()}`,
        });
      return { data: r, mediaType: e };
    }
    return { data: t, mediaType: void 0 };
  }
  function EM(t) {
    return typeof t == "string"
      ? t
      : t instanceof ArrayBuffer
      ? Rd(new Uint8Array(t))
      : Rd(t);
  }
  async function S_({
    prompt: t,
    supportedUrls: e,
    downloadImplementation: r = wM,
  }) {
    const a = await $M(t.messages, r, e);
    return [
      ...(t.system != null ? [{ role: "system", content: t.system }] : []),
      ...t.messages.map((n) => SM({ message: n, downloadedAssets: a })),
    ];
  }
  function SM({ message: t, downloadedAssets: e }) {
    const r = t.role;
    switch (r) {
      case "system":
        return {
          role: "system",
          content: t.content,
          providerOptions: t.providerOptions,
        };
      case "user":
        return typeof t.content == "string"
          ? {
              role: "user",
              content: [{ type: "text", text: t.content }],
              providerOptions: t.providerOptions,
            }
          : {
              role: "user",
              content: t.content
                .map((a) => PM(a, e))
                .filter((a) => a.type !== "text" || a.text !== ""),
              providerOptions: t.providerOptions,
            };
      case "assistant":
        return typeof t.content == "string"
          ? {
              role: "assistant",
              content: [{ type: "text", text: t.content }],
              providerOptions: t.providerOptions,
            }
          : {
              role: "assistant",
              content: t.content
                .filter((a) => a.type !== "text" || a.text !== "")
                .map((a) => {
                  const n = a.providerOptions;
                  switch (a.type) {
                    case "file": {
                      const { data: s, mediaType: o } = E_(a.data);
                      return {
                        type: "file",
                        data: s,
                        filename: a.filename,
                        mediaType: o ?? a.mediaType,
                        providerOptions: n,
                      };
                    }
                    case "reasoning":
                      return {
                        type: "reasoning",
                        text: a.text,
                        providerOptions: n,
                      };
                    case "text":
                      return { type: "text", text: a.text, providerOptions: n };
                    case "tool-call":
                      return {
                        type: "tool-call",
                        toolCallId: a.toolCallId,
                        toolName: a.toolName,
                        input: a.input,
                        providerExecuted: a.providerExecuted,
                        providerOptions: n,
                      };
                    case "tool-result":
                      return {
                        type: "tool-result",
                        toolCallId: a.toolCallId,
                        toolName: a.toolName,
                        output: a.output,
                        providerOptions: n,
                      };
                  }
                }),
              providerOptions: t.providerOptions,
            };
      case "tool":
        return {
          role: "tool",
          content: t.content.map((a) => ({
            type: "tool-result",
            toolCallId: a.toolCallId,
            toolName: a.toolName,
            output: a.output,
            providerOptions: a.providerOptions,
          })),
          providerOptions: t.providerOptions,
        };
      default: {
        const a = r;
        throw new fM({ role: a });
      }
    }
  }
  async function $M(t, e, r) {
    const a = t
        .filter((s) => s.role === "user")
        .map((s) => s.content)
        .filter((s) => Array.isArray(s))
        .flat()
        .filter((s) => s.type === "image" || s.type === "file")
        .map((s) => {
          var o;
          const i =
            (o = s.mediaType) != null
              ? o
              : s.type === "image"
              ? "image/*"
              : void 0;
          let l = s.type === "image" ? s.image : s.data;
          if (typeof l == "string")
            try {
              l = new URL(l);
            } catch {}
          return { mediaType: i, data: l };
        })
        .filter(
          (s) =>
            s.data instanceof URL &&
            s.mediaType != null &&
            !U2({
              url: s.data.toString(),
              mediaType: s.mediaType,
              supportedUrls: r,
            })
        )
        .map((s) => s.data),
      n = await Promise.all(
        a.map(async (s) => ({ url: s, data: await e({ url: s }) }))
      );
    return Object.fromEntries(
      n.map(({ url: s, data: o }) => [s.toString(), o])
    );
  }
  function PM(t, e) {
    var r;
    if (t.type === "text")
      return { type: "text", text: t.text, providerOptions: t.providerOptions };
    let a;
    const n = t.type;
    switch (n) {
      case "image":
        a = t.image;
        break;
      case "file":
        a = t.data;
        break;
      default:
        throw new Error(`Unsupported part type: ${n}`);
    }
    const { data: s, mediaType: o } = E_(a);
    let i = o ?? t.mediaType,
      l = s;
    if (l instanceof URL) {
      const c = e[l.toString()];
      c && ((l = c.data), i ?? (i = c.mediaType));
    }
    switch (n) {
      case "image":
        return (
          (l instanceof Uint8Array || typeof l == "string") &&
            (i = (r = _M({ data: l, signatures: vM })) != null ? r : i),
          {
            type: "file",
            mediaType: i ?? "image/*",
            filename: void 0,
            data: l,
            providerOptions: t.providerOptions,
          }
        );
      case "file": {
        if (i == null) throw new Error("Media type is missing for file part");
        return {
          type: "file",
          mediaType: i,
          filename: t.filename,
          data: l,
          providerOptions: t.providerOptions,
        };
      }
    }
  }
  function Bd({
    maxOutputTokens: t,
    temperature: e,
    topP: r,
    topK: a,
    presencePenalty: n,
    frequencyPenalty: s,
    seed: o,
    stopSequences: i,
  }) {
    if (t != null) {
      if (!Number.isInteger(t))
        throw new Hr({
          parameter: "maxOutputTokens",
          value: t,
          message: "maxOutputTokens must be an integer",
        });
      if (t < 1)
        throw new Hr({
          parameter: "maxOutputTokens",
          value: t,
          message: "maxOutputTokens must be >= 1",
        });
    }
    if (e != null && typeof e != "number")
      throw new Hr({
        parameter: "temperature",
        value: e,
        message: "temperature must be a number",
      });
    if (r != null && typeof r != "number")
      throw new Hr({
        parameter: "topP",
        value: r,
        message: "topP must be a number",
      });
    if (a != null && typeof a != "number")
      throw new Hr({
        parameter: "topK",
        value: a,
        message: "topK must be a number",
      });
    if (n != null && typeof n != "number")
      throw new Hr({
        parameter: "presencePenalty",
        value: n,
        message: "presencePenalty must be a number",
      });
    if (s != null && typeof s != "number")
      throw new Hr({
        parameter: "frequencyPenalty",
        value: s,
        message: "frequencyPenalty must be a number",
      });
    if (o != null && !Number.isInteger(o))
      throw new Hr({
        parameter: "seed",
        value: o,
        message: "seed must be an integer",
      });
    return {
      maxOutputTokens: t,
      temperature: e,
      topP: r,
      topK: a,
      presencePenalty: n,
      frequencyPenalty: s,
      stopSequences: i,
      seed: o,
    };
  }
  function TM(t) {
    return t != null && Object.keys(t).length > 0;
  }
  function $_({ tools: t, toolChoice: e, activeTools: r }) {
    return TM(t)
      ? {
          tools: (r != null
            ? Object.entries(t).filter(([n]) => r.includes(n))
            : Object.entries(t)
          ).map(([n, s]) => {
            const o = s.type;
            switch (o) {
              case void 0:
              case "dynamic":
              case "function":
                return {
                  type: "function",
                  name: n,
                  description: s.description,
                  inputSchema: Xi(s.inputSchema).jsonSchema,
                  providerOptions: s.providerOptions,
                };
              case "provider-defined":
                return {
                  type: "provider-defined",
                  name: n,
                  id: s.id,
                  args: s.args,
                };
              default: {
                const i = o;
                throw new Error(`Unsupported tool type: ${i}`);
              }
            }
          }),
          toolChoice:
            e == null
              ? { type: "auto" }
              : typeof e == "string"
              ? { type: e }
              : { type: "tool", toolName: e.toolName },
        }
      : { tools: void 0, toolChoice: void 0 };
  }
  var to = Hg(() => Fe([i2(), S(), K(), Ve(), Xt(S(), to), ce(to)])),
    vt = Xt(S(), Xt(S(), to)),
    P_ = O({ type: W("text"), text: S(), providerOptions: vt.optional() }),
    xM = O({
      type: W("image"),
      image: Fe([b_, Gi(URL)]),
      mediaType: S().optional(),
      providerOptions: vt.optional(),
    }),
    T_ = O({
      type: W("file"),
      data: Fe([b_, Gi(URL)]),
      filename: S().optional(),
      mediaType: S(),
      providerOptions: vt.optional(),
    }),
    IM = O({ type: W("reasoning"), text: S(), providerOptions: vt.optional() }),
    kM = O({
      type: W("tool-call"),
      toolCallId: S(),
      toolName: S(),
      input: Ft(),
      providerOptions: vt.optional(),
      providerExecuted: Ve().optional(),
    }),
    CM = qa("type", [
      O({ type: W("text"), value: S() }),
      O({ type: W("json"), value: to }),
      O({ type: W("error-text"), value: S() }),
      O({ type: W("error-json"), value: to }),
      O({
        type: W("content"),
        value: ce(
          Fe([
            O({ type: W("text"), text: S() }),
            O({ type: W("media"), data: S(), mediaType: S() }),
          ])
        ),
      }),
    ]),
    x_ = O({
      type: W("tool-result"),
      toolCallId: S(),
      toolName: S(),
      output: CM,
      providerOptions: vt.optional(),
    }),
    RM = O({ role: W("system"), content: S(), providerOptions: vt.optional() }),
    OM = O({
      role: W("user"),
      content: Fe([S(), ce(Fe([P_, xM, T_]))]),
      providerOptions: vt.optional(),
    }),
    AM = O({
      role: W("assistant"),
      content: Fe([S(), ce(Fe([P_, T_, IM, kM, x_]))]),
      providerOptions: vt.optional(),
    }),
    NM = O({
      role: W("tool"),
      content: ce(x_),
      providerOptions: vt.optional(),
    }),
    MM = Fe([RM, OM, AM, NM]);
  async function I_(t) {
    if (t.prompt == null && t.messages == null)
      throw new Zn({
        prompt: t,
        message: "prompt or messages must be defined",
      });
    if (t.prompt != null && t.messages != null)
      throw new Zn({
        prompt: t,
        message: "prompt and messages cannot be defined at the same time",
      });
    if (t.system != null && typeof t.system != "string")
      throw new Zn({ prompt: t, message: "system must be a string" });
    let e;
    if (t.prompt != null && typeof t.prompt == "string")
      e = [{ role: "user", content: t.prompt }];
    else if (t.prompt != null && Array.isArray(t.prompt)) e = t.prompt;
    else if (t.messages != null) e = t.messages;
    else
      throw new Zn({
        prompt: t,
        message: "prompt or messages must be defined",
      });
    if (e.length === 0)
      throw new Zn({ prompt: t, message: "messages must not be empty" });
    const r = await Bs({ value: e, schema: ce(MM) });
    if (!r.success)
      throw new Zn({
        prompt: t,
        message:
          "The messages must be a ModelMessage[]. If you have passed a UIMessage[], you can use convertToModelMessages to convert them.",
        cause: r.error,
      });
    return { messages: e, system: t.system };
  }
  function k_(t) {
    return el.isInstance(t) || gy.isInstance(t)
      ? new Se({
          name: "GatewayError",
          message:
            "Vercel AI Gateway access failed. If you want to use AI SDK providers directly, use the providers, e.g. @ai-sdk/openai, or register a different global default provider.",
          cause: t,
        })
      : t;
  }
  function Fa({ operationId: t, telemetry: e }) {
    return {
      "operation.name": `${t}${
        (e == null ? void 0 : e.functionId) != null ? ` ${e.functionId}` : ""
      }`,
      "resource.name": e == null ? void 0 : e.functionId,
      "ai.operationId": t,
      "ai.telemetry.functionId": e == null ? void 0 : e.functionId,
    };
  }
  function C_({ model: t, settings: e, telemetry: r, headers: a }) {
    var n;
    return {
      "ai.model.provider": t.provider,
      "ai.model.id": t.modelId,
      ...Object.entries(e).reduce(
        (s, [o, i]) => ((s[`ai.settings.${o}`] = i), s),
        {}
      ),
      ...Object.entries(
        (n = r == null ? void 0 : r.metadata) != null ? n : {}
      ).reduce((s, [o, i]) => ((s[`ai.telemetry.metadata.${o}`] = i), s), {}),
      ...Object.entries(a ?? {}).reduce(
        (s, [o, i]) => (i !== void 0 && (s[`ai.request.headers.${o}`] = i), s),
        {}
      ),
    };
  }
  var jM = {
      startSpan() {
        return ol;
      },
      startActiveSpan(t, e, r, a) {
        if (typeof e == "function") return e(ol);
        if (typeof r == "function") return r(ol);
        if (typeof a == "function") return a(ol);
      },
    },
    ol = {
      spanContext() {
        return DM;
      },
      setAttribute() {
        return this;
      },
      setAttributes() {
        return this;
      },
      addEvent() {
        return this;
      },
      addLink() {
        return this;
      },
      addLinks() {
        return this;
      },
      setStatus() {
        return this;
      },
      updateName() {
        return this;
      },
      end() {
        return this;
      },
      isRecording() {
        return !1;
      },
      recordException() {
        return this;
      },
    },
    DM = { traceId: "", spanId: "", traceFlags: 0 };
  function R_({ isEnabled: t = !1, tracer: e } = {}) {
    return t ? e || WN.getTracer("ai") : jM;
  }
  function Va({
    name: t,
    tracer: e,
    attributes: r,
    fn: a,
    endWhenDone: n = !0,
  }) {
    return e.startActiveSpan(t, { attributes: r }, async (s) => {
      try {
        const o = await a(s);
        return n && s.end(), o;
      } catch (o) {
        try {
          Jd(s, o);
        } finally {
          s.end();
        }
        throw o;
      }
    });
  }
  function Jd(t, e) {
    e instanceof Error
      ? (t.recordException({
          name: e.name,
          message: e.message,
          stack: e.stack,
        }),
        t.setStatus({ code: al.ERROR, message: e.message }))
      : t.setStatus({ code: al.ERROR });
  }
  function fr({ telemetry: t, attributes: e }) {
    return (t == null ? void 0 : t.isEnabled) !== !0
      ? {}
      : Object.entries(e).reduce((r, [a, n]) => {
          if (n == null) return r;
          if (
            typeof n == "object" &&
            "input" in n &&
            typeof n.input == "function"
          ) {
            if ((t == null ? void 0 : t.recordInputs) === !1) return r;
            const s = n.input();
            return s == null ? r : { ...r, [a]: s };
          }
          if (
            typeof n == "object" &&
            "output" in n &&
            typeof n.output == "function"
          ) {
            if ((t == null ? void 0 : t.recordOutputs) === !1) return r;
            const s = n.output();
            return s == null ? r : { ...r, [a]: s };
          }
          return { ...r, [a]: n };
        }, {});
  }
  function O_(t) {
    return JSON.stringify(
      t.map((e) => ({
        ...e,
        content:
          typeof e.content == "string"
            ? e.content
            : e.content.map((r) =>
                r.type === "file"
                  ? {
                      ...r,
                      data: r.data instanceof Uint8Array ? EM(r.data) : r.data,
                    }
                  : r
              ),
      }))
    );
  }
  function A_(t, e) {
    return {
      inputTokens: ro(t.inputTokens, e.inputTokens),
      outputTokens: ro(t.outputTokens, e.outputTokens),
      totalTokens: ro(t.totalTokens, e.totalTokens),
      reasoningTokens: ro(t.reasoningTokens, e.reasoningTokens),
      cachedInputTokens: ro(t.cachedInputTokens, e.cachedInputTokens),
    };
  }
  function ro(t, e) {
    return t == null && e == null ? void 0 : (t ?? 0) + (e ?? 0);
  }
  function Kd(t) {
    return t === void 0 ? [] : Array.isArray(t) ? t : [t];
  }
  function LM({ error: t, exponentialBackoffDelay: e }) {
    const r = t.responseHeaders;
    if (!r) return e;
    let a;
    const n = r["retry-after-ms"];
    if (n) {
      const o = parseFloat(n);
      Number.isNaN(o) || (a = o);
    }
    const s = r["retry-after"];
    if (s && a === void 0) {
      const o = parseFloat(s);
      Number.isNaN(o) ? (a = Date.parse(s) - Date.now()) : (a = o * 1e3);
    }
    return a != null && !Number.isNaN(a) && 0 <= a && (a < 60 * 1e3 || a < e)
      ? a
      : e;
  }
  var zM =
    ({
      maxRetries: t = 2,
      initialDelayInMs: e = 2e3,
      backoffFactor: r = 2,
      abortSignal: a,
    } = {}) =>
    async (n) =>
      N_(n, { maxRetries: t, delayInMs: e, backoffFactor: r, abortSignal: a });
  async function N_(
    t,
    { maxRetries: e, delayInMs: r, backoffFactor: a, abortSignal: n },
    s = []
  ) {
    try {
      return await t();
    } catch (o) {
      if (Jn(o) || e === 0) throw o;
      const i = Td(o),
        l = [...s, o],
        c = l.length;
      if (c > e)
        throw new w_({
          message: `Failed after ${c} attempts. Last error: ${i}`,
          reason: "maxRetriesExceeded",
          errors: l,
        });
      if (
        o instanceof Error &&
        Xe.isInstance(o) &&
        o.isRetryable === !0 &&
        c <= e
      )
        return (
          await j2(LM({ error: o, exponentialBackoffDelay: r }), {
            abortSignal: n,
          }),
          N_(
            t,
            {
              maxRetries: e,
              delayInMs: a * r,
              backoffFactor: a,
              abortSignal: n,
            },
            l
          )
        );
      throw c === 1
        ? o
        : new w_({
            message: `Failed after ${c} attempts with non-retryable error: '${i}'`,
            reason: "errorNotRetryable",
            errors: l,
          });
    }
  }
  function M_({ maxRetries: t, abortSignal: e }) {
    if (t != null) {
      if (!Number.isInteger(t))
        throw new Hr({
          parameter: "maxRetries",
          value: t,
          message: "maxRetries must be an integer",
        });
      if (t < 0)
        throw new Hr({
          parameter: "maxRetries",
          value: t,
          message: "maxRetries must be >= 0",
        });
    }
    const r = t ?? 2;
    return { maxRetries: r, retry: zM({ maxRetries: r, abortSignal: e }) };
  }
  function j_(t) {
    const e = t.filter((r) => r.type === "text");
    if (e.length !== 0) return e.map((r) => r.text).join("");
  }
  var D_ = class {
      constructor({ data: t, mediaType: e }) {
        const r = t instanceof Uint8Array;
        (this.base64Data = r ? void 0 : t),
          (this.uint8ArrayData = r ? t : void 0),
          (this.mediaType = e);
      }
      get base64() {
        return (
          this.base64Data == null &&
            (this.base64Data = Rd(this.uint8ArrayData)),
          this.base64Data
        );
      }
      get uint8Array() {
        return (
          this.uint8ArrayData == null &&
            (this.uint8ArrayData = Qg(this.base64Data)),
          this.uint8ArrayData
        );
      }
    },
    qM = class extends D_ {
      constructor(t) {
        super(t), (this.type = "file");
      }
    };
  async function L_({
    toolCall: t,
    tools: e,
    repairToolCall: r,
    system: a,
    messages: n,
  }) {
    try {
      if (e == null) throw new Zd({ toolName: t.toolName });
      try {
        return await z_({ toolCall: t, tools: e });
      } catch (s) {
        if (r == null || !(Zd.isInstance(s) || Gy.isInstance(s))) throw s;
        let o = null;
        try {
          o = await r({
            toolCall: t,
            tools: e,
            inputSchema: ({ toolName: i }) => {
              const { inputSchema: l } = e[i];
              return Xi(l).jsonSchema;
            },
            system: a,
            messages: n,
            error: s,
          });
        } catch (i) {
          throw new cM({ cause: i, originalError: s });
        }
        if (o == null) throw s;
        return await z_({ toolCall: o, tools: e });
      }
    } catch (s) {
      return {
        type: "tool-call",
        toolCallId: t.toolCallId,
        toolName: t.toolName,
        input: t.input,
        dynamic: !0,
        invalid: !0,
        error: s,
      };
    }
  }
  async function z_({ toolCall: t, tools: e }) {
    const r = t.toolName,
      a = e[r];
    if (a == null)
      throw new Zd({ toolName: t.toolName, availableTools: Object.keys(e) });
    const n = Xi(a.inputSchema),
      s =
        t.input.trim() === ""
          ? await Bs({ value: {}, schema: n })
          : await Ua({ text: t.input, schema: n });
    if (s.success === !1)
      throw new Gy({ toolName: r, toolInput: t.input, cause: s.error });
    return a.type === "dynamic"
      ? {
          type: "tool-call",
          toolCallId: t.toolCallId,
          toolName: t.toolName,
          input: s.value,
          providerExecuted: t.providerExecuted,
          providerMetadata: t.providerMetadata,
          dynamic: !0,
        }
      : {
          type: "tool-call",
          toolCallId: t.toolCallId,
          toolName: r,
          input: s.value,
          providerExecuted: t.providerExecuted,
          providerMetadata: t.providerMetadata,
        };
  }
  var q_ = class {
    constructor({
      content: t,
      finishReason: e,
      usage: r,
      warnings: a,
      request: n,
      response: s,
      providerMetadata: o,
    }) {
      (this.content = t),
        (this.finishReason = e),
        (this.usage = r),
        (this.warnings = a),
        (this.request = n),
        (this.response = s),
        (this.providerMetadata = o);
    }
    get text() {
      return this.content
        .filter((t) => t.type === "text")
        .map((t) => t.text)
        .join("");
    }
    get reasoning() {
      return this.content.filter((t) => t.type === "reasoning");
    }
    get reasoningText() {
      return this.reasoning.length === 0
        ? void 0
        : this.reasoning.map((t) => t.text).join("");
    }
    get files() {
      return this.content.filter((t) => t.type === "file").map((t) => t.file);
    }
    get sources() {
      return this.content.filter((t) => t.type === "source");
    }
    get toolCalls() {
      return this.content.filter((t) => t.type === "tool-call");
    }
    get staticToolCalls() {
      return this.toolCalls.filter((t) => t.dynamic === !1);
    }
    get dynamicToolCalls() {
      return this.toolCalls.filter((t) => t.dynamic === !0);
    }
    get toolResults() {
      return this.content.filter((t) => t.type === "tool-result");
    }
    get staticToolResults() {
      return this.toolResults.filter((t) => t.dynamic === !1);
    }
    get dynamicToolResults() {
      return this.toolResults.filter((t) => t.dynamic === !0);
    }
  };
  function Gd(t) {
    return ({ steps: e }) => e.length === t;
  }
  async function U_({ stopConditions: t, steps: e }) {
    return (await Promise.all(t.map((r) => r({ steps: e })))).some((r) => r);
  }
  function Wd({ output: t, tool: e, errorMode: r }) {
    return r === "text"
      ? { type: "error-text", value: La(t) }
      : r === "json"
      ? { type: "error-json", value: F_(t) }
      : e != null && e.toModelOutput
      ? e.toModelOutput(t)
      : typeof t == "string"
      ? { type: "text", value: t }
      : { type: "json", value: F_(t) };
  }
  function F_(t) {
    return t === void 0 ? null : t;
  }
  function Qd({ content: t, tools: e }) {
    const r = [],
      a = t
        .filter((s) => s.type !== "source")
        .filter(
          (s) =>
            (s.type !== "tool-result" || s.providerExecuted) &&
            (s.type !== "tool-error" || s.providerExecuted)
        )
        .filter((s) => s.type !== "text" || s.text.length > 0)
        .map((s) => {
          switch (s.type) {
            case "text":
              return {
                type: "text",
                text: s.text,
                providerOptions: s.providerMetadata,
              };
            case "reasoning":
              return {
                type: "reasoning",
                text: s.text,
                providerOptions: s.providerMetadata,
              };
            case "file":
              return {
                type: "file",
                data: s.file.base64,
                mediaType: s.file.mediaType,
                providerOptions: s.providerMetadata,
              };
            case "tool-call":
              return {
                type: "tool-call",
                toolCallId: s.toolCallId,
                toolName: s.toolName,
                input: s.input,
                providerExecuted: s.providerExecuted,
                providerOptions: s.providerMetadata,
              };
            case "tool-result":
              return {
                type: "tool-result",
                toolCallId: s.toolCallId,
                toolName: s.toolName,
                output: Wd({
                  tool: e == null ? void 0 : e[s.toolName],
                  output: s.output,
                  errorMode: "none",
                }),
                providerExecuted: !0,
                providerOptions: s.providerMetadata,
              };
            case "tool-error":
              return {
                type: "tool-result",
                toolCallId: s.toolCallId,
                toolName: s.toolName,
                output: Wd({
                  tool: e == null ? void 0 : e[s.toolName],
                  output: s.error,
                  errorMode: "json",
                }),
                providerOptions: s.providerMetadata,
              };
          }
        });
    a.length > 0 && r.push({ role: "assistant", content: a });
    const n = t
      .filter((s) => s.type === "tool-result" || s.type === "tool-error")
      .filter((s) => !s.providerExecuted)
      .map((s) => ({
        type: "tool-result",
        toolCallId: s.toolCallId,
        toolName: s.toolName,
        output: Wd({
          tool: e == null ? void 0 : e[s.toolName],
          output: s.type === "tool-result" ? s.output : s.error,
          errorMode: s.type === "tool-error" ? "text" : "none",
        }),
      }));
    return n.length > 0 && r.push({ role: "tool", content: n }), r;
  }
  var UM = Hs({ prefix: "aitxt", size: 24 });
  async function FM({
    model: t,
    tools: e,
    toolChoice: r,
    system: a,
    prompt: n,
    messages: s,
    maxRetries: o,
    abortSignal: i,
    headers: l,
    stopWhen: c = Gd(1),
    experimental_output: u,
    experimental_telemetry: f,
    providerOptions: v,
    experimental_activeTools: d,
    activeTools: p = d,
    experimental_prepareStep: g,
    prepareStep: m = g,
    experimental_repairToolCall: h,
    experimental_context: y,
    _internal: { generateId: _ = UM, currentDate: w = () => new Date() } = {},
    onStepFinish: E,
    ...P
  }) {
    const x = sl(t),
      A = Kd(c),
      { maxRetries: M, retry: H } = M_({ maxRetries: o, abortSignal: i }),
      V = Bd(P),
      J = C_({
        model: x,
        telemetry: f,
        headers: l,
        settings: { ...V, maxRetries: M },
      }),
      z = await I_({ system: a, prompt: n, messages: s }),
      Z = R_(f);
    try {
      return await Va({
        name: "ai.generateText",
        attributes: fr({
          telemetry: f,
          attributes: {
            ...Fa({ operationId: "ai.generateText", telemetry: f }),
            ...J,
            "ai.model.provider": x.provider,
            "ai.model.id": x.modelId,
            "ai.prompt": {
              input: () =>
                JSON.stringify({ system: a, prompt: n, messages: s }),
            },
          },
        }),
        tracer: Z,
        fn: async (te) => {
          var me, ge, N, se, D, k;
          const L = Bd(P);
          let R,
            b = [],
            T = [];
          const q = [],
            G = [];
          do {
            const fe = [...z.messages, ...q],
              le = await (m == null
                ? void 0
                : m({
                    model: x,
                    steps: G,
                    stepNumber: G.length,
                    messages: fe,
                  })),
              ve = await S_({
                prompt: {
                  system:
                    (me = le == null ? void 0 : le.system) != null
                      ? me
                      : z.system,
                  messages:
                    (ge = le == null ? void 0 : le.messages) != null ? ge : fe,
                },
                supportedUrls: await x.supportedUrls,
              }),
              Ae = sl((N = le == null ? void 0 : le.model) != null ? N : x),
              { toolChoice: Pe, tools: xe } = $_({
                tools: e,
                toolChoice:
                  (se = le == null ? void 0 : le.toolChoice) != null ? se : r,
                activeTools:
                  (D = le == null ? void 0 : le.activeTools) != null ? D : p,
              });
            R = await H(() => {
              var we;
              return Va({
                name: "ai.generateText.doGenerate",
                attributes: fr({
                  telemetry: f,
                  attributes: {
                    ...Fa({
                      operationId: "ai.generateText.doGenerate",
                      telemetry: f,
                    }),
                    ...J,
                    "ai.model.provider": Ae.provider,
                    "ai.model.id": Ae.modelId,
                    "ai.prompt.messages": { input: () => O_(ve) },
                    "ai.prompt.tools": {
                      input: () =>
                        xe == null
                          ? void 0
                          : xe.map((ht) => JSON.stringify(ht)),
                    },
                    "ai.prompt.toolChoice": {
                      input: () => (Pe != null ? JSON.stringify(Pe) : void 0),
                    },
                    "gen_ai.system": Ae.provider,
                    "gen_ai.request.model": Ae.modelId,
                    "gen_ai.request.frequency_penalty": P.frequencyPenalty,
                    "gen_ai.request.max_tokens": P.maxOutputTokens,
                    "gen_ai.request.presence_penalty": P.presencePenalty,
                    "gen_ai.request.stop_sequences": P.stopSequences,
                    "gen_ai.request.temperature":
                      (we = P.temperature) != null ? we : void 0,
                    "gen_ai.request.top_k": P.topK,
                    "gen_ai.request.top_p": P.topP,
                  },
                }),
                tracer: Z,
                fn: async (ht) => {
                  var Zt, Ge, We, tt, gt, Ht, Dt, Ir;
                  const Ze = await Ae.doGenerate({
                      ...L,
                      tools: xe,
                      toolChoice: Pe,
                      responseFormat: u == null ? void 0 : u.responseFormat,
                      prompt: ve,
                      providerOptions: v,
                      abortSignal: i,
                      headers: l,
                    }),
                    Lt = {
                      id:
                        (Ge = (Zt = Ze.response) == null ? void 0 : Zt.id) !=
                        null
                          ? Ge
                          : _(),
                      timestamp:
                        (tt =
                          (We = Ze.response) == null ? void 0 : We.timestamp) !=
                        null
                          ? tt
                          : w(),
                      modelId:
                        (Ht =
                          (gt = Ze.response) == null ? void 0 : gt.modelId) !=
                        null
                          ? Ht
                          : Ae.modelId,
                      headers: (Dt = Ze.response) == null ? void 0 : Dt.headers,
                      body: (Ir = Ze.response) == null ? void 0 : Ir.body,
                    };
                  return (
                    ht.setAttributes(
                      fr({
                        telemetry: f,
                        attributes: {
                          "ai.response.finishReason": Ze.finishReason,
                          "ai.response.text": { output: () => j_(Ze.content) },
                          "ai.response.toolCalls": {
                            output: () => {
                              const Tn = V_(Ze.content);
                              return Tn == null ? void 0 : JSON.stringify(Tn);
                            },
                          },
                          "ai.response.id": Lt.id,
                          "ai.response.model": Lt.modelId,
                          "ai.response.timestamp": Lt.timestamp.toISOString(),
                          "ai.response.providerMetadata": JSON.stringify(
                            Ze.providerMetadata
                          ),
                          "ai.usage.promptTokens": Ze.usage.inputTokens,
                          "ai.usage.completionTokens": Ze.usage.outputTokens,
                          "gen_ai.response.finish_reasons": [Ze.finishReason],
                          "gen_ai.response.id": Lt.id,
                          "gen_ai.response.model": Lt.modelId,
                          "gen_ai.usage.input_tokens": Ze.usage.inputTokens,
                          "gen_ai.usage.output_tokens": Ze.usage.outputTokens,
                        },
                      })
                    ),
                    { ...Ze, response: Lt }
                  );
                },
              });
            });
            const Te = await Promise.all(
              R.content
                .filter((we) => we.type === "tool-call")
                .map((we) =>
                  L_({
                    toolCall: we,
                    tools: e,
                    repairToolCall: h,
                    system: a,
                    messages: fe,
                  })
                )
            );
            for (const we of Te) {
              if (we.invalid) continue;
              const ht = e[we.toolName];
              (ht == null ? void 0 : ht.onInputAvailable) != null &&
                (await ht.onInputAvailable({
                  input: we.input,
                  toolCallId: we.toolCallId,
                  messages: fe,
                  abortSignal: i,
                  experimental_context: y,
                }));
            }
            const ze = Te.filter((we) => we.invalid && we.dynamic);
            T = [];
            for (const we of ze)
              T.push({
                type: "tool-error",
                toolCallId: we.toolCallId,
                toolName: we.toolName,
                input: we.input,
                error: Td(we.error),
                dynamic: !0,
              });
            (b = Te.filter((we) => !we.providerExecuted)),
              e != null &&
                T.push(
                  ...(await VM({
                    toolCalls: b.filter((we) => !we.invalid),
                    tools: e,
                    tracer: Z,
                    telemetry: f,
                    messages: fe,
                    abortSignal: i,
                    experimental_context: y,
                  }))
                );
            const ae = HM({
              content: R.content,
              toolCalls: Te,
              toolOutputs: T,
            });
            q.push(...Qd({ content: ae, tools: e }));
            const qe = new q_({
              content: ae,
              finishReason: R.finishReason,
              usage: R.usage,
              warnings: R.warnings,
              providerMetadata: R.providerMetadata,
              request: (k = R.request) != null ? k : {},
              response: { ...R.response, messages: structuredClone(q) },
            });
            G.push(qe), await (E == null ? void 0 : E(qe));
          } while (
            b.length > 0 &&
            T.length === b.length &&
            !(await U_({ stopConditions: A, steps: G }))
          );
          te.setAttributes(
            fr({
              telemetry: f,
              attributes: {
                "ai.response.finishReason": R.finishReason,
                "ai.response.text": { output: () => j_(R.content) },
                "ai.response.toolCalls": {
                  output: () => {
                    const fe = V_(R.content);
                    return fe == null ? void 0 : JSON.stringify(fe);
                  },
                },
                "ai.response.providerMetadata": JSON.stringify(
                  R.providerMetadata
                ),
                "ai.usage.promptTokens": R.usage.inputTokens,
                "ai.usage.completionTokens": R.usage.outputTokens,
              },
            })
          );
          const ee = G[G.length - 1];
          return new ZM({
            steps: G,
            resolvedOutput: await (u == null
              ? void 0
              : u.parseOutput(
                  { text: ee.text },
                  {
                    response: ee.response,
                    usage: ee.usage,
                    finishReason: ee.finishReason,
                  }
                )),
          });
        },
      });
    } catch (te) {
      throw k_(te);
    }
  }
  async function VM({
    toolCalls: t,
    tools: e,
    tracer: r,
    telemetry: a,
    messages: n,
    abortSignal: s,
    experimental_context: o,
  }) {
    return (
      await Promise.all(
        t.map(async ({ toolCallId: l, toolName: c, input: u }) => {
          const f = e[c];
          if ((f == null ? void 0 : f.execute) != null)
            return Va({
              name: "ai.toolCall",
              attributes: fr({
                telemetry: a,
                attributes: {
                  ...Fa({ operationId: "ai.toolCall", telemetry: a }),
                  "ai.toolCall.name": c,
                  "ai.toolCall.id": l,
                  "ai.toolCall.args": { output: () => JSON.stringify(u) },
                },
              }),
              tracer: r,
              fn: async (v) => {
                try {
                  const d = Yg({
                    execute: f.execute.bind(f),
                    input: u,
                    options: {
                      toolCallId: l,
                      messages: n,
                      abortSignal: s,
                      experimental_context: o,
                    },
                  });
                  let p;
                  for await (const g of d) g.type === "final" && (p = g.output);
                  try {
                    v.setAttributes(
                      fr({
                        telemetry: a,
                        attributes: {
                          "ai.toolCall.result": {
                            output: () => JSON.stringify(p),
                          },
                        },
                      })
                    );
                  } catch {}
                  return {
                    type: "tool-result",
                    toolCallId: l,
                    toolName: c,
                    input: u,
                    output: p,
                    dynamic: f.type === "dynamic",
                  };
                } catch (d) {
                  return (
                    Jd(v, d),
                    {
                      type: "tool-error",
                      toolCallId: l,
                      toolName: c,
                      input: u,
                      error: d,
                      dynamic: f.type === "dynamic",
                    }
                  );
                }
              },
            });
        })
      )
    ).filter((l) => l != null);
  }
  var ZM = class {
    constructor(t) {
      (this.steps = t.steps), (this.resolvedOutput = t.resolvedOutput);
    }
    get finalStep() {
      return this.steps[this.steps.length - 1];
    }
    get content() {
      return this.finalStep.content;
    }
    get text() {
      return this.finalStep.text;
    }
    get files() {
      return this.finalStep.files;
    }
    get reasoningText() {
      return this.finalStep.reasoningText;
    }
    get reasoning() {
      return this.finalStep.reasoning;
    }
    get toolCalls() {
      return this.finalStep.toolCalls;
    }
    get staticToolCalls() {
      return this.finalStep.staticToolCalls;
    }
    get dynamicToolCalls() {
      return this.finalStep.dynamicToolCalls;
    }
    get toolResults() {
      return this.finalStep.toolResults;
    }
    get staticToolResults() {
      return this.finalStep.staticToolResults;
    }
    get dynamicToolResults() {
      return this.finalStep.dynamicToolResults;
    }
    get sources() {
      return this.finalStep.sources;
    }
    get finishReason() {
      return this.finalStep.finishReason;
    }
    get warnings() {
      return this.finalStep.warnings;
    }
    get providerMetadata() {
      return this.finalStep.providerMetadata;
    }
    get response() {
      return this.finalStep.response;
    }
    get request() {
      return this.finalStep.request;
    }
    get usage() {
      return this.finalStep.usage;
    }
    get totalUsage() {
      return this.steps.reduce((t, e) => A_(t, e.usage), {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0,
        reasoningTokens: void 0,
        cachedInputTokens: void 0,
      });
    }
    get experimental_output() {
      if (this.resolvedOutput == null) throw new Fy();
      return this.resolvedOutput;
    }
  };
  function V_(t) {
    const e = t.filter((r) => r.type === "tool-call");
    if (e.length !== 0)
      return e.map((r) => ({
        toolCallId: r.toolCallId,
        toolName: r.toolName,
        input: r.input,
      }));
  }
  function HM({ content: t, toolCalls: e, toolOutputs: r }) {
    return [
      ...t.map((a) => {
        switch (a.type) {
          case "text":
          case "reasoning":
          case "source":
            return a;
          case "file":
            return { type: "file", file: new D_(a) };
          case "tool-call":
            return e.find((n) => n.toolCallId === a.toolCallId);
          case "tool-result": {
            const n = e.find((s) => s.toolCallId === a.toolCallId);
            if (n == null)
              throw new Error(`Tool call ${a.toolCallId} not found.`);
            return a.isError
              ? {
                  type: "tool-error",
                  toolCallId: a.toolCallId,
                  toolName: a.toolName,
                  input: n.input,
                  error: a.result,
                  providerExecuted: !0,
                  dynamic: n.dynamic,
                }
              : {
                  type: "tool-result",
                  toolCallId: a.toolCallId,
                  toolName: a.toolName,
                  input: n.input,
                  output: a.result,
                  providerExecuted: !0,
                  dynamic: n.dynamic,
                };
          }
        }
      }),
      ...r,
    ];
  }
  function il(t, e) {
    const r = new Headers(t ?? {});
    for (const [a, n] of Object.entries(e)) r.has(a) || r.set(a, n);
    return r;
  }
  function BM({ status: t, statusText: e, headers: r, textStream: a }) {
    return new Response(a.pipeThrough(new TextEncoderStream()), {
      status: t ?? 200,
      statusText: e,
      headers: il(r, { "content-type": "text/plain; charset=utf-8" }),
    });
  }
  function Z_({
    response: t,
    status: e,
    statusText: r,
    headers: a,
    stream: n,
  }) {
    t.writeHead(e ?? 200, r, a);
    const s = n.getReader();
    (async () => {
      try {
        for (;;) {
          const { done: i, value: l } = await s.read();
          if (i) break;
          t.write(l);
        }
      } catch (i) {
        throw i;
      } finally {
        t.end();
      }
    })();
  }
  function JM({
    response: t,
    status: e,
    statusText: r,
    headers: a,
    textStream: n,
  }) {
    Z_({
      response: t,
      status: e,
      statusText: r,
      headers: Object.fromEntries(
        il(a, { "content-type": "text/plain; charset=utf-8" }).entries()
      ),
      stream: n.pipeThrough(new TextEncoderStream()),
    });
  }
  var H_ = class extends TransformStream {
      constructor() {
        super({
          transform(t, e) {
            e.enqueue(`data: ${JSON.stringify(t)}

`);
          },
          flush(t) {
            t.enqueue(`data: [DONE]

`);
          },
        });
      }
    },
    B_ = {
      "content-type": "text/event-stream",
      "cache-control": "no-cache",
      connection: "keep-alive",
      "x-vercel-ai-ui-message-stream": "v1",
      "x-accel-buffering": "no",
    };
  function KM({
    status: t,
    statusText: e,
    headers: r,
    stream: a,
    consumeSseStream: n,
  }) {
    let s = a.pipeThrough(new H_());
    if (n) {
      const [o, i] = s.tee();
      (s = o), n({ stream: i });
    }
    return new Response(s.pipeThrough(new TextEncoderStream()), {
      status: t,
      statusText: e,
      headers: il(r, B_),
    });
  }
  function GM({ originalMessages: t, responseMessageId: e }) {
    if (t == null) return;
    const r = t[t.length - 1];
    return (r == null ? void 0 : r.role) === "assistant"
      ? r.id
      : typeof e == "function"
      ? e()
      : e;
  }
  Fe([
    it({ type: W("text-start"), id: S(), providerMetadata: vt.optional() }),
    it({
      type: W("text-delta"),
      id: S(),
      delta: S(),
      providerMetadata: vt.optional(),
    }),
    it({ type: W("text-end"), id: S(), providerMetadata: vt.optional() }),
    it({ type: W("error"), errorText: S() }),
    it({
      type: W("tool-input-start"),
      toolCallId: S(),
      toolName: S(),
      providerExecuted: Ve().optional(),
      dynamic: Ve().optional(),
    }),
    it({ type: W("tool-input-delta"), toolCallId: S(), inputTextDelta: S() }),
    it({
      type: W("tool-input-available"),
      toolCallId: S(),
      toolName: S(),
      input: Ft(),
      providerExecuted: Ve().optional(),
      providerMetadata: vt.optional(),
      dynamic: Ve().optional(),
    }),
    it({
      type: W("tool-input-error"),
      toolCallId: S(),
      toolName: S(),
      input: Ft(),
      providerExecuted: Ve().optional(),
      providerMetadata: vt.optional(),
      dynamic: Ve().optional(),
      errorText: S(),
    }),
    it({
      type: W("tool-output-available"),
      toolCallId: S(),
      output: Ft(),
      providerExecuted: Ve().optional(),
      dynamic: Ve().optional(),
      preliminary: Ve().optional(),
    }),
    it({
      type: W("tool-output-error"),
      toolCallId: S(),
      errorText: S(),
      providerExecuted: Ve().optional(),
      dynamic: Ve().optional(),
    }),
    it({ type: W("reasoning"), text: S(), providerMetadata: vt.optional() }),
    it({
      type: W("reasoning-start"),
      id: S(),
      providerMetadata: vt.optional(),
    }),
    it({
      type: W("reasoning-delta"),
      id: S(),
      delta: S(),
      providerMetadata: vt.optional(),
    }),
    it({ type: W("reasoning-end"), id: S(), providerMetadata: vt.optional() }),
    it({ type: W("reasoning-part-finish") }),
    it({
      type: W("source-url"),
      sourceId: S(),
      url: S(),
      title: S().optional(),
      providerMetadata: vt.optional(),
    }),
    it({
      type: W("source-document"),
      sourceId: S(),
      mediaType: S(),
      title: S(),
      filename: S().optional(),
      providerMetadata: vt.optional(),
    }),
    it({
      type: W("file"),
      url: S(),
      mediaType: S(),
      providerMetadata: vt.optional(),
    }),
    it({
      type: S().startsWith("data-"),
      id: S().optional(),
      data: Ft(),
      transient: Ve().optional(),
    }),
    it({ type: W("start-step") }),
    it({ type: W("finish-step") }),
    it({
      type: W("start"),
      messageId: S().optional(),
      messageMetadata: Ft().optional(),
    }),
    it({ type: W("finish"), messageMetadata: Ft().optional() }),
    it({ type: W("abort") }),
    it({ type: W("message-metadata"), messageMetadata: Ft() }),
  ]);
  function WM(t) {
    return t.type.startsWith("data-");
  }
  function J_(t, e) {
    if (t === void 0 && e === void 0) return;
    if (t === void 0) return e;
    if (e === void 0) return t;
    const r = { ...t };
    for (const a in e)
      if (Object.prototype.hasOwnProperty.call(e, a)) {
        const n = e[a];
        if (n === void 0) continue;
        const s = a in t ? t[a] : void 0,
          o =
            n !== null &&
            typeof n == "object" &&
            !Array.isArray(n) &&
            !(n instanceof Date) &&
            !(n instanceof RegExp),
          i =
            s != null &&
            typeof s == "object" &&
            !Array.isArray(s) &&
            !(s instanceof Date) &&
            !(s instanceof RegExp);
        o && i ? (r[a] = J_(s, n)) : (r[a] = n);
      }
    return r;
  }
  function QM(t) {
    const e = ["ROOT"];
    let r = -1,
      a = null;
    function n(l, c, u) {
      switch (l) {
        case '"': {
          (r = c), e.pop(), e.push(u), e.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          (r = c), (a = c), e.pop(), e.push(u), e.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          e.pop(), e.push(u), e.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          (r = c), e.pop(), e.push(u), e.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          (r = c), e.pop(), e.push(u), e.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          (r = c), e.pop(), e.push(u), e.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
    function s(l, c) {
      switch (l) {
        case ",": {
          e.pop(), e.push("INSIDE_OBJECT_AFTER_COMMA");
          break;
        }
        case "}": {
          (r = c), e.pop();
          break;
        }
      }
    }
    function o(l, c) {
      switch (l) {
        case ",": {
          e.pop(), e.push("INSIDE_ARRAY_AFTER_COMMA");
          break;
        }
        case "]": {
          (r = c), e.pop();
          break;
        }
      }
    }
    for (let l = 0; l < t.length; l++) {
      const c = t[l];
      switch (e[e.length - 1]) {
        case "ROOT":
          n(c, l, "FINISH");
          break;
        case "INSIDE_OBJECT_START": {
          switch (c) {
            case '"': {
              e.pop(), e.push("INSIDE_OBJECT_KEY");
              break;
            }
            case "}": {
              (r = l), e.pop();
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_AFTER_COMMA": {
          switch (c) {
            case '"': {
              e.pop(), e.push("INSIDE_OBJECT_KEY");
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_KEY": {
          switch (c) {
            case '"': {
              e.pop(), e.push("INSIDE_OBJECT_AFTER_KEY");
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_AFTER_KEY": {
          switch (c) {
            case ":": {
              e.pop(), e.push("INSIDE_OBJECT_BEFORE_VALUE");
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_BEFORE_VALUE": {
          n(c, l, "INSIDE_OBJECT_AFTER_VALUE");
          break;
        }
        case "INSIDE_OBJECT_AFTER_VALUE": {
          s(c, l);
          break;
        }
        case "INSIDE_STRING": {
          switch (c) {
            case '"': {
              e.pop(), (r = l);
              break;
            }
            case "\\": {
              e.push("INSIDE_STRING_ESCAPE");
              break;
            }
            default:
              r = l;
          }
          break;
        }
        case "INSIDE_ARRAY_START": {
          switch (c) {
            case "]": {
              (r = l), e.pop();
              break;
            }
            default: {
              (r = l), n(c, l, "INSIDE_ARRAY_AFTER_VALUE");
              break;
            }
          }
          break;
        }
        case "INSIDE_ARRAY_AFTER_VALUE": {
          switch (c) {
            case ",": {
              e.pop(), e.push("INSIDE_ARRAY_AFTER_COMMA");
              break;
            }
            case "]": {
              (r = l), e.pop();
              break;
            }
            default: {
              r = l;
              break;
            }
          }
          break;
        }
        case "INSIDE_ARRAY_AFTER_COMMA": {
          n(c, l, "INSIDE_ARRAY_AFTER_VALUE");
          break;
        }
        case "INSIDE_STRING_ESCAPE": {
          e.pop(), (r = l);
          break;
        }
        case "INSIDE_NUMBER": {
          switch (c) {
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9": {
              r = l;
              break;
            }
            case "e":
            case "E":
            case "-":
            case ".":
              break;
            case ",": {
              e.pop(),
                e[e.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && o(c, l),
                e[e.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && s(c, l);
              break;
            }
            case "}": {
              e.pop(),
                e[e.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && s(c, l);
              break;
            }
            case "]": {
              e.pop(),
                e[e.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && o(c, l);
              break;
            }
            default: {
              e.pop();
              break;
            }
          }
          break;
        }
        case "INSIDE_LITERAL": {
          const f = t.substring(a, l + 1);
          !"false".startsWith(f) &&
          !"true".startsWith(f) &&
          !"null".startsWith(f)
            ? (e.pop(),
              e[e.length - 1] === "INSIDE_OBJECT_AFTER_VALUE"
                ? s(c, l)
                : e[e.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && o(c, l))
            : (r = l);
          break;
        }
      }
    }
    let i = t.slice(0, r + 1);
    for (let l = e.length - 1; l >= 0; l--)
      switch (e[l]) {
        case "INSIDE_STRING": {
          i += '"';
          break;
        }
        case "INSIDE_OBJECT_KEY":
        case "INSIDE_OBJECT_AFTER_KEY":
        case "INSIDE_OBJECT_AFTER_COMMA":
        case "INSIDE_OBJECT_START":
        case "INSIDE_OBJECT_BEFORE_VALUE":
        case "INSIDE_OBJECT_AFTER_VALUE": {
          i += "}";
          break;
        }
        case "INSIDE_ARRAY_START":
        case "INSIDE_ARRAY_AFTER_COMMA":
        case "INSIDE_ARRAY_AFTER_VALUE": {
          i += "]";
          break;
        }
        case "INSIDE_LITERAL": {
          const u = t.substring(a, t.length);
          "true".startsWith(u)
            ? (i += "true".slice(u.length))
            : "false".startsWith(u)
            ? (i += "false".slice(u.length))
            : "null".startsWith(u) && (i += "null".slice(u.length));
        }
      }
    return i;
  }
  async function K_(t) {
    if (t === void 0) return { value: void 0, state: "undefined-input" };
    let e = await Ua({ text: t });
    return e.success
      ? { value: e.value, state: "successful-parse" }
      : ((e = await Ua({ text: QM(t) })),
        e.success
          ? { value: e.value, state: "repaired-parse" }
          : { value: void 0, state: "failed-parse" });
  }
  function Yd(t) {
    return t.type.startsWith("tool-");
  }
  function G_(t) {
    return t.type.split("-").slice(1).join("-");
  }
  function YM({ lastMessage: t, messageId: e }) {
    return {
      message:
        (t == null ? void 0 : t.role) === "assistant"
          ? t
          : { id: e, metadata: void 0, role: "assistant", parts: [] },
      activeTextParts: {},
      activeReasoningParts: {},
      partialToolCalls: {},
    };
  }
  function XM({
    stream: t,
    messageMetadataSchema: e,
    dataPartSchemas: r,
    runUpdateMessageJob: a,
    onError: n,
    onToolCall: s,
    onData: o,
  }) {
    return t.pipeThrough(
      new TransformStream({
        async transform(i, l) {
          await a(async ({ state: c, write: u }) => {
            var f, v, d, p;
            function g(w) {
              const P = c.message.parts
                .filter(Yd)
                .find((x) => x.toolCallId === w);
              if (P == null)
                throw new Error(
                  "tool-output-error must be preceded by a tool-input-available"
                );
              return P;
            }
            function m(w) {
              const P = c.message.parts
                .filter((x) => x.type === "dynamic-tool")
                .find((x) => x.toolCallId === w);
              if (P == null)
                throw new Error(
                  "tool-output-error must be preceded by a tool-input-available"
                );
              return P;
            }
            function h(w) {
              var E;
              const P = c.message.parts.find(
                  (M) => Yd(M) && M.toolCallId === w.toolCallId
                ),
                x = w,
                A = P;
              P != null
                ? ((P.state = w.state),
                  (A.input = x.input),
                  (A.output = x.output),
                  (A.errorText = x.errorText),
                  (A.rawInput = x.rawInput),
                  (A.preliminary = x.preliminary),
                  (A.providerExecuted =
                    (E = x.providerExecuted) != null ? E : P.providerExecuted),
                  x.providerMetadata != null &&
                    P.state === "input-available" &&
                    (P.callProviderMetadata = x.providerMetadata))
                : c.message.parts.push({
                    type: `tool-${w.toolName}`,
                    toolCallId: w.toolCallId,
                    state: w.state,
                    input: x.input,
                    output: x.output,
                    rawInput: x.rawInput,
                    errorText: x.errorText,
                    providerExecuted: x.providerExecuted,
                    preliminary: x.preliminary,
                    ...(x.providerMetadata != null
                      ? { callProviderMetadata: x.providerMetadata }
                      : {}),
                  });
            }
            function y(w) {
              var E;
              const P = c.message.parts.find(
                  (M) =>
                    M.type === "dynamic-tool" && M.toolCallId === w.toolCallId
                ),
                x = w,
                A = P;
              P != null
                ? ((P.state = w.state),
                  (A.toolName = w.toolName),
                  (A.input = x.input),
                  (A.output = x.output),
                  (A.errorText = x.errorText),
                  (A.rawInput = (E = x.rawInput) != null ? E : A.rawInput),
                  (A.preliminary = x.preliminary),
                  x.providerMetadata != null &&
                    P.state === "input-available" &&
                    (P.callProviderMetadata = x.providerMetadata))
                : c.message.parts.push({
                    type: "dynamic-tool",
                    toolName: w.toolName,
                    toolCallId: w.toolCallId,
                    state: w.state,
                    input: x.input,
                    output: x.output,
                    errorText: x.errorText,
                    preliminary: x.preliminary,
                    ...(x.providerMetadata != null
                      ? { callProviderMetadata: x.providerMetadata }
                      : {}),
                  });
            }
            async function _(w) {
              if (w != null) {
                const E =
                  c.message.metadata != null ? J_(c.message.metadata, w) : w;
                e != null && (await xd({ value: E, schema: e })),
                  (c.message.metadata = E);
              }
            }
            switch (i.type) {
              case "text-start": {
                const w = {
                  type: "text",
                  text: "",
                  providerMetadata: i.providerMetadata,
                  state: "streaming",
                };
                (c.activeTextParts[i.id] = w), c.message.parts.push(w), u();
                break;
              }
              case "text-delta": {
                const w = c.activeTextParts[i.id];
                (w.text += i.delta),
                  (w.providerMetadata =
                    (f = i.providerMetadata) != null ? f : w.providerMetadata),
                  u();
                break;
              }
              case "text-end": {
                const w = c.activeTextParts[i.id];
                (w.state = "done"),
                  (w.providerMetadata =
                    (v = i.providerMetadata) != null ? v : w.providerMetadata),
                  delete c.activeTextParts[i.id],
                  u();
                break;
              }
              case "reasoning-start": {
                const w = {
                  type: "reasoning",
                  text: "",
                  providerMetadata: i.providerMetadata,
                  state: "streaming",
                };
                (c.activeReasoningParts[i.id] = w),
                  c.message.parts.push(w),
                  u();
                break;
              }
              case "reasoning-delta": {
                const w = c.activeReasoningParts[i.id];
                (w.text += i.delta),
                  (w.providerMetadata =
                    (d = i.providerMetadata) != null ? d : w.providerMetadata),
                  u();
                break;
              }
              case "reasoning-end": {
                const w = c.activeReasoningParts[i.id];
                (w.providerMetadata =
                  (p = i.providerMetadata) != null ? p : w.providerMetadata),
                  (w.state = "done"),
                  delete c.activeReasoningParts[i.id],
                  u();
                break;
              }
              case "file": {
                c.message.parts.push({
                  type: "file",
                  mediaType: i.mediaType,
                  url: i.url,
                }),
                  u();
                break;
              }
              case "source-url": {
                c.message.parts.push({
                  type: "source-url",
                  sourceId: i.sourceId,
                  url: i.url,
                  title: i.title,
                  providerMetadata: i.providerMetadata,
                }),
                  u();
                break;
              }
              case "source-document": {
                c.message.parts.push({
                  type: "source-document",
                  sourceId: i.sourceId,
                  mediaType: i.mediaType,
                  title: i.title,
                  filename: i.filename,
                  providerMetadata: i.providerMetadata,
                }),
                  u();
                break;
              }
              case "tool-input-start": {
                const w = c.message.parts.filter(Yd);
                (c.partialToolCalls[i.toolCallId] = {
                  text: "",
                  toolName: i.toolName,
                  index: w.length,
                  dynamic: i.dynamic,
                }),
                  i.dynamic
                    ? y({
                        toolCallId: i.toolCallId,
                        toolName: i.toolName,
                        state: "input-streaming",
                        input: void 0,
                      })
                    : h({
                        toolCallId: i.toolCallId,
                        toolName: i.toolName,
                        state: "input-streaming",
                        input: void 0,
                        providerExecuted: i.providerExecuted,
                      }),
                  u();
                break;
              }
              case "tool-input-delta": {
                const w = c.partialToolCalls[i.toolCallId];
                w.text += i.inputTextDelta;
                const { value: E } = await K_(w.text);
                w.dynamic
                  ? y({
                      toolCallId: i.toolCallId,
                      toolName: w.toolName,
                      state: "input-streaming",
                      input: E,
                    })
                  : h({
                      toolCallId: i.toolCallId,
                      toolName: w.toolName,
                      state: "input-streaming",
                      input: E,
                    }),
                  u();
                break;
              }
              case "tool-input-available": {
                i.dynamic
                  ? y({
                      toolCallId: i.toolCallId,
                      toolName: i.toolName,
                      state: "input-available",
                      input: i.input,
                      providerMetadata: i.providerMetadata,
                    })
                  : h({
                      toolCallId: i.toolCallId,
                      toolName: i.toolName,
                      state: "input-available",
                      input: i.input,
                      providerExecuted: i.providerExecuted,
                      providerMetadata: i.providerMetadata,
                    }),
                  u(),
                  s && !i.providerExecuted && (await s({ toolCall: i }));
                break;
              }
              case "tool-input-error": {
                i.dynamic
                  ? y({
                      toolCallId: i.toolCallId,
                      toolName: i.toolName,
                      state: "output-error",
                      input: i.input,
                      errorText: i.errorText,
                      providerMetadata: i.providerMetadata,
                    })
                  : h({
                      toolCallId: i.toolCallId,
                      toolName: i.toolName,
                      state: "output-error",
                      input: void 0,
                      rawInput: i.input,
                      errorText: i.errorText,
                      providerExecuted: i.providerExecuted,
                      providerMetadata: i.providerMetadata,
                    }),
                  u();
                break;
              }
              case "tool-output-available": {
                if (i.dynamic) {
                  const w = m(i.toolCallId);
                  y({
                    toolCallId: i.toolCallId,
                    toolName: w.toolName,
                    state: "output-available",
                    input: w.input,
                    output: i.output,
                    preliminary: i.preliminary,
                  });
                } else {
                  const w = g(i.toolCallId);
                  h({
                    toolCallId: i.toolCallId,
                    toolName: G_(w),
                    state: "output-available",
                    input: w.input,
                    output: i.output,
                    providerExecuted: i.providerExecuted,
                    preliminary: i.preliminary,
                  });
                }
                u();
                break;
              }
              case "tool-output-error": {
                if (i.dynamic) {
                  const w = m(i.toolCallId);
                  y({
                    toolCallId: i.toolCallId,
                    toolName: w.toolName,
                    state: "output-error",
                    input: w.input,
                    errorText: i.errorText,
                  });
                } else {
                  const w = g(i.toolCallId);
                  h({
                    toolCallId: i.toolCallId,
                    toolName: G_(w),
                    state: "output-error",
                    input: w.input,
                    rawInput: w.rawInput,
                    errorText: i.errorText,
                  });
                }
                u();
                break;
              }
              case "start-step": {
                c.message.parts.push({ type: "step-start" });
                break;
              }
              case "finish-step": {
                (c.activeTextParts = {}), (c.activeReasoningParts = {});
                break;
              }
              case "start": {
                i.messageId != null && (c.message.id = i.messageId),
                  await _(i.messageMetadata),
                  (i.messageId != null || i.messageMetadata != null) && u();
                break;
              }
              case "finish": {
                await _(i.messageMetadata), i.messageMetadata != null && u();
                break;
              }
              case "message-metadata": {
                await _(i.messageMetadata), i.messageMetadata != null && u();
                break;
              }
              case "error": {
                n == null || n(new Error(i.errorText));
                break;
              }
              default:
                if (WM(i)) {
                  (r == null ? void 0 : r[i.type]) != null &&
                    (await xd({ value: i.data, schema: r[i.type] }));
                  const w = i;
                  if (w.transient) {
                    o == null || o(w);
                    break;
                  }
                  const E =
                    w.id != null
                      ? c.message.parts.find(
                          (P) => w.type === P.type && w.id === P.id
                        )
                      : void 0;
                  E != null ? (E.data = w.data) : c.message.parts.push(w),
                    o == null || o(w),
                    u();
                }
            }
            l.enqueue(i);
          });
        },
      })
    );
  }
  function e4({
    messageId: t,
    originalMessages: e = [],
    onFinish: r,
    onError: a,
    stream: n,
  }) {
    let s = e == null ? void 0 : e[e.length - 1];
    (s == null ? void 0 : s.role) !== "assistant" ? (s = void 0) : (t = s.id);
    let o = !1;
    const i = n.pipeThrough(
      new TransformStream({
        transform(u, f) {
          if (u.type === "start") {
            const v = u;
            v.messageId == null && t != null && (v.messageId = t);
          }
          u.type === "abort" && (o = !0), f.enqueue(u);
        },
      })
    );
    if (r == null) return i;
    const l = YM({
      lastMessage: s ? structuredClone(s) : void 0,
      messageId: t ?? "",
    });
    return XM({
      stream: i,
      runUpdateMessageJob: async (u) => {
        await u({ state: l, write: () => {} });
      },
      onError: a,
    }).pipeThrough(
      new TransformStream({
        transform(u, f) {
          f.enqueue(u);
        },
        async flush() {
          const u = l.message.id === (s == null ? void 0 : s.id);
          await r({
            isAborted: o,
            isContinuation: u,
            responseMessage: l.message,
            messages: [...(u ? e.slice(0, -1) : e), l.message],
          });
        },
      })
    );
  }
  function t4({
    response: t,
    status: e,
    statusText: r,
    headers: a,
    stream: n,
    consumeSseStream: s,
  }) {
    let o = n.pipeThrough(new H_());
    if (s) {
      const [i, l] = o.tee();
      (o = i), s({ stream: l });
    }
    Z_({
      response: t,
      status: e,
      statusText: r,
      headers: Object.fromEntries(il(a, B_).entries()),
      stream: o.pipeThrough(new TextEncoderStream()),
    });
  }
  function ll(t) {
    const e = t.pipeThrough(new TransformStream());
    return (
      (e[Symbol.asyncIterator] = () => {
        const r = e.getReader();
        return {
          async next() {
            const { done: a, value: n } = await r.read();
            return a ? { done: !0, value: void 0 } : { done: !1, value: n };
          },
        };
      }),
      e
    );
  }
  async function r4({ stream: t, onError: e }) {
    const r = t.getReader();
    try {
      for (;;) {
        const { done: a } = await r.read();
        if (a) break;
      }
    } catch (a) {
      e == null || e(a);
    } finally {
      r.releaseLock();
    }
  }
  function W_() {
    let t, e;
    return {
      promise: new Promise((a, n) => {
        (t = a), (e = n);
      }),
      resolve: t,
      reject: e,
    };
  }
  function n4() {
    let t = [],
      e = null,
      r = !1,
      a = W_();
    const n = () => {
        (r = !0),
          a.resolve(),
          t.forEach((o) => o.cancel()),
          (t = []),
          e == null || e.close();
      },
      s = async () => {
        if (r && t.length === 0) {
          e == null || e.close();
          return;
        }
        if (t.length === 0) return (a = W_()), await a.promise, s();
        try {
          const { value: o, done: i } = await t[0].read();
          i
            ? (t.shift(),
              t.length > 0 ? await s() : r && (e == null || e.close()))
            : e == null || e.enqueue(o);
        } catch (o) {
          e == null || e.error(o), t.shift(), n();
        }
      };
    return {
      stream: new ReadableStream({
        start(o) {
          e = o;
        },
        pull: s,
        async cancel() {
          for (const o of t) await o.cancel();
          (t = []), (r = !0);
        },
      }),
      addStream: (o) => {
        if (r)
          throw new Error("Cannot add inner stream: outer stream is closed");
        t.push(o.getReader()), a.resolve();
      },
      close: () => {
        (r = !0), a.resolve(), t.length === 0 && (e == null || e.close());
      },
      terminate: n,
    };
  }
  var cl = class {
    constructor() {
      (this.status = { type: "pending" }),
        (this._resolve = void 0),
        (this._reject = void 0);
    }
    get promise() {
      return this._promise
        ? this._promise
        : ((this._promise = new Promise((t, e) => {
            this.status.type === "resolved"
              ? t(this.status.value)
              : this.status.type === "rejected" && e(this.status.error),
              (this._resolve = t),
              (this._reject = e);
          })),
          this._promise);
    }
    resolve(t) {
      var e;
      (this.status = { type: "resolved", value: t }),
        this._promise && ((e = this._resolve) == null || e.call(this, t));
    }
    reject(t) {
      var e;
      (this.status = { type: "rejected", error: t }),
        this._promise && ((e = this._reject) == null || e.call(this, t));
    }
  };
  function a4(t, e) {
    return new ReadableStream({
      async start(r) {
        const a = t.getReader();
        try {
          for (;;) {
            const { done: n, value: s } = await a.read();
            if (n) {
              r.close();
              break;
            }
            r.enqueue(s);
          }
        } catch (n) {
          await e({ error: n, controller: r });
        }
      },
      cancel(r) {
        return t.cancel(r);
      },
    });
  }
  function s4() {
    var t, e;
    return (e =
      (t = globalThis == null ? void 0 : globalThis.performance) == null
        ? void 0
        : t.now()) != null
      ? e
      : Date.now();
  }
  function o4({
    tools: t,
    generatorStream: e,
    tracer: r,
    telemetry: a,
    system: n,
    messages: s,
    abortSignal: o,
    repairToolCall: i,
    experimental_context: l,
  }) {
    let c = null;
    const u = new ReadableStream({
        start(h) {
          c = h;
        },
      }),
      f = new Set(),
      v = new Map();
    let d = !1,
      p;
    function g() {
      d && f.size === 0 && (p != null && c.enqueue(p), c.close());
    }
    const m = new TransformStream({
      async transform(h, y) {
        const _ = h.type;
        switch (_) {
          case "stream-start":
          case "text-start":
          case "text-delta":
          case "text-end":
          case "reasoning-start":
          case "reasoning-delta":
          case "reasoning-end":
          case "tool-input-start":
          case "tool-input-delta":
          case "tool-input-end":
          case "source":
          case "response-metadata":
          case "error":
          case "raw": {
            y.enqueue(h);
            break;
          }
          case "file": {
            y.enqueue({
              type: "file",
              file: new qM({ data: h.data, mediaType: h.mediaType }),
            });
            break;
          }
          case "finish": {
            p = {
              type: "finish",
              finishReason: h.finishReason,
              usage: h.usage,
              providerMetadata: h.providerMetadata,
            };
            break;
          }
          case "tool-call": {
            try {
              const w = await L_({
                toolCall: h,
                tools: t,
                repairToolCall: i,
                system: n,
                messages: s,
              });
              if ((y.enqueue(w), w.invalid)) {
                c.enqueue({
                  type: "tool-error",
                  toolCallId: w.toolCallId,
                  toolName: w.toolName,
                  input: w.input,
                  error: Td(w.error),
                  dynamic: !0,
                });
                break;
              }
              const E = t[w.toolName];
              if (
                (v.set(w.toolCallId, w.input),
                E.onInputAvailable != null &&
                  (await E.onInputAvailable({
                    input: w.input,
                    toolCallId: w.toolCallId,
                    messages: s,
                    abortSignal: o,
                    experimental_context: l,
                  })),
                E.execute != null && w.providerExecuted !== !0)
              ) {
                const P = D2();
                f.add(P),
                  Va({
                    name: "ai.toolCall",
                    attributes: fr({
                      telemetry: a,
                      attributes: {
                        ...Fa({ operationId: "ai.toolCall", telemetry: a }),
                        "ai.toolCall.name": w.toolName,
                        "ai.toolCall.id": w.toolCallId,
                        "ai.toolCall.args": {
                          output: () => JSON.stringify(w.input),
                        },
                      },
                    }),
                    tracer: r,
                    fn: async (x) => {
                      let A;
                      try {
                        const M = Yg({
                          execute: E.execute.bind(E),
                          input: w.input,
                          options: {
                            toolCallId: w.toolCallId,
                            messages: s,
                            abortSignal: o,
                            experimental_context: l,
                          },
                        });
                        for await (const H of M)
                          c.enqueue({
                            ...w,
                            type: "tool-result",
                            output: H.output,
                            ...(H.type === "preliminary" && {
                              preliminary: !0,
                            }),
                          }),
                            H.type === "final" && (A = H.output);
                      } catch (M) {
                        Jd(x, M),
                          c.enqueue({ ...w, type: "tool-error", error: M }),
                          f.delete(P),
                          g();
                        return;
                      }
                      f.delete(P), g();
                      try {
                        x.setAttributes(
                          fr({
                            telemetry: a,
                            attributes: {
                              "ai.toolCall.result": {
                                output: () => JSON.stringify(A),
                              },
                            },
                          })
                        );
                      } catch {}
                    },
                  });
              }
            } catch (w) {
              c.enqueue({ type: "error", error: w });
            }
            break;
          }
          case "tool-result": {
            const w = h.toolName;
            h.isError
              ? c.enqueue({
                  type: "tool-error",
                  toolCallId: h.toolCallId,
                  toolName: w,
                  input: v.get(h.toolCallId),
                  providerExecuted: h.providerExecuted,
                  error: h.result,
                })
              : y.enqueue({
                  type: "tool-result",
                  toolCallId: h.toolCallId,
                  toolName: w,
                  input: v.get(h.toolCallId),
                  output: h.result,
                  providerExecuted: h.providerExecuted,
                });
            break;
          }
          default: {
            const w = _;
            throw new Error(`Unhandled chunk type: ${w}`);
          }
        }
      },
      flush() {
        (d = !0), g();
      },
    });
    return new ReadableStream({
      async start(h) {
        return Promise.all([
          e.pipeThrough(m).pipeTo(
            new WritableStream({
              write(y) {
                h.enqueue(y);
              },
              close() {},
            })
          ),
          u.pipeTo(
            new WritableStream({
              write(y) {
                h.enqueue(y);
              },
              close() {
                h.close();
              },
            })
          ),
        ]);
      },
    });
  }
  var i4 = Hs({ prefix: "aitxt", size: 24 });
  function l4({
    model: t,
    tools: e,
    toolChoice: r,
    system: a,
    prompt: n,
    messages: s,
    maxRetries: o,
    abortSignal: i,
    headers: l,
    stopWhen: c = Gd(1),
    experimental_output: u,
    experimental_telemetry: f,
    prepareStep: v,
    providerOptions: d,
    experimental_activeTools: p,
    activeTools: g = p,
    experimental_repairToolCall: m,
    experimental_transform: h,
    includeRawChunks: y = !1,
    onChunk: _,
    onError: w = ({ error: z }) => {
      console.error(z);
    },
    onFinish: E,
    onAbort: P,
    onStepFinish: x,
    experimental_context: A,
    _internal: {
      now: M = s4,
      generateId: H = i4,
      currentDate: V = () => new Date(),
    } = {},
    ...J
  }) {
    return new u4({
      model: sl(t),
      telemetry: f,
      headers: l,
      settings: J,
      maxRetries: o,
      abortSignal: i,
      system: a,
      prompt: n,
      messages: s,
      tools: e,
      toolChoice: r,
      transforms: Kd(h),
      activeTools: g,
      repairToolCall: m,
      stopConditions: Kd(c),
      output: u,
      providerOptions: d,
      prepareStep: v,
      includeRawChunks: y,
      onChunk: _,
      onError: w,
      onFinish: E,
      onAbort: P,
      onStepFinish: x,
      now: M,
      currentDate: V,
      generateId: H,
      experimental_context: A,
    });
  }
  function c4(t) {
    if (!t)
      return new TransformStream({
        transform(o, i) {
          i.enqueue({ part: o, partialOutput: void 0 });
        },
      });
    let e,
      r = "",
      a = "",
      n = "";
    function s({ controller: o, partialOutput: i = void 0 }) {
      o.enqueue({
        part: { type: "text-delta", id: e, text: a },
        partialOutput: i,
      }),
        (a = "");
    }
    return new TransformStream({
      async transform(o, i) {
        if (
          (o.type === "finish-step" && a.length > 0 && s({ controller: i }),
          o.type !== "text-delta" &&
            o.type !== "text-start" &&
            o.type !== "text-end")
        ) {
          i.enqueue({ part: o, partialOutput: void 0 });
          return;
        }
        if (e == null) e = o.id;
        else if (o.id !== e) {
          i.enqueue({ part: o, partialOutput: void 0 });
          return;
        }
        if (o.type === "text-start") {
          i.enqueue({ part: o, partialOutput: void 0 });
          return;
        }
        if (o.type === "text-end") {
          a.length > 0 && s({ controller: i }),
            i.enqueue({ part: o, partialOutput: void 0 });
          return;
        }
        (r += o.text), (a += o.text);
        const l = await t.parsePartial({ text: r });
        if (l != null) {
          const c = JSON.stringify(l.partial);
          c !== n && (s({ controller: i, partialOutput: l.partial }), (n = c));
        }
      },
    });
  }
  var u4 = class {
    constructor({
      model: t,
      telemetry: e,
      headers: r,
      settings: a,
      maxRetries: n,
      abortSignal: s,
      system: o,
      prompt: i,
      messages: l,
      tools: c,
      toolChoice: u,
      transforms: f,
      activeTools: v,
      repairToolCall: d,
      stopConditions: p,
      output: g,
      providerOptions: m,
      prepareStep: h,
      includeRawChunks: y,
      now: _,
      currentDate: w,
      generateId: E,
      onChunk: P,
      onError: x,
      onFinish: A,
      onAbort: M,
      onStepFinish: H,
      experimental_context: V,
    }) {
      (this._totalUsage = new cl()),
        (this._finishReason = new cl()),
        (this._steps = new cl()),
        (this.output = g),
        (this.includeRawChunks = y),
        (this.tools = c);
      let J,
        z = [];
      const Z = [];
      let te,
        me,
        ge = {},
        N = [];
      const se = [];
      let D,
        k = {},
        L = {};
      const R = new TransformStream({
          async transform(Ae, Pe) {
            var xe, Te, ze;
            Pe.enqueue(Ae);
            const { part: ae } = Ae;
            if (
              ((ae.type === "text-delta" ||
                ae.type === "reasoning-delta" ||
                ae.type === "source" ||
                ae.type === "tool-call" ||
                ae.type === "tool-result" ||
                ae.type === "tool-input-start" ||
                ae.type === "tool-input-delta" ||
                ae.type === "raw") &&
                (await (P == null ? void 0 : P({ chunk: ae }))),
              ae.type === "error" && (await x({ error: k_(ae.error) })),
              ae.type === "text-start" &&
                ((k[ae.id] = {
                  type: "text",
                  text: "",
                  providerMetadata: ae.providerMetadata,
                }),
                z.push(k[ae.id])),
              ae.type === "text-delta")
            ) {
              const qe = k[ae.id];
              if (qe == null) {
                Pe.enqueue({
                  part: {
                    type: "error",
                    error: `text part ${ae.id} not found`,
                  },
                  partialOutput: void 0,
                });
                return;
              }
              (qe.text += ae.text),
                (qe.providerMetadata =
                  (xe = ae.providerMetadata) != null
                    ? xe
                    : qe.providerMetadata);
            }
            if (
              (ae.type === "text-end" && delete k[ae.id],
              ae.type === "reasoning-start" &&
                ((L[ae.id] = {
                  type: "reasoning",
                  text: "",
                  providerMetadata: ae.providerMetadata,
                }),
                z.push(L[ae.id])),
              ae.type === "reasoning-delta")
            ) {
              const qe = L[ae.id];
              if (qe == null) {
                Pe.enqueue({
                  part: {
                    type: "error",
                    error: `reasoning part ${ae.id} not found`,
                  },
                  partialOutput: void 0,
                });
                return;
              }
              (qe.text += ae.text),
                (qe.providerMetadata =
                  (Te = ae.providerMetadata) != null
                    ? Te
                    : qe.providerMetadata);
            }
            if (ae.type === "reasoning-end") {
              const qe = L[ae.id];
              if (qe == null) {
                Pe.enqueue({
                  part: {
                    type: "error",
                    error: `reasoning part ${ae.id} not found`,
                  },
                  partialOutput: void 0,
                });
                return;
              }
              (qe.providerMetadata =
                (ze = ae.providerMetadata) != null ? ze : qe.providerMetadata),
                delete L[ae.id];
            }
            if (
              (ae.type === "file" && z.push({ type: "file", file: ae.file }),
              ae.type === "source" && z.push(ae),
              ae.type === "tool-call" && z.push(ae),
              ae.type === "tool-result" && !ae.preliminary && z.push(ae),
              ae.type === "tool-error" && z.push(ae),
              ae.type === "start-step" &&
                ((ge = ae.request), (N = ae.warnings)),
              ae.type === "finish-step")
            ) {
              const qe = Qd({ content: z, tools: c }),
                we = new q_({
                  content: z,
                  finishReason: ae.finishReason,
                  usage: ae.usage,
                  warnings: N,
                  request: ge,
                  response: { ...ae.response, messages: [...Z, ...qe] },
                  providerMetadata: ae.providerMetadata,
                });
              await (H == null ? void 0 : H(we)),
                se.push(we),
                (z = []),
                (L = {}),
                (k = {}),
                Z.push(...qe),
                J.resolve();
            }
            ae.type === "finish" &&
              ((me = ae.totalUsage), (te = ae.finishReason));
          },
          async flush(Ae) {
            try {
              if (se.length === 0) {
                const ze = new oM({
                  message: "No output generated. Check the stream for errors.",
                });
                ve._finishReason.reject(ze),
                  ve._totalUsage.reject(ze),
                  ve._steps.reject(ze);
                return;
              }
              const Pe = te ?? "unknown",
                xe = me ?? {
                  inputTokens: void 0,
                  outputTokens: void 0,
                  totalTokens: void 0,
                };
              ve._finishReason.resolve(Pe),
                ve._totalUsage.resolve(xe),
                ve._steps.resolve(se);
              const Te = se[se.length - 1];
              await (A == null
                ? void 0
                : A({
                    finishReason: Pe,
                    totalUsage: xe,
                    usage: Te.usage,
                    content: Te.content,
                    text: Te.text,
                    reasoningText: Te.reasoningText,
                    reasoning: Te.reasoning,
                    files: Te.files,
                    sources: Te.sources,
                    toolCalls: Te.toolCalls,
                    staticToolCalls: Te.staticToolCalls,
                    dynamicToolCalls: Te.dynamicToolCalls,
                    toolResults: Te.toolResults,
                    staticToolResults: Te.staticToolResults,
                    dynamicToolResults: Te.dynamicToolResults,
                    request: Te.request,
                    response: Te.response,
                    warnings: Te.warnings,
                    providerMetadata: Te.providerMetadata,
                    steps: se,
                  })),
                D.setAttributes(
                  fr({
                    telemetry: e,
                    attributes: {
                      "ai.response.finishReason": Pe,
                      "ai.response.text": { output: () => Te.text },
                      "ai.response.toolCalls": {
                        output: () => {
                          var ze;
                          return (ze = Te.toolCalls) != null && ze.length
                            ? JSON.stringify(Te.toolCalls)
                            : void 0;
                        },
                      },
                      "ai.response.providerMetadata": JSON.stringify(
                        Te.providerMetadata
                      ),
                      "ai.usage.inputTokens": xe.inputTokens,
                      "ai.usage.outputTokens": xe.outputTokens,
                      "ai.usage.totalTokens": xe.totalTokens,
                      "ai.usage.reasoningTokens": xe.reasoningTokens,
                      "ai.usage.cachedInputTokens": xe.cachedInputTokens,
                    },
                  })
                );
            } catch (Pe) {
              Ae.error(Pe);
            } finally {
              D.end();
            }
          },
        }),
        b = n4();
      (this.addStream = b.addStream), (this.closeStream = b.close);
      let T = b.stream;
      (T = a4(T, ({ error: Ae, controller: Pe }) => {
        Jn(Ae) && s != null && s.aborted
          ? (M == null || M({ steps: se }),
            Pe.enqueue({ type: "abort" }),
            Pe.close())
          : Pe.error(Ae);
      })),
        (T = T.pipeThrough(
          new TransformStream({
            start(Ae) {
              Ae.enqueue({ type: "start" });
            },
          })
        ));
      for (const Ae of f)
        T = T.pipeThrough(
          Ae({
            tools: c,
            stopStream() {
              b.terminate();
            },
          })
        );
      this.baseStream = T.pipeThrough(c4(g)).pipeThrough(R);
      const { maxRetries: q, retry: G } = M_({ maxRetries: n, abortSignal: s }),
        ee = R_(e),
        fe = Bd(a),
        le = C_({
          model: t,
          telemetry: e,
          headers: r,
          settings: { ...fe, maxRetries: q },
        }),
        ve = this;
      Va({
        name: "ai.streamText",
        attributes: fr({
          telemetry: e,
          attributes: {
            ...Fa({ operationId: "ai.streamText", telemetry: e }),
            ...le,
            "ai.prompt": {
              input: () =>
                JSON.stringify({ system: o, prompt: i, messages: l }),
            },
          },
        }),
        tracer: ee,
        endWhenDone: !1,
        fn: async (Ae) => {
          D = Ae;
          async function Pe({
            currentStep: xe,
            responseMessages: Te,
            usage: ze,
          }) {
            var ae, qe, we, ht, Zt;
            const Ge = ve.includeRawChunks;
            J = new cl();
            const We = await I_({ system: o, prompt: i, messages: l }),
              tt = [...We.messages, ...Te],
              gt = await (h == null
                ? void 0
                : h({
                    model: t,
                    steps: se,
                    stepNumber: se.length,
                    messages: tt,
                  })),
              Ht = await S_({
                prompt: {
                  system:
                    (ae = gt == null ? void 0 : gt.system) != null
                      ? ae
                      : We.system,
                  messages:
                    (qe = gt == null ? void 0 : gt.messages) != null ? qe : tt,
                },
                supportedUrls: await t.supportedUrls,
              }),
              Dt = sl((we = gt == null ? void 0 : gt.model) != null ? we : t),
              { toolChoice: Ir, tools: Ze } = $_({
                tools: c,
                toolChoice:
                  (ht = gt == null ? void 0 : gt.toolChoice) != null ? ht : u,
                activeTools:
                  (Zt = gt == null ? void 0 : gt.activeTools) != null ? Zt : v,
              }),
              {
                result: { stream: Lt, response: Tn, request: io },
                doStreamSpan: hr,
                startTimestampMs: lo,
              } = await G(() =>
                Va({
                  name: "ai.streamText.doStream",
                  attributes: fr({
                    telemetry: e,
                    attributes: {
                      ...Fa({
                        operationId: "ai.streamText.doStream",
                        telemetry: e,
                      }),
                      ...le,
                      "ai.model.provider": Dt.provider,
                      "ai.model.id": Dt.modelId,
                      "ai.prompt.messages": { input: () => O_(Ht) },
                      "ai.prompt.tools": {
                        input: () =>
                          Ze == null
                            ? void 0
                            : Ze.map((be) => JSON.stringify(be)),
                      },
                      "ai.prompt.toolChoice": {
                        input: () => (Ir != null ? JSON.stringify(Ir) : void 0),
                      },
                      "gen_ai.system": Dt.provider,
                      "gen_ai.request.model": Dt.modelId,
                      "gen_ai.request.frequency_penalty": fe.frequencyPenalty,
                      "gen_ai.request.max_tokens": fe.maxOutputTokens,
                      "gen_ai.request.presence_penalty": fe.presencePenalty,
                      "gen_ai.request.stop_sequences": fe.stopSequences,
                      "gen_ai.request.temperature": fe.temperature,
                      "gen_ai.request.top_k": fe.topK,
                      "gen_ai.request.top_p": fe.topP,
                    },
                  }),
                  tracer: ee,
                  endWhenDone: !1,
                  fn: async (be) => ({
                    startTimestampMs: _(),
                    doStreamSpan: be,
                    result: await Dt.doStream({
                      ...fe,
                      tools: Ze,
                      toolChoice: Ir,
                      responseFormat: g == null ? void 0 : g.responseFormat,
                      prompt: Ht,
                      providerOptions: m,
                      abortSignal: s,
                      headers: r,
                      includeRawChunks: Ge,
                    }),
                  }),
                })
              ),
              sf = o4({
                tools: c,
                generatorStream: Lt,
                tracer: ee,
                telemetry: e,
                system: o,
                messages: tt,
                repairToolCall: d,
                abortSignal: s,
                experimental_context: V,
              }),
              pl = io ?? {},
              Bt = [],
              co = [];
            let uo;
            const fo = {};
            let xn = "unknown",
              or = {
                inputTokens: void 0,
                outputTokens: void 0,
                totalTokens: void 0,
              },
              po,
              on = !0,
              mr = { id: E(), timestamp: w(), modelId: t.modelId },
              ho = "";
            ve.addStream(
              sf.pipeThrough(
                new TransformStream({
                  async transform(be, wt) {
                    var In, ea, ta, kr;
                    if (be.type === "stream-start") {
                      uo = be.warnings;
                      return;
                    }
                    if (on) {
                      const I = _() - lo;
                      (on = !1),
                        hr.addEvent("ai.stream.firstChunk", {
                          "ai.response.msToFirstChunk": I,
                        }),
                        hr.setAttributes({ "ai.response.msToFirstChunk": I }),
                        wt.enqueue({
                          type: "start-step",
                          request: pl,
                          warnings: uo ?? [],
                        });
                    }
                    const mo = be.type;
                    switch (mo) {
                      case "text-start":
                      case "text-end": {
                        wt.enqueue(be);
                        break;
                      }
                      case "text-delta": {
                        be.delta.length > 0 &&
                          (wt.enqueue({
                            type: "text-delta",
                            id: be.id,
                            text: be.delta,
                            providerMetadata: be.providerMetadata,
                          }),
                          (ho += be.delta));
                        break;
                      }
                      case "reasoning-start":
                      case "reasoning-end": {
                        wt.enqueue(be);
                        break;
                      }
                      case "reasoning-delta": {
                        wt.enqueue({
                          type: "reasoning-delta",
                          id: be.id,
                          text: be.delta,
                          providerMetadata: be.providerMetadata,
                        });
                        break;
                      }
                      case "tool-call": {
                        wt.enqueue(be), Bt.push(be);
                        break;
                      }
                      case "tool-result": {
                        wt.enqueue(be), be.preliminary || co.push(be);
                        break;
                      }
                      case "tool-error": {
                        wt.enqueue(be), co.push(be);
                        break;
                      }
                      case "response-metadata": {
                        mr = {
                          id: (In = be.id) != null ? In : mr.id,
                          timestamp:
                            (ea = be.timestamp) != null ? ea : mr.timestamp,
                          modelId: (ta = be.modelId) != null ? ta : mr.modelId,
                        };
                        break;
                      }
                      case "finish": {
                        (or = be.usage),
                          (xn = be.finishReason),
                          (po = be.providerMetadata);
                        const I = _() - lo;
                        hr.addEvent("ai.stream.finish"),
                          hr.setAttributes({
                            "ai.response.msToFinish": I,
                            "ai.response.avgOutputTokensPerSecond":
                              (1e3 *
                                ((kr = or.outputTokens) != null ? kr : 0)) /
                              I,
                          });
                        break;
                      }
                      case "file": {
                        wt.enqueue(be);
                        break;
                      }
                      case "source": {
                        wt.enqueue(be);
                        break;
                      }
                      case "tool-input-start": {
                        fo[be.id] = be.toolName;
                        const I = c == null ? void 0 : c[be.toolName];
                        (I == null ? void 0 : I.onInputStart) != null &&
                          (await I.onInputStart({
                            toolCallId: be.id,
                            messages: tt,
                            abortSignal: s,
                            experimental_context: V,
                          })),
                          wt.enqueue({
                            ...be,
                            dynamic:
                              (I == null ? void 0 : I.type) === "dynamic",
                          });
                        break;
                      }
                      case "tool-input-end": {
                        delete fo[be.id], wt.enqueue(be);
                        break;
                      }
                      case "tool-input-delta": {
                        const I = fo[be.id],
                          $ = c == null ? void 0 : c[I];
                        ($ == null ? void 0 : $.onInputDelta) != null &&
                          (await $.onInputDelta({
                            inputTextDelta: be.delta,
                            toolCallId: be.id,
                            messages: tt,
                            abortSignal: s,
                            experimental_context: V,
                          })),
                          wt.enqueue(be);
                        break;
                      }
                      case "error": {
                        wt.enqueue(be), (xn = "error");
                        break;
                      }
                      case "raw": {
                        Ge && wt.enqueue(be);
                        break;
                      }
                      default: {
                        const I = mo;
                        throw new Error(`Unknown chunk type: ${I}`);
                      }
                    }
                  },
                  async flush(be) {
                    const wt = Bt.length > 0 ? JSON.stringify(Bt) : void 0;
                    try {
                      hr.setAttributes(
                        fr({
                          telemetry: e,
                          attributes: {
                            "ai.response.finishReason": xn,
                            "ai.response.text": { output: () => ho },
                            "ai.response.toolCalls": { output: () => wt },
                            "ai.response.id": mr.id,
                            "ai.response.model": mr.modelId,
                            "ai.response.timestamp": mr.timestamp.toISOString(),
                            "ai.response.providerMetadata": JSON.stringify(po),
                            "ai.usage.inputTokens": or.inputTokens,
                            "ai.usage.outputTokens": or.outputTokens,
                            "ai.usage.totalTokens": or.totalTokens,
                            "ai.usage.reasoningTokens": or.reasoningTokens,
                            "ai.usage.cachedInputTokens": or.cachedInputTokens,
                            "gen_ai.response.finish_reasons": [xn],
                            "gen_ai.response.id": mr.id,
                            "gen_ai.response.model": mr.modelId,
                            "gen_ai.usage.input_tokens": or.inputTokens,
                            "gen_ai.usage.output_tokens": or.outputTokens,
                          },
                        })
                      );
                    } catch {
                    } finally {
                      hr.end();
                    }
                    be.enqueue({
                      type: "finish-step",
                      finishReason: xn,
                      usage: or,
                      providerMetadata: po,
                      response: {
                        ...mr,
                        headers: Tn == null ? void 0 : Tn.headers,
                      },
                    });
                    const In = A_(ze, or);
                    await J.promise;
                    const ea = Bt.filter((kr) => kr.providerExecuted !== !0),
                      ta = co.filter((kr) => kr.providerExecuted !== !0);
                    if (
                      ea.length > 0 &&
                      ta.length === ea.length &&
                      !(await U_({ stopConditions: p, steps: se }))
                    ) {
                      Te.push(
                        ...Qd({ content: se[se.length - 1].content, tools: c })
                      );
                      try {
                        await Pe({
                          currentStep: xe + 1,
                          responseMessages: Te,
                          usage: In,
                        });
                      } catch (kr) {
                        be.enqueue({ type: "error", error: kr }),
                          ve.closeStream();
                      }
                    } else
                      be.enqueue({
                        type: "finish",
                        finishReason: xn,
                        totalUsage: In,
                      }),
                        ve.closeStream();
                  },
                })
              )
            );
          }
          await Pe({
            currentStep: 0,
            responseMessages: [],
            usage: {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0,
            },
          });
        },
      }).catch((Ae) => {
        ve.addStream(
          new ReadableStream({
            start(Pe) {
              Pe.enqueue({ type: "error", error: Ae }), Pe.close();
            },
          })
        ),
          ve.closeStream();
      });
    }
    get steps() {
      return this.consumeStream(), this._steps.promise;
    }
    get finalStep() {
      return this.steps.then((t) => t[t.length - 1]);
    }
    get content() {
      return this.finalStep.then((t) => t.content);
    }
    get warnings() {
      return this.finalStep.then((t) => t.warnings);
    }
    get providerMetadata() {
      return this.finalStep.then((t) => t.providerMetadata);
    }
    get text() {
      return this.finalStep.then((t) => t.text);
    }
    get reasoningText() {
      return this.finalStep.then((t) => t.reasoningText);
    }
    get reasoning() {
      return this.finalStep.then((t) => t.reasoning);
    }
    get sources() {
      return this.finalStep.then((t) => t.sources);
    }
    get files() {
      return this.finalStep.then((t) => t.files);
    }
    get toolCalls() {
      return this.finalStep.then((t) => t.toolCalls);
    }
    get staticToolCalls() {
      return this.finalStep.then((t) => t.staticToolCalls);
    }
    get dynamicToolCalls() {
      return this.finalStep.then((t) => t.dynamicToolCalls);
    }
    get toolResults() {
      return this.finalStep.then((t) => t.toolResults);
    }
    get staticToolResults() {
      return this.finalStep.then((t) => t.staticToolResults);
    }
    get dynamicToolResults() {
      return this.finalStep.then((t) => t.dynamicToolResults);
    }
    get usage() {
      return this.finalStep.then((t) => t.usage);
    }
    get request() {
      return this.finalStep.then((t) => t.request);
    }
    get response() {
      return this.finalStep.then((t) => t.response);
    }
    get totalUsage() {
      return this.consumeStream(), this._totalUsage.promise;
    }
    get finishReason() {
      return this.consumeStream(), this._finishReason.promise;
    }
    teeStream() {
      const [t, e] = this.baseStream.tee();
      return (this.baseStream = e), t;
    }
    get textStream() {
      return ll(
        this.teeStream().pipeThrough(
          new TransformStream({
            transform({ part: t }, e) {
              t.type === "text-delta" && e.enqueue(t.text);
            },
          })
        )
      );
    }
    get fullStream() {
      return ll(
        this.teeStream().pipeThrough(
          new TransformStream({
            transform({ part: t }, e) {
              e.enqueue(t);
            },
          })
        )
      );
    }
    async consumeStream(t) {
      var e;
      try {
        await r4({
          stream: this.fullStream,
          onError: t == null ? void 0 : t.onError,
        });
      } catch (r) {
        (e = t == null ? void 0 : t.onError) == null || e.call(t, r);
      }
    }
    get experimental_partialOutputStream() {
      if (this.output == null) throw new Fy();
      return ll(
        this.teeStream().pipeThrough(
          new TransformStream({
            transform({ partialOutput: t }, e) {
              t != null && e.enqueue(t);
            },
          })
        )
      );
    }
    toUIMessageStream({
      originalMessages: t,
      generateMessageId: e,
      onFinish: r,
      messageMetadata: a,
      sendReasoning: n = !0,
      sendSources: s = !1,
      sendStart: o = !0,
      sendFinish: i = !0,
      onError: l = La,
    } = {}) {
      const c =
          e != null
            ? GM({ originalMessages: t, responseMessageId: e })
            : void 0,
        u = {},
        f = (d) => {
          var p, g;
          const m = u[d];
          return ((g = (p = this.tools) == null ? void 0 : p[m]) == null
            ? void 0
            : g.type) === "dynamic"
            ? !0
            : void 0;
        },
        v = this.fullStream.pipeThrough(
          new TransformStream({
            transform: async (d, p) => {
              const g = a == null ? void 0 : a({ part: d }),
                m = d.type;
              switch (m) {
                case "text-start": {
                  p.enqueue({
                    type: "text-start",
                    id: d.id,
                    ...(d.providerMetadata != null
                      ? { providerMetadata: d.providerMetadata }
                      : {}),
                  });
                  break;
                }
                case "text-delta": {
                  p.enqueue({
                    type: "text-delta",
                    id: d.id,
                    delta: d.text,
                    ...(d.providerMetadata != null
                      ? { providerMetadata: d.providerMetadata }
                      : {}),
                  });
                  break;
                }
                case "text-end": {
                  p.enqueue({
                    type: "text-end",
                    id: d.id,
                    ...(d.providerMetadata != null
                      ? { providerMetadata: d.providerMetadata }
                      : {}),
                  });
                  break;
                }
                case "reasoning-start": {
                  p.enqueue({
                    type: "reasoning-start",
                    id: d.id,
                    ...(d.providerMetadata != null
                      ? { providerMetadata: d.providerMetadata }
                      : {}),
                  });
                  break;
                }
                case "reasoning-delta": {
                  n &&
                    p.enqueue({
                      type: "reasoning-delta",
                      id: d.id,
                      delta: d.text,
                      ...(d.providerMetadata != null
                        ? { providerMetadata: d.providerMetadata }
                        : {}),
                    });
                  break;
                }
                case "reasoning-end": {
                  p.enqueue({
                    type: "reasoning-end",
                    id: d.id,
                    ...(d.providerMetadata != null
                      ? { providerMetadata: d.providerMetadata }
                      : {}),
                  });
                  break;
                }
                case "file": {
                  p.enqueue({
                    type: "file",
                    mediaType: d.file.mediaType,
                    url: `data:${d.file.mediaType};base64,${d.file.base64}`,
                  });
                  break;
                }
                case "source": {
                  s &&
                    d.sourceType === "url" &&
                    p.enqueue({
                      type: "source-url",
                      sourceId: d.id,
                      url: d.url,
                      title: d.title,
                      ...(d.providerMetadata != null
                        ? { providerMetadata: d.providerMetadata }
                        : {}),
                    }),
                    s &&
                      d.sourceType === "document" &&
                      p.enqueue({
                        type: "source-document",
                        sourceId: d.id,
                        mediaType: d.mediaType,
                        title: d.title,
                        filename: d.filename,
                        ...(d.providerMetadata != null
                          ? { providerMetadata: d.providerMetadata }
                          : {}),
                      });
                  break;
                }
                case "tool-input-start": {
                  u[d.id] = d.toolName;
                  const h = f(d.id);
                  p.enqueue({
                    type: "tool-input-start",
                    toolCallId: d.id,
                    toolName: d.toolName,
                    ...(d.providerExecuted != null
                      ? { providerExecuted: d.providerExecuted }
                      : {}),
                    ...(h != null ? { dynamic: h } : {}),
                  });
                  break;
                }
                case "tool-input-delta": {
                  p.enqueue({
                    type: "tool-input-delta",
                    toolCallId: d.id,
                    inputTextDelta: d.delta,
                  });
                  break;
                }
                case "tool-call": {
                  u[d.toolCallId] = d.toolName;
                  const h = f(d.toolCallId);
                  d.invalid
                    ? p.enqueue({
                        type: "tool-input-error",
                        toolCallId: d.toolCallId,
                        toolName: d.toolName,
                        input: d.input,
                        ...(d.providerExecuted != null
                          ? { providerExecuted: d.providerExecuted }
                          : {}),
                        ...(d.providerMetadata != null
                          ? { providerMetadata: d.providerMetadata }
                          : {}),
                        ...(h != null ? { dynamic: h } : {}),
                        errorText: l(d.error),
                      })
                    : p.enqueue({
                        type: "tool-input-available",
                        toolCallId: d.toolCallId,
                        toolName: d.toolName,
                        input: d.input,
                        ...(d.providerExecuted != null
                          ? { providerExecuted: d.providerExecuted }
                          : {}),
                        ...(d.providerMetadata != null
                          ? { providerMetadata: d.providerMetadata }
                          : {}),
                        ...(h != null ? { dynamic: h } : {}),
                      });
                  break;
                }
                case "tool-result": {
                  const h = f(d.toolCallId);
                  p.enqueue({
                    type: "tool-output-available",
                    toolCallId: d.toolCallId,
                    output: d.output,
                    ...(d.providerExecuted != null
                      ? { providerExecuted: d.providerExecuted }
                      : {}),
                    ...(d.preliminary != null
                      ? { preliminary: d.preliminary }
                      : {}),
                    ...(h != null ? { dynamic: h } : {}),
                  });
                  break;
                }
                case "tool-error": {
                  const h = f(d.toolCallId);
                  p.enqueue({
                    type: "tool-output-error",
                    toolCallId: d.toolCallId,
                    errorText: l(d.error),
                    ...(d.providerExecuted != null
                      ? { providerExecuted: d.providerExecuted }
                      : {}),
                    ...(h != null ? { dynamic: h } : {}),
                  });
                  break;
                }
                case "error": {
                  p.enqueue({ type: "error", errorText: l(d.error) });
                  break;
                }
                case "start-step": {
                  p.enqueue({ type: "start-step" });
                  break;
                }
                case "finish-step": {
                  p.enqueue({ type: "finish-step" });
                  break;
                }
                case "start": {
                  o &&
                    p.enqueue({
                      type: "start",
                      ...(g != null ? { messageMetadata: g } : {}),
                      ...(c != null ? { messageId: c } : {}),
                    });
                  break;
                }
                case "finish": {
                  i &&
                    p.enqueue({
                      type: "finish",
                      ...(g != null ? { messageMetadata: g } : {}),
                    });
                  break;
                }
                case "abort": {
                  p.enqueue(d);
                  break;
                }
                case "tool-input-end":
                  break;
                case "raw":
                  break;
                default: {
                  const h = m;
                  throw new Error(`Unknown chunk type: ${h}`);
                }
              }
              g != null &&
                m !== "start" &&
                m !== "finish" &&
                p.enqueue({ type: "message-metadata", messageMetadata: g });
            },
          })
        );
      return ll(
        e4({
          stream: v,
          messageId: c ?? (e == null ? void 0 : e()),
          originalMessages: t,
          onFinish: r,
          onError: l,
        })
      );
    }
    pipeUIMessageStreamToResponse(
      t,
      {
        originalMessages: e,
        generateMessageId: r,
        onFinish: a,
        messageMetadata: n,
        sendReasoning: s,
        sendSources: o,
        sendFinish: i,
        sendStart: l,
        onError: c,
        ...u
      } = {}
    ) {
      t4({
        response: t,
        stream: this.toUIMessageStream({
          originalMessages: e,
          generateMessageId: r,
          onFinish: a,
          messageMetadata: n,
          sendReasoning: s,
          sendSources: o,
          sendFinish: i,
          sendStart: l,
          onError: c,
        }),
        ...u,
      });
    }
    pipeTextStreamToResponse(t, e) {
      JM({ response: t, textStream: this.textStream, ...e });
    }
    toUIMessageStreamResponse({
      originalMessages: t,
      generateMessageId: e,
      onFinish: r,
      messageMetadata: a,
      sendReasoning: n,
      sendSources: s,
      sendFinish: o,
      sendStart: i,
      onError: l,
      ...c
    } = {}) {
      return KM({
        stream: this.toUIMessageStream({
          originalMessages: t,
          generateMessageId: e,
          onFinish: r,
          messageMetadata: a,
          sendReasoning: n,
          sendSources: s,
          sendFinish: o,
          sendStart: i,
          onError: l,
        }),
        ...c,
      });
    }
    toTextStreamResponse(t) {
      return BM({ textStream: this.textStream, ...t });
    }
  };
  Hs({ prefix: "aiobj", size: 24 }), Hs({ prefix: "aiobj", size: 24 });
  var d4 = {};
  YN(d4, { object: () => p4, text: () => f4 });
  var f4 = () => ({
      type: "text",
      responseFormat: { type: "text" },
      async parsePartial({ text: t }) {
        return { partial: t };
      },
      async parseOutput({ text: t }) {
        return t;
      },
    }),
    p4 = ({ schema: t }) => {
      const e = Xi(t);
      return {
        type: "object",
        responseFormat: { type: "json", schema: e.jsonSchema },
        async parsePartial({ text: r }) {
          const a = await K_(r);
          switch (a.state) {
            case "failed-parse":
            case "undefined-input":
              return;
            case "repaired-parse":
            case "successful-parse":
              return { partial: a.value };
            default: {
              const n = a.state;
              throw new Error(`Unsupported parse state: ${n}`);
            }
          }
        },
        async parseOutput({ text: r }, a) {
          const n = await Ua({ text: r });
          if (!n.success)
            throw new t_({
              message: "No object generated: could not parse the response.",
              cause: n.error,
              text: r,
              response: a.response,
              usage: a.usage,
              finishReason: a.finishReason,
            });
          const s = await Bs({ value: n.value, schema: e });
          if (!s.success)
            throw new t_({
              message: "No object generated: response did not match schema.",
              cause: s.error,
              text: r,
              response: a.response,
              usage: a.usage,
              finishReason: a.finishReason,
            });
          return s.value;
        },
      };
    },
    Q_ = "2025-06-18",
    h4 = [Q_, "2025-03-26", "2024-11-05"],
    m4 = za({ name: S(), version: S() }),
    Xd = za({ _meta: $t(O({}).loose()) }),
    no = Xd,
    v4 = O({ method: S(), params: $t(Xd) }),
    g4 = za({
      experimental: $t(O({}).loose()),
      logging: $t(O({}).loose()),
      prompts: $t(za({ listChanged: $t(Ve()) })),
      resources: $t(za({ subscribe: $t(Ve()), listChanged: $t(Ve()) })),
      tools: $t(za({ listChanged: $t(Ve()) })),
    }),
    y4 = no.extend({
      protocolVersion: S(),
      capabilities: g4,
      serverInfo: m4,
      instructions: $t(S()),
    }),
    _4 = no.extend({ nextCursor: $t(S()) }),
    w4 = O({
      name: S(),
      description: $t(S()),
      inputSchema: O({
        type: W("object"),
        properties: $t(O({}).loose()),
      }).loose(),
    }).loose(),
    b4 = _4.extend({ tools: ce(w4) }),
    E4 = O({ type: W("text"), text: S() }).loose(),
    S4 = O({ type: W("image"), data: Dg(), mimeType: S() }).loose(),
    Y_ = O({ uri: S(), mimeType: $t(S()) }).loose(),
    $4 = Y_.extend({ text: S() }),
    P4 = Y_.extend({ blob: Dg() }),
    T4 = O({ type: W("resource"), resource: Fe([$4, P4]) }).loose(),
    x4 = no
      .extend({
        content: ce(Fe([E4, S4, T4])),
        isError: Ve().default(!1).optional(),
      })
      .or(no.extend({ toolResult: Ft() })),
    ul = "2.0",
    I4 = O({ jsonrpc: W(ul), id: Fe([S(), K().int()]) })
      .merge(v4)
      .strict(),
    k4 = O({ jsonrpc: W(ul), id: Fe([S(), K().int()]), result: no }).strict(),
    C4 = O({
      jsonrpc: W(ul),
      id: Fe([S(), K().int()]),
      error: O({ code: K().int(), message: S(), data: $t(Ft()) }),
    }).strict(),
    R4 = O({ jsonrpc: W(ul) })
      .merge(O({ method: S(), params: $t(Xd) }))
      .strict(),
    O4 = Fe([I4, R4, k4, C4]),
    A4 = class {
      constructor({ url: t, headers: e }) {
        (this.connected = !1), (this.url = new URL(t)), (this.headers = e);
      }
      async start() {
        return new Promise((t, e) => {
          if (this.connected) return t();
          (this.abortController = new AbortController()),
            (async () => {
              var a, n, s;
              try {
                const o = new Headers(this.headers);
                o.set("Accept", "text/event-stream");
                const i = await fetch(this.url.href, {
                  headers: o,
                  signal:
                    (a = this.abortController) == null ? void 0 : a.signal,
                });
                if (!i.ok || !i.body) {
                  const f = new Ct({
                    message: `MCP SSE Transport Error: ${i.status} ${i.statusText}`,
                  });
                  return (n = this.onerror) == null || n.call(this, f), e(f);
                }
                const c = i.body
                    .pipeThrough(new TextDecoderStream())
                    .pipeThrough(new wi())
                    .getReader(),
                  u = async () => {
                    var f, v, d;
                    try {
                      for (;;) {
                        const { done: p, value: g } = await c.read();
                        if (p) {
                          if (this.connected)
                            throw (
                              ((this.connected = !1),
                              new Ct({
                                message:
                                  "MCP SSE Transport Error: Connection closed unexpectedly",
                              }))
                            );
                          return;
                        }
                        const { event: m, data: h } = g;
                        if (m === "endpoint") {
                          if (
                            ((this.endpoint = new URL(h, this.url)),
                            this.endpoint.origin !== this.url.origin)
                          )
                            throw new Ct({
                              message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`,
                            });
                          (this.connected = !0), t();
                        } else if (m === "message")
                          try {
                            const y = O4.parse(JSON.parse(h));
                            (f = this.onmessage) == null || f.call(this, y);
                          } catch (y) {
                            const _ = new Ct({
                              message:
                                "MCP SSE Transport Error: Failed to parse message",
                              cause: y,
                            });
                            (v = this.onerror) == null || v.call(this, _);
                          }
                      }
                    } catch (p) {
                      if (p instanceof Error && p.name === "AbortError") return;
                      (d = this.onerror) == null || d.call(this, p), e(p);
                    }
                  };
                (this.sseConnection = { close: () => c.cancel() }), u();
              } catch (o) {
                if (o instanceof Error && o.name === "AbortError") return;
                (s = this.onerror) == null || s.call(this, o), e(o);
              }
            })();
        });
      }
      async close() {
        var t, e, r;
        (this.connected = !1),
          (t = this.sseConnection) == null || t.close(),
          (e = this.abortController) == null || e.abort(),
          (r = this.onclose) == null || r.call(this);
      }
      async send(t) {
        var e, r, a;
        if (!this.endpoint || !this.connected)
          throw new Ct({ message: "MCP SSE Transport Error: Not connected" });
        try {
          const n = new Headers(this.headers);
          n.set("Content-Type", "application/json");
          const s = {
              method: "POST",
              headers: n,
              body: JSON.stringify(t),
              signal: (e = this.abortController) == null ? void 0 : e.signal,
            },
            o = await fetch(this.endpoint, s);
          if (!o.ok) {
            const i = await o.text().catch(() => null),
              l = new Ct({
                message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${o.status}): ${i}`,
              });
            (r = this.onerror) == null || r.call(this, l);
            return;
          }
        } catch (n) {
          (a = this.onerror) == null || a.call(this, n);
          return;
        }
      }
    };
  function N4(t) {
    if (t.type !== "sse")
      throw new Ct({
        message:
          "Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface.",
      });
    return new A4(t);
  }
  function M4(t) {
    return (
      "start" in t &&
      typeof t.start == "function" &&
      "send" in t &&
      typeof t.send == "function" &&
      "close" in t &&
      typeof t.close == "function"
    );
  }
  var j4 = "1.0.0";
  async function D4(t) {
    const e = new L4(t);
    return await e.init(), e;
  }
  var L4 = class {
    constructor({
      transport: t,
      name: e = "ai-sdk-mcp-client",
      onUncaughtError: r,
    }) {
      (this.requestMessageId = 0),
        (this.responseHandlers = new Map()),
        (this.serverCapabilities = {}),
        (this.isClosed = !0),
        (this.onUncaughtError = r),
        M4(t) ? (this.transport = t) : (this.transport = N4(t)),
        (this.transport.onclose = () => this.onClose()),
        (this.transport.onerror = (a) => this.onError(a)),
        (this.transport.onmessage = (a) => {
          if ("method" in a) {
            this.onError(new Ct({ message: "Unsupported message type" }));
            return;
          }
          this.onResponse(a);
        }),
        (this.clientInfo = { name: e, version: j4 });
    }
    async init() {
      try {
        await this.transport.start(), (this.isClosed = !1);
        const t = await this.request({
          request: {
            method: "initialize",
            params: {
              protocolVersion: Q_,
              capabilities: {},
              clientInfo: this.clientInfo,
            },
          },
          resultSchema: y4,
        });
        if (t === void 0)
          throw new Ct({ message: "Server sent invalid initialize result" });
        if (!h4.includes(t.protocolVersion))
          throw new Ct({
            message: `Server's protocol version is not supported: ${t.protocolVersion}`,
          });
        return (
          (this.serverCapabilities = t.capabilities),
          await this.notification({ method: "notifications/initialized" }),
          this
        );
      } catch (t) {
        throw (await this.close(), t);
      }
    }
    async close() {
      var t;
      this.isClosed ||
        (await ((t = this.transport) == null ? void 0 : t.close()),
        this.onClose());
    }
    assertCapability(t) {
      switch (t) {
        case "initialize":
          break;
        case "tools/list":
        case "tools/call":
          if (!this.serverCapabilities.tools)
            throw new Ct({ message: "Server does not support tools" });
          break;
        default:
          throw new Ct({ message: `Unsupported method: ${t}` });
      }
    }
    async request({ request: t, resultSchema: e, options: r }) {
      return new Promise((a, n) => {
        if (this.isClosed)
          return n(
            new Ct({
              message: "Attempted to send a request from a closed client",
            })
          );
        this.assertCapability(t.method);
        const s = r == null ? void 0 : r.signal;
        s == null || s.throwIfAborted();
        const o = this.requestMessageId++,
          i = { ...t, jsonrpc: "2.0", id: o },
          l = () => {
            this.responseHandlers.delete(o);
          };
        this.responseHandlers.set(o, (c) => {
          if (s != null && s.aborted)
            return n(
              new Ct({ message: "Request was aborted", cause: s.reason })
            );
          if (c instanceof Error) return n(c);
          try {
            const u = e.parse(c.result);
            a(u);
          } catch (u) {
            const f = new Ct({
              message: "Failed to parse server response",
              cause: u,
            });
            n(f);
          }
        }),
          this.transport.send(i).catch((c) => {
            l(), n(c);
          });
      });
    }
    async listTools({ params: t, options: e } = {}) {
      try {
        return this.request({
          request: { method: "tools/list", params: t },
          resultSchema: b4,
          options: e,
        });
      } catch (r) {
        throw r;
      }
    }
    async callTool({ name: t, args: e, options: r }) {
      try {
        return this.request({
          request: { method: "tools/call", params: { name: t, arguments: e } },
          resultSchema: x4,
          options: { signal: r == null ? void 0 : r.abortSignal },
        });
      } catch (a) {
        throw a;
      }
    }
    async notification(t) {
      const e = { ...t, jsonrpc: "2.0" };
      await this.transport.send(e);
    }
    async tools({ schemas: t = "automatic" } = {}) {
      var e;
      const r = {};
      try {
        const a = await this.listTools();
        for (const { name: n, description: s, inputSchema: o } of a.tools) {
          if (t !== "automatic" && !(n in t)) continue;
          const i = this,
            l = async (u, f) => {
              var v;
              return (
                (v = f == null ? void 0 : f.abortSignal) == null ||
                  v.throwIfAborted(),
                i.callTool({ name: n, args: u, options: f })
              );
            },
            c =
              t === "automatic"
                ? Wg({
                    description: s,
                    inputSchema: Js({
                      ...o,
                      properties: (e = o.properties) != null ? e : {},
                      additionalProperties: !1,
                    }),
                    execute: l,
                  })
                : { description: s, inputSchema: t[n].inputSchema, execute: l };
          r[n] = c;
        }
        return r;
      } catch (a) {
        throw a;
      }
    }
    onClose() {
      if (this.isClosed) return;
      this.isClosed = !0;
      const t = new Ct({ message: "Connection closed" });
      for (const e of this.responseHandlers.values()) e(t);
      this.responseHandlers.clear();
    }
    onError(t) {
      this.onUncaughtError && this.onUncaughtError(t);
    }
    onResponse(t) {
      const e = Number(t.id),
        r = this.responseHandlers.get(e);
      if (r === void 0)
        throw new Ct({
          message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(
            t
          )}`,
        });
      this.responseHandlers.delete(e),
        r(
          "result" in t
            ? t
            : new Ct({ message: t.error.message, cause: t.error })
        );
    }
  };
  function pr(...t) {
    return t.reduce((e, r) => ({ ...e, ...(r ?? {}) }), {});
  }
  function ao(t) {
    return Object.fromEntries([...t.headers]);
  }
  var z4 = ({
      prefix: t,
      size: e = 16,
      alphabet:
        r = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      separator: a = "-",
    } = {}) => {
      const n = () => {
        const s = r.length,
          o = new Array(e);
        for (let i = 0; i < e; i++) o[i] = r[(Math.random() * s) | 0];
        return o.join("");
      };
      if (t == null) return n;
      if (r.includes(a))
        throw new dd({
          argument: "separator",
          message: `The separator "${a}" must not be part of the alphabet "${r}".`,
        });
      return () => `${t}${a}${n()}`;
    },
    sr = z4();
  function ef(t) {
    return (
      (t instanceof Error || t instanceof DOMException) &&
      (t.name === "AbortError" ||
        t.name === "ResponseAborted" ||
        t.name === "TimeoutError")
    );
  }
  var q4 = ["fetch failed", "failed to fetch"];
  function U4({ error: t, url: e, requestBodyValues: r }) {
    if (ef(t)) return t;
    if (t instanceof TypeError && q4.includes(t.message.toLowerCase())) {
      const a = t.cause;
      if (a != null)
        return new Xe({
          message: `Cannot connect to API: ${a.message}`,
          cause: a,
          url: e,
          requestBodyValues: r,
          isRetryable: !0,
        });
    }
    return t;
  }
  function F4(t) {
    return Object.fromEntries(Object.entries(t).filter(([e, r]) => r != null));
  }
  function X_({
    apiKey: t,
    environmentVariableName: e,
    apiKeyParameterName: r = "apiKey",
    description: a,
  }) {
    if (typeof t == "string") return t;
    if (t != null) throw new qi({ message: `${a} API key must be a string.` });
    if (typeof process > "u")
      throw new qi({
        message: `${a} API key is missing. Pass it using the '${r}' parameter. Environment variables is not supported in this environment.`,
      });
    if (((t = process.env[e]), t == null))
      throw new qi({
        message: `${a} API key is missing. Pass it using the '${r}' parameter or the ${e} environment variable.`,
      });
    if (typeof t != "string")
      throw new qi({
        message: `${a} API key must be a string. The value of the ${e} environment variable is not a string.`,
      });
    return t;
  }
  var V4 = /"__proto__"\s*:/,
    Z4 = /"constructor"\s*:/;
  function H4(t) {
    const e = JSON.parse(t);
    return e === null ||
      typeof e != "object" ||
      (V4.test(t) === !1 && Z4.test(t) === !1)
      ? e
      : B4(e);
  }
  function B4(t) {
    let e = [t];
    for (; e.length; ) {
      const r = e;
      e = [];
      for (const a of r) {
        if (Object.prototype.hasOwnProperty.call(a, "__proto__"))
          throw new SyntaxError("Object contains forbidden prototype property");
        if (
          Object.prototype.hasOwnProperty.call(a, "constructor") &&
          Object.prototype.hasOwnProperty.call(a.constructor, "prototype")
        )
          throw new SyntaxError("Object contains forbidden prototype property");
        for (const n in a) {
          const s = a[n];
          s && typeof s == "object" && e.push(s);
        }
      }
    }
    return t;
  }
  function tf(t) {
    const { stackTraceLimit: e } = Error;
    Error.stackTraceLimit = 0;
    try {
      return H4(t);
    } finally {
      Error.stackTraceLimit = e;
    }
  }
  var rf = Symbol.for("vercel.ai.validator");
  function J4(t) {
    return { [rf]: !0, validate: t };
  }
  function K4(t) {
    return (
      typeof t == "object" &&
      t !== null &&
      rf in t &&
      t[rf] === !0 &&
      "validate" in t
    );
  }
  function G4(t) {
    return K4(t) ? t : W4(t);
  }
  function W4(t) {
    return J4(async (e) => {
      const r = await t["~standard"].validate(e);
      return r.issues == null
        ? { success: !0, value: r.value }
        : { success: !1, error: new Vr({ value: e, cause: r.issues }) };
    });
  }
  async function Q4({ value: t, schema: e }) {
    const r = await so({ value: t, schema: e });
    if (!r.success) throw Vr.wrap({ value: t, cause: r.error });
    return r.value;
  }
  async function so({ value: t, schema: e }) {
    const r = G4(e);
    try {
      if (r.validate == null) return { success: !0, value: t, rawValue: t };
      const a = await r.validate(t);
      return a.success
        ? { success: !0, value: a.value, rawValue: t }
        : {
            success: !1,
            error: Vr.wrap({ value: t, cause: a.error }),
            rawValue: t,
          };
    } catch (a) {
      return {
        success: !1,
        error: Vr.wrap({ value: t, cause: a }),
        rawValue: t,
      };
    }
  }
  async function Y4({ text: t, schema: e }) {
    try {
      const r = tf(t);
      return e == null ? r : Q4({ value: r, schema: e });
    } catch (r) {
      throw Sn.isInstance(r) || Vr.isInstance(r)
        ? r
        : new Sn({ text: t, cause: r });
    }
  }
  async function e0({ text: t, schema: e }) {
    try {
      const r = tf(t);
      return e == null
        ? { success: !0, value: r, rawValue: r }
        : await so({ value: r, schema: e });
    } catch (r) {
      return {
        success: !1,
        error: Sn.isInstance(r) ? r : new Sn({ text: t, cause: r }),
        rawValue: void 0,
      };
    }
  }
  function dl(t) {
    try {
      return tf(t), !0;
    } catch {
      return !1;
    }
  }
  function X4({ stream: t, schema: e }) {
    return t
      .pipeThrough(new TextDecoderStream())
      .pipeThrough(new wi())
      .pipeThrough(
        new TransformStream({
          async transform({ data: r }, a) {
            r !== "[DONE]" && a.enqueue(await e0({ text: r, schema: e }));
          },
        })
      );
  }
  async function Br({ provider: t, providerOptions: e, schema: r }) {
    if ((e == null ? void 0 : e[t]) == null) return;
    const a = await so({ value: e[t], schema: r });
    if (!a.success)
      throw new dd({
        argument: "providerOptions",
        message: `invalid ${t} provider options`,
        cause: a.error,
      });
    return a.value;
  }
  var ej = () => globalThis.fetch,
    xr = async ({
      url: t,
      headers: e,
      body: r,
      failedResponseHandler: a,
      successfulResponseHandler: n,
      abortSignal: s,
      fetch: o,
    }) =>
      t0({
        url: t,
        headers: { "Content-Type": "application/json", ...e },
        body: { content: JSON.stringify(r), values: r },
        failedResponseHandler: a,
        successfulResponseHandler: n,
        abortSignal: s,
        fetch: o,
      }),
    tj = async ({
      url: t,
      headers: e,
      formData: r,
      failedResponseHandler: a,
      successfulResponseHandler: n,
      abortSignal: s,
      fetch: o,
    }) =>
      t0({
        url: t,
        headers: e,
        body: { content: r, values: Object.fromEntries(r.entries()) },
        failedResponseHandler: a,
        successfulResponseHandler: n,
        abortSignal: s,
        fetch: o,
      }),
    t0 = async ({
      url: t,
      headers: e = {},
      body: r,
      successfulResponseHandler: a,
      failedResponseHandler: n,
      abortSignal: s,
      fetch: o = ej(),
    }) => {
      try {
        const i = await o(t, {
            method: "POST",
            headers: F4(e),
            body: r.content,
            signal: s,
          }),
          l = ao(i);
        if (!i.ok) {
          let c;
          try {
            c = await n({ response: i, url: t, requestBodyValues: r.values });
          } catch (u) {
            throw ef(u) || Xe.isInstance(u)
              ? u
              : new Xe({
                  message: "Failed to process error response",
                  cause: u,
                  statusCode: i.status,
                  url: t,
                  responseHeaders: l,
                  requestBodyValues: r.values,
                });
          }
          throw c.value;
        }
        try {
          return await a({ response: i, url: t, requestBodyValues: r.values });
        } catch (c) {
          throw c instanceof Error && (ef(c) || Xe.isInstance(c))
            ? c
            : new Xe({
                message: "Failed to process successful response",
                cause: c,
                statusCode: i.status,
                url: t,
                responseHeaders: l,
                requestBodyValues: r.values,
              });
        }
      } catch (i) {
        throw U4({ error: i, url: t, requestBodyValues: r.values });
      }
    };
  function I9(t) {
    return t;
  }
  function nf({ id: t, name: e, inputSchema: r }) {
    return ({
      execute: a,
      outputSchema: n,
      toModelOutput: s,
      onInputStart: o,
      onInputDelta: i,
      onInputAvailable: l,
      ...c
    }) => ({
      type: "provider-defined",
      id: t,
      name: e,
      args: c,
      inputSchema: r,
      outputSchema: n,
      execute: a,
      toModelOutput: s,
      onInputStart: o,
      onInputDelta: i,
      onInputAvailable: l,
    });
  }
  var r0 =
      ({ errorSchema: t, errorToMessage: e, isRetryable: r }) =>
      async ({ response: a, url: n, requestBodyValues: s }) => {
        const o = await a.text(),
          i = ao(a);
        if (o.trim() === "")
          return {
            responseHeaders: i,
            value: new Xe({
              message: a.statusText,
              url: n,
              requestBodyValues: s,
              statusCode: a.status,
              responseHeaders: i,
              responseBody: o,
              isRetryable: r == null ? void 0 : r(a),
            }),
          };
        try {
          const l = await Y4({ text: o, schema: t });
          return {
            responseHeaders: i,
            value: new Xe({
              message: e(l),
              url: n,
              requestBodyValues: s,
              statusCode: a.status,
              responseHeaders: i,
              responseBody: o,
              data: l,
              isRetryable: r == null ? void 0 : r(a, l),
            }),
          };
        } catch {
          return {
            responseHeaders: i,
            value: new Xe({
              message: a.statusText,
              url: n,
              requestBodyValues: s,
              statusCode: a.status,
              responseHeaders: i,
              responseBody: o,
              isRetryable: r == null ? void 0 : r(a),
            }),
          };
        }
      },
    fl =
      (t) =>
      async ({ response: e }) => {
        const r = ao(e);
        if (e.body == null) throw new Sv({});
        return { responseHeaders: r, value: X4({ stream: e.body, schema: t }) };
      },
    Yn =
      (t) =>
      async ({ response: e, url: r, requestBodyValues: a }) => {
        const n = await e.text(),
          s = await e0({ text: n, schema: t }),
          o = ao(e);
        if (!s.success)
          throw new Xe({
            message: "Invalid JSON response",
            cause: s.error,
            statusCode: e.status,
            responseHeaders: o,
            responseBody: n,
            url: r,
            requestBodyValues: a,
          });
        return { responseHeaders: o, value: s.value, rawValue: s.rawValue };
      },
    rj =
      () =>
      async ({ response: t, url: e, requestBodyValues: r }) => {
        const a = ao(t);
        if (!t.body)
          throw new Xe({
            message: "Response body is empty",
            url: e,
            requestBodyValues: r,
            statusCode: t.status,
            responseHeaders: a,
            responseBody: void 0,
          });
        try {
          const n = await t.arrayBuffer();
          return { responseHeaders: a, value: new Uint8Array(n) };
        } catch (n) {
          throw new Xe({
            message: "Failed to read response as array buffer",
            url: e,
            requestBodyValues: r,
            statusCode: t.status,
            responseHeaders: a,
            responseBody: void 0,
            cause: n,
          });
        }
      },
    { btoa: nj, atob: aj } = globalThis;
  function sj(t) {
    const e = t.replace(/-/g, "+").replace(/_/g, "/"),
      r = aj(e);
    return Uint8Array.from(r, (a) => a.codePointAt(0));
  }
  function oj(t) {
    let e = "";
    for (let r = 0; r < t.length; r++) e += String.fromCodePoint(t[r]);
    return nj(e);
  }
  function Xn(t) {
    return t instanceof Uint8Array ? oj(t) : t;
  }
  function n0(t) {
    return t == null ? void 0 : t.replace(/\/$/, "");
  }
  var af = O({
      error: O({
        message: S(),
        type: S().nullish(),
        param: Tr().nullish(),
        code: Fe([S(), K()]).nullish(),
      }),
    }),
    Jr = r0({ errorSchema: af, errorToMessage: (t) => t.error.message });
  function ij({ prompt: t, systemMessageMode: e = "system" }) {
    const r = [],
      a = [];
    for (const { role: n, content: s } of t)
      switch (n) {
        case "system": {
          switch (e) {
            case "system": {
              r.push({ role: "system", content: s });
              break;
            }
            case "developer": {
              r.push({ role: "developer", content: s });
              break;
            }
            case "remove": {
              a.push({
                type: "other",
                message: "system messages are removed for this model",
              });
              break;
            }
            default: {
              const o = e;
              throw new Error(`Unsupported system message mode: ${o}`);
            }
          }
          break;
        }
        case "user": {
          if (s.length === 1 && s[0].type === "text") {
            r.push({ role: "user", content: s[0].text });
            break;
          }
          r.push({
            role: "user",
            content: s.map((o, i) => {
              var l, c, u;
              switch (o.type) {
                case "text":
                  return { type: "text", text: o.text };
                case "file":
                  if (o.mediaType.startsWith("image/")) {
                    const f =
                      o.mediaType === "image/*" ? "image/jpeg" : o.mediaType;
                    return {
                      type: "image_url",
                      image_url: {
                        url:
                          o.data instanceof URL
                            ? o.data.toString()
                            : `data:${f};base64,${Xn(o.data)}`,
                        detail:
                          (c =
                            (l = o.providerOptions) == null
                              ? void 0
                              : l.openai) == null
                            ? void 0
                            : c.imageDetail,
                      },
                    };
                  } else if (o.mediaType.startsWith("audio/")) {
                    if (o.data instanceof URL)
                      throw new dr({
                        functionality: "audio file parts with URLs",
                      });
                    switch (o.mediaType) {
                      case "audio/wav":
                        return {
                          type: "input_audio",
                          input_audio: { data: Xn(o.data), format: "wav" },
                        };
                      case "audio/mp3":
                      case "audio/mpeg":
                        return {
                          type: "input_audio",
                          input_audio: { data: Xn(o.data), format: "mp3" },
                        };
                      default:
                        throw new dr({
                          functionality: `audio content parts with media type ${o.mediaType}`,
                        });
                    }
                  } else if (o.mediaType === "application/pdf") {
                    if (o.data instanceof URL)
                      throw new dr({
                        functionality: "PDF file parts with URLs",
                      });
                    return {
                      type: "file",
                      file:
                        typeof o.data == "string" && o.data.startsWith("file-")
                          ? { file_id: o.data }
                          : {
                              filename:
                                (u = o.filename) != null ? u : `part-${i}.pdf`,
                              file_data: `data:application/pdf;base64,${Xn(
                                o.data
                              )}`,
                            },
                    };
                  } else
                    throw new dr({
                      functionality: `file part media type ${o.mediaType}`,
                    });
              }
            }),
          });
          break;
        }
        case "assistant": {
          let o = "";
          const i = [];
          for (const l of s)
            switch (l.type) {
              case "text": {
                o += l.text;
                break;
              }
              case "tool-call": {
                i.push({
                  id: l.toolCallId,
                  type: "function",
                  function: {
                    name: l.toolName,
                    arguments: JSON.stringify(l.input),
                  },
                });
                break;
              }
            }
          r.push({
            role: "assistant",
            content: o,
            tool_calls: i.length > 0 ? i : void 0,
          });
          break;
        }
        case "tool": {
          for (const o of s) {
            const i = o.output;
            let l;
            switch (i.type) {
              case "text":
              case "error-text":
                l = i.value;
                break;
              case "content":
              case "json":
              case "error-json":
                l = JSON.stringify(i.value);
                break;
            }
            r.push({ role: "tool", tool_call_id: o.toolCallId, content: l });
          }
          break;
        }
        default: {
          const o = n;
          throw new Error(`Unsupported role: ${o}`);
        }
      }
    return { messages: r, warnings: a };
  }
  function a0({ id: t, model: e, created: r }) {
    return {
      id: t ?? void 0,
      modelId: e ?? void 0,
      timestamp: r != null ? new Date(r * 1e3) : void 0,
    };
  }
  function s0(t) {
    switch (t) {
      case "stop":
        return "stop";
      case "length":
        return "length";
      case "content_filter":
        return "content-filter";
      case "function_call":
      case "tool_calls":
        return "tool-calls";
      default:
        return "unknown";
    }
  }
  var lj = O({
      logitBias: Xt(M2(), K()).optional(),
      logprobs: Fe([Ve(), K()]).optional(),
      parallelToolCalls: Ve().optional(),
      user: S().optional(),
      reasoningEffort: Vt(["minimal", "low", "medium", "high"]).optional(),
      maxCompletionTokens: K().optional(),
      store: Ve().optional(),
      metadata: Xt(S().max(64), S().max(512)).optional(),
      prediction: Xt(S(), Tr()).optional(),
      structuredOutputs: Ve().optional(),
      serviceTier: Vt(["auto", "flex", "priority"]).optional(),
      strictJsonSchema: Ve().optional(),
      textVerbosity: Vt(["low", "medium", "high"]).optional(),
      promptCacheKey: S().optional(),
      safetyIdentifier: S().optional(),
    }),
    o0 = O({
      key: S(),
      type: Vt(["eq", "ne", "gt", "gte", "lt", "lte"]),
      value: Fe([S(), K(), Ve()]),
    }),
    i0 = O({ type: Vt(["and", "or"]), filters: ce(Fe([o0, Hg(() => i0)])) }),
    cj = Fe([o0, i0]),
    l0 = O({
      vectorStoreIds: ce(S()).optional(),
      maxNumResults: K().optional(),
      ranking: O({
        ranker: Vt(["auto", "default-2024-08-21"]).optional(),
      }).optional(),
      filters: cj.optional(),
    }),
    uj = nf({
      id: "openai.file_search",
      name: "file_search",
      inputSchema: O({ query: S() }),
    }),
    c0 = O({
      searchContextSize: Vt(["low", "medium", "high"]).optional(),
      userLocation: O({
        type: W("approximate"),
        country: S().optional(),
        city: S().optional(),
        region: S().optional(),
        timezone: S().optional(),
      }).optional(),
    }),
    dj = nf({
      id: "openai.web_search_preview",
      name: "web_search_preview",
      inputSchema: O({}),
    });
  function fj({
    tools: t,
    toolChoice: e,
    structuredOutputs: r,
    strictJsonSchema: a,
  }) {
    t = t != null && t.length ? t : void 0;
    const n = [];
    if (t == null)
      return { tools: void 0, toolChoice: void 0, toolWarnings: n };
    const s = [];
    for (const i of t)
      switch (i.type) {
        case "function":
          s.push({
            type: "function",
            function: {
              name: i.name,
              description: i.description,
              parameters: i.inputSchema,
              strict: r ? a : void 0,
            },
          });
          break;
        case "provider-defined":
          switch (i.id) {
            case "openai.file_search": {
              const l = l0.parse(i.args);
              s.push({
                type: "file_search",
                vector_store_ids: l.vectorStoreIds,
                max_num_results: l.maxNumResults,
                ranking_options: l.ranking
                  ? { ranker: l.ranking.ranker }
                  : void 0,
                filters: l.filters,
              });
              break;
            }
            case "openai.web_search_preview": {
              const l = c0.parse(i.args);
              s.push({
                type: "web_search_preview",
                search_context_size: l.searchContextSize,
                user_location: l.userLocation,
              });
              break;
            }
            default:
              n.push({ type: "unsupported-tool", tool: i });
              break;
          }
          break;
        default:
          n.push({ type: "unsupported-tool", tool: i });
          break;
      }
    if (e == null) return { tools: s, toolChoice: void 0, toolWarnings: n };
    const o = e.type;
    switch (o) {
      case "auto":
      case "none":
      case "required":
        return { tools: s, toolChoice: o, toolWarnings: n };
      case "tool":
        return {
          tools: s,
          toolChoice: { type: "function", function: { name: e.toolName } },
          toolWarnings: n,
        };
      default: {
        const i = o;
        throw new dr({ functionality: `tool choice type: ${i}` });
      }
    }
  }
  var pj = class {
      constructor(t, e) {
        (this.specificationVersion = "v2"),
          (this.supportedUrls = { "image/*": [/^https?:\/\/.*$/] }),
          (this.modelId = t),
          (this.config = e);
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        prompt: t,
        maxOutputTokens: e,
        temperature: r,
        topP: a,
        topK: n,
        frequencyPenalty: s,
        presencePenalty: o,
        stopSequences: i,
        responseFormat: l,
        seed: c,
        tools: u,
        toolChoice: f,
        providerOptions: v,
      }) {
        var d, p, g, m;
        const h = [],
          y =
            (d = await Br({
              provider: "openai",
              providerOptions: v,
              schema: lj,
            })) != null
              ? d
              : {},
          _ = (p = y.structuredOutputs) != null ? p : !0;
        n != null && h.push({ type: "unsupported-setting", setting: "topK" }),
          (l == null ? void 0 : l.type) === "json" &&
            l.schema != null &&
            !_ &&
            h.push({
              type: "unsupported-setting",
              setting: "responseFormat",
              details:
                "JSON response format schema is only supported with structuredOutputs",
            });
        const { messages: w, warnings: E } = ij({
          prompt: t,
          systemMessageMode: yj(this.modelId),
        });
        h.push(...E);
        const P = (g = y.strictJsonSchema) != null ? g : !1,
          x = {
            model: this.modelId,
            logit_bias: y.logitBias,
            logprobs:
              y.logprobs === !0 || typeof y.logprobs == "number" ? !0 : void 0,
            top_logprobs:
              typeof y.logprobs == "number"
                ? y.logprobs
                : typeof y.logprobs == "boolean" && y.logprobs
                ? 0
                : void 0,
            user: y.user,
            parallel_tool_calls: y.parallelToolCalls,
            max_tokens: e,
            temperature: r,
            top_p: a,
            frequency_penalty: s,
            presence_penalty: o,
            response_format:
              (l == null ? void 0 : l.type) === "json"
                ? _ && l.schema != null
                  ? {
                      type: "json_schema",
                      json_schema: {
                        schema: l.schema,
                        strict: P,
                        name: (m = l.name) != null ? m : "response",
                        description: l.description,
                      },
                    }
                  : { type: "json_object" }
                : void 0,
            stop: i,
            seed: c,
            verbosity: y.textVerbosity,
            max_completion_tokens: y.maxCompletionTokens,
            store: y.store,
            metadata: y.metadata,
            prediction: y.prediction,
            reasoning_effort: y.reasoningEffort,
            service_tier: y.serviceTier,
            prompt_cache_key: y.promptCacheKey,
            safety_identifier: y.safetyIdentifier,
            messages: w,
          };
        d0(this.modelId)
          ? (x.temperature != null &&
              ((x.temperature = void 0),
              h.push({
                type: "unsupported-setting",
                setting: "temperature",
                details: "temperature is not supported for reasoning models",
              })),
            x.top_p != null &&
              ((x.top_p = void 0),
              h.push({
                type: "unsupported-setting",
                setting: "topP",
                details: "topP is not supported for reasoning models",
              })),
            x.frequency_penalty != null &&
              ((x.frequency_penalty = void 0),
              h.push({
                type: "unsupported-setting",
                setting: "frequencyPenalty",
                details:
                  "frequencyPenalty is not supported for reasoning models",
              })),
            x.presence_penalty != null &&
              ((x.presence_penalty = void 0),
              h.push({
                type: "unsupported-setting",
                setting: "presencePenalty",
                details:
                  "presencePenalty is not supported for reasoning models",
              })),
            x.logit_bias != null &&
              ((x.logit_bias = void 0),
              h.push({
                type: "other",
                message: "logitBias is not supported for reasoning models",
              })),
            x.logprobs != null &&
              ((x.logprobs = void 0),
              h.push({
                type: "other",
                message: "logprobs is not supported for reasoning models",
              })),
            x.top_logprobs != null &&
              ((x.top_logprobs = void 0),
              h.push({
                type: "other",
                message: "topLogprobs is not supported for reasoning models",
              })),
            x.max_tokens != null &&
              (x.max_completion_tokens == null &&
                (x.max_completion_tokens = x.max_tokens),
              (x.max_tokens = void 0)))
          : (this.modelId.startsWith("gpt-4o-search-preview") ||
              this.modelId.startsWith("gpt-4o-mini-search-preview")) &&
            x.temperature != null &&
            ((x.temperature = void 0),
            h.push({
              type: "unsupported-setting",
              setting: "temperature",
              details:
                "temperature is not supported for the search preview models and has been removed.",
            })),
          y.serviceTier === "flex" &&
            !vj(this.modelId) &&
            (h.push({
              type: "unsupported-setting",
              setting: "serviceTier",
              details:
                "flex processing is only available for o3, o4-mini, and gpt-5 models",
            }),
            (x.service_tier = void 0)),
          y.serviceTier === "priority" &&
            !gj(this.modelId) &&
            (h.push({
              type: "unsupported-setting",
              setting: "serviceTier",
              details:
                "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported",
            }),
            (x.service_tier = void 0));
        const {
          tools: A,
          toolChoice: M,
          toolWarnings: H,
        } = fj({
          tools: u,
          toolChoice: f,
          structuredOutputs: _,
          strictJsonSchema: P,
        });
        return {
          args: { ...x, tools: A, tool_choice: M },
          warnings: [...h, ...H],
        };
      }
      async doGenerate(t) {
        var e, r, a, n, s, o, i, l, c, u, f, v, d, p;
        const { args: g, warnings: m } = await this.getArgs(t),
          {
            responseHeaders: h,
            value: y,
            rawValue: _,
          } = await xr({
            url: this.config.url({
              path: "/chat/completions",
              modelId: this.modelId,
            }),
            headers: pr(this.config.headers(), t.headers),
            body: g,
            failedResponseHandler: Jr,
            successfulResponseHandler: Yn(hj),
            abortSignal: t.abortSignal,
            fetch: this.config.fetch,
          }),
          w = y.choices[0],
          E = [],
          P = w.message.content;
        P != null && P.length > 0 && E.push({ type: "text", text: P });
        for (const H of (e = w.message.tool_calls) != null ? e : [])
          E.push({
            type: "tool-call",
            toolCallId: (r = H.id) != null ? r : sr(),
            toolName: H.function.name,
            input: H.function.arguments,
          });
        for (const H of (a = w.message.annotations) != null ? a : [])
          E.push({
            type: "source",
            sourceType: "url",
            id: sr(),
            url: H.url,
            title: H.title,
          });
        const x = (n = y.usage) == null ? void 0 : n.completion_tokens_details,
          A = (s = y.usage) == null ? void 0 : s.prompt_tokens_details,
          M = { openai: {} };
        return (
          (x == null ? void 0 : x.accepted_prediction_tokens) != null &&
            (M.openai.acceptedPredictionTokens =
              x == null ? void 0 : x.accepted_prediction_tokens),
          (x == null ? void 0 : x.rejected_prediction_tokens) != null &&
            (M.openai.rejectedPredictionTokens =
              x == null ? void 0 : x.rejected_prediction_tokens),
          ((o = w.logprobs) == null ? void 0 : o.content) != null &&
            (M.openai.logprobs = w.logprobs.content),
          {
            content: E,
            finishReason: s0(w.finish_reason),
            usage: {
              inputTokens:
                (l = (i = y.usage) == null ? void 0 : i.prompt_tokens) != null
                  ? l
                  : void 0,
              outputTokens:
                (u = (c = y.usage) == null ? void 0 : c.completion_tokens) !=
                null
                  ? u
                  : void 0,
              totalTokens:
                (v = (f = y.usage) == null ? void 0 : f.total_tokens) != null
                  ? v
                  : void 0,
              reasoningTokens:
                (d = x == null ? void 0 : x.reasoning_tokens) != null
                  ? d
                  : void 0,
              cachedInputTokens:
                (p = A == null ? void 0 : A.cached_tokens) != null ? p : void 0,
            },
            request: { body: g },
            response: { ...a0(y), headers: h, body: _ },
            warnings: m,
            providerMetadata: M,
          }
        );
      }
      async doStream(t) {
        const { args: e, warnings: r } = await this.getArgs(t),
          a = { ...e, stream: !0, stream_options: { include_usage: !0 } },
          { responseHeaders: n, value: s } = await xr({
            url: this.config.url({
              path: "/chat/completions",
              modelId: this.modelId,
            }),
            headers: pr(this.config.headers(), t.headers),
            body: a,
            failedResponseHandler: Jr,
            successfulResponseHandler: fl(mj),
            abortSignal: t.abortSignal,
            fetch: this.config.fetch,
          }),
          o = [];
        let i = "unknown";
        const l = {
          inputTokens: void 0,
          outputTokens: void 0,
          totalTokens: void 0,
        };
        let c = !0,
          u = !1;
        const f = { openai: {} };
        return {
          stream: s.pipeThrough(
            new TransformStream({
              start(v) {
                v.enqueue({ type: "stream-start", warnings: r });
              },
              transform(v, d) {
                var p,
                  g,
                  m,
                  h,
                  y,
                  _,
                  w,
                  E,
                  P,
                  x,
                  A,
                  M,
                  H,
                  V,
                  J,
                  z,
                  Z,
                  te,
                  me,
                  ge,
                  N,
                  se,
                  D,
                  k;
                if (
                  (t.includeRawChunks &&
                    d.enqueue({ type: "raw", rawValue: v.rawValue }),
                  !v.success)
                ) {
                  (i = "error"), d.enqueue({ type: "error", error: v.error });
                  return;
                }
                const L = v.value;
                if ("error" in L) {
                  (i = "error"), d.enqueue({ type: "error", error: L.error });
                  return;
                }
                c &&
                  ((c = !1),
                  d.enqueue({ type: "response-metadata", ...a0(L) })),
                  L.usage != null &&
                    ((l.inputTokens =
                      (p = L.usage.prompt_tokens) != null ? p : void 0),
                    (l.outputTokens =
                      (g = L.usage.completion_tokens) != null ? g : void 0),
                    (l.totalTokens =
                      (m = L.usage.total_tokens) != null ? m : void 0),
                    (l.reasoningTokens =
                      (y =
                        (h = L.usage.completion_tokens_details) == null
                          ? void 0
                          : h.reasoning_tokens) != null
                        ? y
                        : void 0),
                    (l.cachedInputTokens =
                      (w =
                        (_ = L.usage.prompt_tokens_details) == null
                          ? void 0
                          : _.cached_tokens) != null
                        ? w
                        : void 0),
                    ((E = L.usage.completion_tokens_details) == null
                      ? void 0
                      : E.accepted_prediction_tokens) != null &&
                      (f.openai.acceptedPredictionTokens =
                        (P = L.usage.completion_tokens_details) == null
                          ? void 0
                          : P.accepted_prediction_tokens),
                    ((x = L.usage.completion_tokens_details) == null
                      ? void 0
                      : x.rejected_prediction_tokens) != null &&
                      (f.openai.rejectedPredictionTokens =
                        (A = L.usage.completion_tokens_details) == null
                          ? void 0
                          : A.rejected_prediction_tokens));
                const R = L.choices[0];
                if (
                  ((R == null ? void 0 : R.finish_reason) != null &&
                    (i = s0(R.finish_reason)),
                  ((M = R == null ? void 0 : R.logprobs) == null
                    ? void 0
                    : M.content) != null &&
                    (f.openai.logprobs = R.logprobs.content),
                  (R == null ? void 0 : R.delta) == null)
                )
                  return;
                const b = R.delta;
                if (
                  (b.content != null &&
                    (u ||
                      (d.enqueue({ type: "text-start", id: "0" }), (u = !0)),
                    d.enqueue({
                      type: "text-delta",
                      id: "0",
                      delta: b.content,
                    })),
                  b.tool_calls != null)
                )
                  for (const T of b.tool_calls) {
                    const q = T.index;
                    if (o[q] == null) {
                      if (T.type !== "function")
                        throw new Ms({
                          data: T,
                          message: "Expected 'function' type.",
                        });
                      if (T.id == null)
                        throw new Ms({
                          data: T,
                          message: "Expected 'id' to be a string.",
                        });
                      if (((H = T.function) == null ? void 0 : H.name) == null)
                        throw new Ms({
                          data: T,
                          message: "Expected 'function.name' to be a string.",
                        });
                      d.enqueue({
                        type: "tool-input-start",
                        id: T.id,
                        toolName: T.function.name,
                      }),
                        (o[q] = {
                          id: T.id,
                          type: "function",
                          function: {
                            name: T.function.name,
                            arguments:
                              (V = T.function.arguments) != null ? V : "",
                          },
                          hasFinished: !1,
                        });
                      const ee = o[q];
                      ((J = ee.function) == null ? void 0 : J.name) != null &&
                        ((z = ee.function) == null ? void 0 : z.arguments) !=
                          null &&
                        (ee.function.arguments.length > 0 &&
                          d.enqueue({
                            type: "tool-input-delta",
                            id: ee.id,
                            delta: ee.function.arguments,
                          }),
                        dl(ee.function.arguments) &&
                          (d.enqueue({ type: "tool-input-end", id: ee.id }),
                          d.enqueue({
                            type: "tool-call",
                            toolCallId: (Z = ee.id) != null ? Z : sr(),
                            toolName: ee.function.name,
                            input: ee.function.arguments,
                          }),
                          (ee.hasFinished = !0)));
                      continue;
                    }
                    const G = o[q];
                    G.hasFinished ||
                      (((te = T.function) == null ? void 0 : te.arguments) !=
                        null &&
                        (G.function.arguments +=
                          (ge =
                            (me = T.function) == null
                              ? void 0
                              : me.arguments) != null
                            ? ge
                            : ""),
                      d.enqueue({
                        type: "tool-input-delta",
                        id: G.id,
                        delta: (N = T.function.arguments) != null ? N : "",
                      }),
                      ((se = G.function) == null ? void 0 : se.name) != null &&
                        ((D = G.function) == null ? void 0 : D.arguments) !=
                          null &&
                        dl(G.function.arguments) &&
                        (d.enqueue({ type: "tool-input-end", id: G.id }),
                        d.enqueue({
                          type: "tool-call",
                          toolCallId: (k = G.id) != null ? k : sr(),
                          toolName: G.function.name,
                          input: G.function.arguments,
                        }),
                        (G.hasFinished = !0)));
                  }
                if (b.annotations != null)
                  for (const T of b.annotations)
                    d.enqueue({
                      type: "source",
                      sourceType: "url",
                      id: sr(),
                      url: T.url,
                      title: T.title,
                    });
              },
              flush(v) {
                u && v.enqueue({ type: "text-end", id: "0" }),
                  v.enqueue({
                    type: "finish",
                    finishReason: i,
                    usage: l,
                    ...(f != null ? { providerMetadata: f } : {}),
                  });
              },
            })
          ),
          request: { body: a },
          response: { headers: n },
        };
      }
    },
    u0 = O({
      prompt_tokens: K().nullish(),
      completion_tokens: K().nullish(),
      total_tokens: K().nullish(),
      prompt_tokens_details: O({ cached_tokens: K().nullish() }).nullish(),
      completion_tokens_details: O({
        reasoning_tokens: K().nullish(),
        accepted_prediction_tokens: K().nullish(),
        rejected_prediction_tokens: K().nullish(),
      }).nullish(),
    }).nullish(),
    hj = O({
      id: S().nullish(),
      created: K().nullish(),
      model: S().nullish(),
      choices: ce(
        O({
          message: O({
            role: W("assistant").nullish(),
            content: S().nullish(),
            tool_calls: ce(
              O({
                id: S().nullish(),
                type: W("function"),
                function: O({ name: S(), arguments: S() }),
              })
            ).nullish(),
            annotations: ce(
              O({
                type: W("url_citation"),
                start_index: K(),
                end_index: K(),
                url: S(),
                title: S(),
              })
            ).nullish(),
          }),
          index: K(),
          logprobs: O({
            content: ce(
              O({
                token: S(),
                logprob: K(),
                top_logprobs: ce(O({ token: S(), logprob: K() })),
              })
            ).nullish(),
          }).nullish(),
          finish_reason: S().nullish(),
        })
      ),
      usage: u0,
    }),
    mj = Fe([
      O({
        id: S().nullish(),
        created: K().nullish(),
        model: S().nullish(),
        choices: ce(
          O({
            delta: O({
              role: Vt(["assistant"]).nullish(),
              content: S().nullish(),
              tool_calls: ce(
                O({
                  index: K(),
                  id: S().nullish(),
                  type: W("function").nullish(),
                  function: O({
                    name: S().nullish(),
                    arguments: S().nullish(),
                  }),
                })
              ).nullish(),
              annotations: ce(
                O({
                  type: W("url_citation"),
                  start_index: K(),
                  end_index: K(),
                  url: S(),
                  title: S(),
                })
              ).nullish(),
            }).nullish(),
            logprobs: O({
              content: ce(
                O({
                  token: S(),
                  logprob: K(),
                  top_logprobs: ce(O({ token: S(), logprob: K() })),
                })
              ).nullish(),
            }).nullish(),
            finish_reason: S().nullish(),
            index: K(),
          })
        ),
        usage: u0,
      }),
      af,
    ]);
  function d0(t) {
    return (
      (t.startsWith("o") || t.startsWith("gpt-5")) &&
      !t.startsWith("gpt-5-chat")
    );
  }
  function vj(t) {
    return (
      t.startsWith("o3") ||
      t.startsWith("o4-mini") ||
      (t.startsWith("gpt-5") && !t.startsWith("gpt-5-chat"))
    );
  }
  function gj(t) {
    return (
      t.startsWith("gpt-4") ||
      t.startsWith("gpt-5-mini") ||
      (t.startsWith("gpt-5") &&
        !t.startsWith("gpt-5-nano") &&
        !t.startsWith("gpt-5-chat")) ||
      t.startsWith("o3") ||
      t.startsWith("o4-mini")
    );
  }
  function yj(t) {
    var e, r;
    return d0(t)
      ? (r = (e = _j[t]) == null ? void 0 : e.systemMessageMode) != null
        ? r
        : "developer"
      : "system";
  }
  var _j = {
    "o1-mini": { systemMessageMode: "remove" },
    "o1-mini-2024-09-12": { systemMessageMode: "remove" },
    "o1-preview": { systemMessageMode: "remove" },
    "o1-preview-2024-09-12": { systemMessageMode: "remove" },
    o3: { systemMessageMode: "developer" },
    "o3-2025-04-16": { systemMessageMode: "developer" },
    "o3-mini": { systemMessageMode: "developer" },
    "o3-mini-2025-01-31": { systemMessageMode: "developer" },
    "o4-mini": { systemMessageMode: "developer" },
    "o4-mini-2025-04-16": { systemMessageMode: "developer" },
  };
  function wj({ prompt: t, user: e = "user", assistant: r = "assistant" }) {
    let a = "";
    t[0].role === "system" &&
      ((a += `${t[0].content}

`),
      (t = t.slice(1)));
    for (const { role: n, content: s } of t)
      switch (n) {
        case "system":
          throw new Zn({
            message: "Unexpected system message in prompt: ${content}",
            prompt: t,
          });
        case "user": {
          const o = s
            .map((i) => {
              switch (i.type) {
                case "text":
                  return i.text;
              }
            })
            .filter(Boolean)
            .join("");
          a += `${e}:
${o}

`;
          break;
        }
        case "assistant": {
          const o = s
            .map((i) => {
              switch (i.type) {
                case "text":
                  return i.text;
                case "tool-call":
                  throw new dr({ functionality: "tool-call messages" });
              }
            })
            .join("");
          a += `${r}:
${o}

`;
          break;
        }
        case "tool":
          throw new dr({ functionality: "tool messages" });
        default: {
          const o = n;
          throw new Error(`Unsupported role: ${o}`);
        }
      }
    return (
      (a += `${r}:
`),
      {
        prompt: a,
        stopSequences: [
          `
${e}:`,
        ],
      }
    );
  }
  function f0({ id: t, model: e, created: r }) {
    return {
      id: t ?? void 0,
      modelId: e ?? void 0,
      timestamp: r != null ? new Date(r * 1e3) : void 0,
    };
  }
  function p0(t) {
    switch (t) {
      case "stop":
        return "stop";
      case "length":
        return "length";
      case "content_filter":
        return "content-filter";
      case "function_call":
      case "tool_calls":
        return "tool-calls";
      default:
        return "unknown";
    }
  }
  var h0 = O({
      echo: Ve().optional(),
      logitBias: Xt(S(), K()).optional(),
      suffix: S().optional(),
      user: S().optional(),
      logprobs: Fe([Ve(), K()]).optional(),
    }),
    bj = class {
      constructor(t, e) {
        (this.specificationVersion = "v2"),
          (this.supportedUrls = {}),
          (this.modelId = t),
          (this.config = e);
      }
      get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        prompt: t,
        maxOutputTokens: e,
        temperature: r,
        topP: a,
        topK: n,
        frequencyPenalty: s,
        presencePenalty: o,
        stopSequences: i,
        responseFormat: l,
        tools: c,
        toolChoice: u,
        seed: f,
        providerOptions: v,
      }) {
        const d = [],
          p = {
            ...(await Br({
              provider: "openai",
              providerOptions: v,
              schema: h0,
            })),
            ...(await Br({
              provider: this.providerOptionsName,
              providerOptions: v,
              schema: h0,
            })),
          };
        n != null && d.push({ type: "unsupported-setting", setting: "topK" }),
          c != null &&
            c.length &&
            d.push({ type: "unsupported-setting", setting: "tools" }),
          u != null &&
            d.push({ type: "unsupported-setting", setting: "toolChoice" }),
          l != null &&
            l.type !== "text" &&
            d.push({
              type: "unsupported-setting",
              setting: "responseFormat",
              details: "JSON response format is not supported.",
            });
        const { prompt: g, stopSequences: m } = wj({ prompt: t }),
          h = [...(m ?? []), ...(i ?? [])];
        return {
          args: {
            model: this.modelId,
            echo: p.echo,
            logit_bias: p.logitBias,
            logprobs:
              (p == null ? void 0 : p.logprobs) === !0
                ? 0
                : (p == null ? void 0 : p.logprobs) === !1 || p == null
                ? void 0
                : p.logprobs,
            suffix: p.suffix,
            user: p.user,
            max_tokens: e,
            temperature: r,
            top_p: a,
            frequency_penalty: s,
            presence_penalty: o,
            seed: f,
            prompt: g,
            stop: h.length > 0 ? h : void 0,
          },
          warnings: d,
        };
      }
      async doGenerate(t) {
        var e, r, a;
        const { args: n, warnings: s } = await this.getArgs(t),
          {
            responseHeaders: o,
            value: i,
            rawValue: l,
          } = await xr({
            url: this.config.url({
              path: "/completions",
              modelId: this.modelId,
            }),
            headers: pr(this.config.headers(), t.headers),
            body: n,
            failedResponseHandler: Jr,
            successfulResponseHandler: Yn(Ej),
            abortSignal: t.abortSignal,
            fetch: this.config.fetch,
          }),
          c = i.choices[0],
          u = { openai: {} };
        return (
          c.logprobs != null && (u.openai.logprobs = c.logprobs),
          {
            content: [{ type: "text", text: c.text }],
            usage: {
              inputTokens: (e = i.usage) == null ? void 0 : e.prompt_tokens,
              outputTokens:
                (r = i.usage) == null ? void 0 : r.completion_tokens,
              totalTokens: (a = i.usage) == null ? void 0 : a.total_tokens,
            },
            finishReason: p0(c.finish_reason),
            request: { body: n },
            response: { ...f0(i), headers: o, body: l },
            providerMetadata: u,
            warnings: s,
          }
        );
      }
      async doStream(t) {
        const { args: e, warnings: r } = await this.getArgs(t),
          a = { ...e, stream: !0, stream_options: { include_usage: !0 } },
          { responseHeaders: n, value: s } = await xr({
            url: this.config.url({
              path: "/completions",
              modelId: this.modelId,
            }),
            headers: pr(this.config.headers(), t.headers),
            body: a,
            failedResponseHandler: Jr,
            successfulResponseHandler: fl(Sj),
            abortSignal: t.abortSignal,
            fetch: this.config.fetch,
          });
        let o = "unknown";
        const i = { openai: {} },
          l = {
            inputTokens: void 0,
            outputTokens: void 0,
            totalTokens: void 0,
          };
        let c = !0;
        return {
          stream: s.pipeThrough(
            new TransformStream({
              start(u) {
                u.enqueue({ type: "stream-start", warnings: r });
              },
              transform(u, f) {
                if (
                  (t.includeRawChunks &&
                    f.enqueue({ type: "raw", rawValue: u.rawValue }),
                  !u.success)
                ) {
                  (o = "error"), f.enqueue({ type: "error", error: u.error });
                  return;
                }
                const v = u.value;
                if ("error" in v) {
                  (o = "error"), f.enqueue({ type: "error", error: v.error });
                  return;
                }
                c &&
                  ((c = !1),
                  f.enqueue({ type: "response-metadata", ...f0(v) }),
                  f.enqueue({ type: "text-start", id: "0" })),
                  v.usage != null &&
                    ((l.inputTokens = v.usage.prompt_tokens),
                    (l.outputTokens = v.usage.completion_tokens),
                    (l.totalTokens = v.usage.total_tokens));
                const d = v.choices[0];
                (d == null ? void 0 : d.finish_reason) != null &&
                  (o = p0(d.finish_reason)),
                  (d == null ? void 0 : d.logprobs) != null &&
                    (i.openai.logprobs = d.logprobs),
                  (d == null ? void 0 : d.text) != null &&
                    d.text.length > 0 &&
                    f.enqueue({ type: "text-delta", id: "0", delta: d.text });
              },
              flush(u) {
                c || u.enqueue({ type: "text-end", id: "0" }),
                  u.enqueue({
                    type: "finish",
                    finishReason: o,
                    providerMetadata: i,
                    usage: l,
                  });
              },
            })
          ),
          request: { body: a },
          response: { headers: n },
        };
      }
    },
    m0 = O({ prompt_tokens: K(), completion_tokens: K(), total_tokens: K() }),
    Ej = O({
      id: S().nullish(),
      created: K().nullish(),
      model: S().nullish(),
      choices: ce(
        O({
          text: S(),
          finish_reason: S(),
          logprobs: O({
            tokens: ce(S()),
            token_logprobs: ce(K()),
            top_logprobs: ce(Xt(S(), K())).nullish(),
          }).nullish(),
        })
      ),
      usage: m0.nullish(),
    }),
    Sj = Fe([
      O({
        id: S().nullish(),
        created: K().nullish(),
        model: S().nullish(),
        choices: ce(
          O({
            text: S(),
            finish_reason: S().nullish(),
            index: K(),
            logprobs: O({
              tokens: ce(S()),
              token_logprobs: ce(K()),
              top_logprobs: ce(Xt(S(), K())).nullish(),
            }).nullish(),
          })
        ),
        usage: m0.nullish(),
      }),
      af,
    ]),
    $j = O({ dimensions: K().optional(), user: S().optional() }),
    Pj = class {
      constructor(t, e) {
        (this.specificationVersion = "v2"),
          (this.maxEmbeddingsPerCall = 2048),
          (this.supportsParallelCalls = !0),
          (this.modelId = t),
          (this.config = e);
      }
      get provider() {
        return this.config.provider;
      }
      async doEmbed({
        values: t,
        headers: e,
        abortSignal: r,
        providerOptions: a,
      }) {
        var n;
        if (t.length > this.maxEmbeddingsPerCall)
          throw new Rk({
            provider: this.provider,
            modelId: this.modelId,
            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
            values: t,
          });
        const s =
            (n = await Br({
              provider: "openai",
              providerOptions: a,
              schema: $j,
            })) != null
              ? n
              : {},
          {
            responseHeaders: o,
            value: i,
            rawValue: l,
          } = await xr({
            url: this.config.url({
              path: "/embeddings",
              modelId: this.modelId,
            }),
            headers: pr(this.config.headers(), e),
            body: {
              model: this.modelId,
              input: t,
              encoding_format: "float",
              dimensions: s.dimensions,
              user: s.user,
            },
            failedResponseHandler: Jr,
            successfulResponseHandler: Yn(Tj),
            abortSignal: r,
            fetch: this.config.fetch,
          });
        return {
          embeddings: i.data.map((c) => c.embedding),
          usage: i.usage ? { tokens: i.usage.prompt_tokens } : void 0,
          response: { headers: o, body: l },
        };
      }
    },
    Tj = O({
      data: ce(O({ embedding: ce(K()) })),
      usage: O({ prompt_tokens: K() }).nullish(),
    }),
    xj = { "dall-e-3": 1, "dall-e-2": 10, "gpt-image-1": 10 },
    Ij = new Set(["gpt-image-1"]),
    kj = class {
      constructor(t, e) {
        (this.modelId = t),
          (this.config = e),
          (this.specificationVersion = "v2");
      }
      get maxImagesPerCall() {
        var t;
        return (t = xj[this.modelId]) != null ? t : 1;
      }
      get provider() {
        return this.config.provider;
      }
      async doGenerate({
        prompt: t,
        n: e,
        size: r,
        aspectRatio: a,
        seed: n,
        providerOptions: s,
        headers: o,
        abortSignal: i,
      }) {
        var l, c, u, f;
        const v = [];
        a != null &&
          v.push({
            type: "unsupported-setting",
            setting: "aspectRatio",
            details:
              "This model does not support aspect ratio. Use `size` instead.",
          }),
          n != null && v.push({ type: "unsupported-setting", setting: "seed" });
        const d =
            (u =
              (c =
                (l = this.config._internal) == null ? void 0 : l.currentDate) ==
              null
                ? void 0
                : c.call(l)) != null
              ? u
              : new Date(),
          { value: p, responseHeaders: g } = await xr({
            url: this.config.url({
              path: "/images/generations",
              modelId: this.modelId,
            }),
            headers: pr(this.config.headers(), o),
            body: {
              model: this.modelId,
              prompt: t,
              n: e,
              size: r,
              ...((f = s.openai) != null ? f : {}),
              ...(Ij.has(this.modelId) ? {} : { response_format: "b64_json" }),
            },
            failedResponseHandler: Jr,
            successfulResponseHandler: Yn(Cj),
            abortSignal: i,
            fetch: this.config.fetch,
          });
        return {
          images: p.data.map((m) => m.b64_json),
          warnings: v,
          response: { timestamp: d, modelId: this.modelId, headers: g },
          providerMetadata: {
            openai: {
              images: p.data.map((m) =>
                m.revised_prompt ? { revisedPrompt: m.revised_prompt } : null
              ),
            },
          },
        };
      }
    },
    Cj = O({ data: ce(O({ b64_json: S(), revised_prompt: S().optional() })) }),
    Rj = O({
      container: Fe([S(), O({ fileIds: ce(S()).optional() })]).optional(),
    }),
    Oj = nf({
      id: "openai.code_interpreter",
      name: "code_interpreter",
      inputSchema: O({}),
    }),
    Aj = { codeInterpreter: Oj, fileSearch: uj, webSearchPreview: dj };
  function v0(t, e) {
    return e ? e.some((r) => t.startsWith(r)) : !1;
  }
  async function Nj({ prompt: t, systemMessageMode: e, fileIdPrefixes: r }) {
    var a, n, s, o, i, l;
    const c = [],
      u = [];
    for (const { role: f, content: v } of t)
      switch (f) {
        case "system": {
          switch (e) {
            case "system": {
              c.push({ role: "system", content: v });
              break;
            }
            case "developer": {
              c.push({ role: "developer", content: v });
              break;
            }
            case "remove": {
              u.push({
                type: "other",
                message: "system messages are removed for this model",
              });
              break;
            }
            default: {
              const d = e;
              throw new Error(`Unsupported system message mode: ${d}`);
            }
          }
          break;
        }
        case "user": {
          c.push({
            role: "user",
            content: v.map((d, p) => {
              var g, m, h;
              switch (d.type) {
                case "text":
                  return { type: "input_text", text: d.text };
                case "file":
                  if (d.mediaType.startsWith("image/")) {
                    const y =
                      d.mediaType === "image/*" ? "image/jpeg" : d.mediaType;
                    return {
                      type: "input_image",
                      ...(d.data instanceof URL
                        ? { image_url: d.data.toString() }
                        : typeof d.data == "string" && v0(d.data, r)
                        ? { file_id: d.data }
                        : { image_url: `data:${y};base64,${Xn(d.data)}` }),
                      detail:
                        (m =
                          (g = d.providerOptions) == null
                            ? void 0
                            : g.openai) == null
                          ? void 0
                          : m.imageDetail,
                    };
                  } else if (d.mediaType === "application/pdf") {
                    if (d.data instanceof URL)
                      throw new dr({
                        functionality: "PDF file parts with URLs",
                      });
                    return {
                      type: "input_file",
                      ...(typeof d.data == "string" && v0(d.data, r)
                        ? { file_id: d.data }
                        : {
                            filename:
                              (h = d.filename) != null ? h : `part-${p}.pdf`,
                            file_data: `data:application/pdf;base64,${Xn(
                              d.data
                            )}`,
                          }),
                    };
                  } else
                    throw new dr({
                      functionality: `file part media type ${d.mediaType}`,
                    });
              }
            }),
          });
          break;
        }
        case "assistant": {
          const d = {};
          for (const p of v)
            switch (p.type) {
              case "text": {
                c.push({
                  role: "assistant",
                  content: [{ type: "output_text", text: p.text }],
                  id:
                    (s =
                      (n =
                        (a = p.providerOptions) == null ? void 0 : a.openai) ==
                      null
                        ? void 0
                        : n.itemId) != null
                      ? s
                      : void 0,
                });
                break;
              }
              case "tool-call": {
                if (p.providerExecuted) break;
                c.push({
                  type: "function_call",
                  call_id: p.toolCallId,
                  name: p.toolName,
                  arguments: JSON.stringify(p.input),
                  id:
                    (l =
                      (i =
                        (o = p.providerOptions) == null ? void 0 : o.openai) ==
                      null
                        ? void 0
                        : i.itemId) != null
                      ? l
                      : void 0,
                });
                break;
              }
              case "tool-result": {
                u.push({
                  type: "other",
                  message:
                    "tool result parts in assistant messages are not supported for OpenAI responses",
                });
                break;
              }
              case "reasoning": {
                const g = await Br({
                    provider: "openai",
                    providerOptions: p.providerOptions,
                    schema: Mj,
                  }),
                  m = g == null ? void 0 : g.itemId;
                if (m != null) {
                  const h = d[m],
                    y = [];
                  p.text.length > 0
                    ? y.push({ type: "summary_text", text: p.text })
                    : h !== void 0 &&
                      u.push({
                        type: "other",
                        message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(
                          p
                        )}.`,
                      }),
                    h === void 0
                      ? ((d[m] = {
                          type: "reasoning",
                          id: m,
                          encrypted_content:
                            g == null ? void 0 : g.reasoningEncryptedContent,
                          summary: y,
                        }),
                        c.push(d[m]))
                      : h.summary.push(...y);
                } else
                  u.push({
                    type: "other",
                    message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(
                      p
                    )}.`,
                  });
                break;
              }
            }
          break;
        }
        case "tool": {
          for (const d of v) {
            const p = d.output;
            let g;
            switch (p.type) {
              case "text":
              case "error-text":
                g = p.value;
                break;
              case "content":
              case "json":
              case "error-json":
                g = JSON.stringify(p.value);
                break;
            }
            c.push({
              type: "function_call_output",
              call_id: d.toolCallId,
              output: g,
            });
          }
          break;
        }
        default: {
          const d = f;
          throw new Error(`Unsupported role: ${d}`);
        }
      }
    return { messages: c, warnings: u };
  }
  var Mj = O({
    itemId: S().nullish(),
    reasoningEncryptedContent: S().nullish(),
  });
  function g0({ finishReason: t, hasToolCalls: e }) {
    switch (t) {
      case void 0:
      case null:
        return e ? "tool-calls" : "stop";
      case "max_output_tokens":
        return "length";
      case "content_filter":
        return "content-filter";
      default:
        return e ? "tool-calls" : "unknown";
    }
  }
  function jj({ tools: t, toolChoice: e, strictJsonSchema: r }) {
    t = t != null && t.length ? t : void 0;
    const a = [];
    if (t == null)
      return { tools: void 0, toolChoice: void 0, toolWarnings: a };
    const n = [];
    for (const o of t)
      switch (o.type) {
        case "function":
          n.push({
            type: "function",
            name: o.name,
            description: o.description,
            parameters: o.inputSchema,
            strict: r,
          });
          break;
        case "provider-defined": {
          switch (o.id) {
            case "openai.file_search": {
              const i = l0.parse(o.args);
              n.push({
                type: "file_search",
                vector_store_ids: i.vectorStoreIds,
                max_num_results: i.maxNumResults,
                ranking_options: i.ranking
                  ? { ranker: i.ranking.ranker }
                  : void 0,
                filters: i.filters,
              });
              break;
            }
            case "openai.web_search_preview": {
              const i = c0.parse(o.args);
              n.push({
                type: "web_search_preview",
                search_context_size: i.searchContextSize,
                user_location: i.userLocation,
              });
              break;
            }
            case "openai.code_interpreter": {
              const i = Rj.parse(o.args);
              n.push({
                type: "code_interpreter",
                container:
                  i.container == null
                    ? { type: "auto", file_ids: void 0 }
                    : typeof i.container == "string"
                    ? i.container
                    : { type: "auto", file_ids: i.container.fileIds },
              });
              break;
            }
            default: {
              a.push({ type: "unsupported-tool", tool: o });
              break;
            }
          }
          break;
        }
        default:
          a.push({ type: "unsupported-tool", tool: o });
          break;
      }
    if (e == null) return { tools: n, toolChoice: void 0, toolWarnings: a };
    const s = e.type;
    switch (s) {
      case "auto":
      case "none":
      case "required":
        return { tools: n, toolChoice: s, toolWarnings: a };
      case "tool":
        return {
          tools: n,
          toolChoice:
            e.toolName === "code_interpreter" ||
            e.toolName === "file_search" ||
            e.toolName === "web_search_preview"
              ? { type: e.toolName }
              : { type: "function", name: e.toolName },
          toolWarnings: a,
        };
      default: {
        const o = s;
        throw new dr({ functionality: `tool choice type: ${o}` });
      }
    }
  }
  var y0 = 20,
    _0 = ce(
      O({
        token: S(),
        logprob: K(),
        top_logprobs: ce(O({ token: S(), logprob: K() })),
      })
    ),
    Dj = class {
      constructor(t, e) {
        (this.specificationVersion = "v2"),
          (this.supportedUrls = { "image/*": [/^https?:\/\/.*$/] }),
          (this.modelId = t),
          (this.config = e);
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        maxOutputTokens: t,
        temperature: e,
        stopSequences: r,
        topP: a,
        topK: n,
        presencePenalty: s,
        frequencyPenalty: o,
        seed: i,
        prompt: l,
        providerOptions: c,
        tools: u,
        toolChoice: f,
        responseFormat: v,
      }) {
        var d, p;
        const g = [],
          m = sD(this.modelId);
        n != null && g.push({ type: "unsupported-setting", setting: "topK" }),
          i != null && g.push({ type: "unsupported-setting", setting: "seed" }),
          s != null &&
            g.push({ type: "unsupported-setting", setting: "presencePenalty" }),
          o != null &&
            g.push({
              type: "unsupported-setting",
              setting: "frequencyPenalty",
            }),
          r != null &&
            g.push({ type: "unsupported-setting", setting: "stopSequences" });
        const { messages: h, warnings: y } = await Nj({
          prompt: l,
          systemMessageMode: m.systemMessageMode,
          fileIdPrefixes: this.config.fileIdPrefixes,
        });
        g.push(...y);
        const _ = await Br({
            provider: "openai",
            providerOptions: c,
            schema: oD,
          }),
          w = (d = _ == null ? void 0 : _.strictJsonSchema) != null ? d : !1,
          E =
            typeof (_ == null ? void 0 : _.logprobs) == "number"
              ? _ == null
                ? void 0
                : _.logprobs
              : (_ == null ? void 0 : _.logprobs) === !0
              ? y0
              : void 0,
          P = E
            ? Array.isArray(_ == null ? void 0 : _.include)
              ? [
                  ...(_ == null ? void 0 : _.include),
                  "message.output_text.logprobs",
                ]
              : ["message.output_text.logprobs"]
            : _ == null
            ? void 0
            : _.include,
          x = {
            model: this.modelId,
            input: h,
            temperature: e,
            top_p: a,
            max_output_tokens: t,
            ...(((v == null ? void 0 : v.type) === "json" ||
              (_ == null ? void 0 : _.textVerbosity)) && {
              text: {
                ...((v == null ? void 0 : v.type) === "json" && {
                  format:
                    v.schema != null
                      ? {
                          type: "json_schema",
                          strict: w,
                          name: (p = v.name) != null ? p : "response",
                          description: v.description,
                          schema: v.schema,
                        }
                      : { type: "json_object" },
                }),
                ...((_ == null ? void 0 : _.textVerbosity) && {
                  verbosity: _.textVerbosity,
                }),
              },
            }),
            metadata: _ == null ? void 0 : _.metadata,
            parallel_tool_calls: _ == null ? void 0 : _.parallelToolCalls,
            previous_response_id: _ == null ? void 0 : _.previousResponseId,
            store: _ == null ? void 0 : _.store,
            user: _ == null ? void 0 : _.user,
            instructions: _ == null ? void 0 : _.instructions,
            service_tier: _ == null ? void 0 : _.serviceTier,
            include: P,
            prompt_cache_key: _ == null ? void 0 : _.promptCacheKey,
            safety_identifier: _ == null ? void 0 : _.safetyIdentifier,
            top_logprobs: E,
            ...(m.isReasoningModel &&
              ((_ == null ? void 0 : _.reasoningEffort) != null ||
                (_ == null ? void 0 : _.reasoningSummary) != null) && {
                reasoning: {
                  ...((_ == null ? void 0 : _.reasoningEffort) != null && {
                    effort: _.reasoningEffort,
                  }),
                  ...((_ == null ? void 0 : _.reasoningSummary) != null && {
                    summary: _.reasoningSummary,
                  }),
                },
              }),
            ...(m.requiredAutoTruncation && { truncation: "auto" }),
          };
        m.isReasoningModel
          ? (x.temperature != null &&
              ((x.temperature = void 0),
              g.push({
                type: "unsupported-setting",
                setting: "temperature",
                details: "temperature is not supported for reasoning models",
              })),
            x.top_p != null &&
              ((x.top_p = void 0),
              g.push({
                type: "unsupported-setting",
                setting: "topP",
                details: "topP is not supported for reasoning models",
              })))
          : ((_ == null ? void 0 : _.reasoningEffort) != null &&
              g.push({
                type: "unsupported-setting",
                setting: "reasoningEffort",
                details:
                  "reasoningEffort is not supported for non-reasoning models",
              }),
            (_ == null ? void 0 : _.reasoningSummary) != null &&
              g.push({
                type: "unsupported-setting",
                setting: "reasoningSummary",
                details:
                  "reasoningSummary is not supported for non-reasoning models",
              })),
          (_ == null ? void 0 : _.serviceTier) === "flex" &&
            !m.supportsFlexProcessing &&
            (g.push({
              type: "unsupported-setting",
              setting: "serviceTier",
              details:
                "flex processing is only available for o3, o4-mini, and gpt-5 models",
            }),
            delete x.service_tier),
          (_ == null ? void 0 : _.serviceTier) === "priority" &&
            !m.supportsPriorityProcessing &&
            (g.push({
              type: "unsupported-setting",
              setting: "serviceTier",
              details:
                "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported",
            }),
            delete x.service_tier);
        const {
          tools: A,
          toolChoice: M,
          toolWarnings: H,
        } = jj({ tools: u, toolChoice: f, strictJsonSchema: w });
        return {
          args: { ...x, tools: A, tool_choice: M },
          warnings: [...g, ...H],
        };
      }
      async doGenerate(t) {
        var e, r, a, n, s, o, i, l, c, u, f, v, d, p, g, m, h;
        const { args: y, warnings: _ } = await this.getArgs(t),
          w = this.config.url({ path: "/responses", modelId: this.modelId }),
          {
            responseHeaders: E,
            value: P,
            rawValue: x,
          } = await xr({
            url: w,
            headers: pr(this.config.headers(), t.headers),
            body: y,
            failedResponseHandler: Jr,
            successfulResponseHandler: Yn(
              O({
                id: S(),
                created_at: K(),
                error: O({ code: S(), message: S() }).nullish(),
                model: S(),
                output: ce(
                  qa("type", [
                    O({
                      type: W("message"),
                      role: W("assistant"),
                      id: S(),
                      content: ce(
                        O({
                          type: W("output_text"),
                          text: S(),
                          logprobs: _0.nullish(),
                          annotations: ce(
                            qa("type", [
                              O({
                                type: W("url_citation"),
                                start_index: K(),
                                end_index: K(),
                                url: S(),
                                title: S(),
                              }),
                              O({
                                type: W("file_citation"),
                                start_index: K(),
                                end_index: K(),
                                file_id: S(),
                                quote: S(),
                              }),
                            ])
                          ),
                        })
                      ),
                    }),
                    O({
                      type: W("function_call"),
                      call_id: S(),
                      name: S(),
                      arguments: S(),
                      id: S(),
                    }),
                    O({
                      type: W("web_search_call"),
                      id: S(),
                      status: S().optional(),
                      action: O({
                        type: W("search"),
                        query: S().optional(),
                      }).nullish(),
                    }),
                    O({
                      type: W("computer_call"),
                      id: S(),
                      status: S().optional(),
                    }),
                    O({
                      type: W("file_search_call"),
                      id: S(),
                      status: S().optional(),
                      queries: ce(S()).nullish(),
                      results: ce(
                        O({
                          attributes: O({
                            file_id: S(),
                            filename: S(),
                            score: K(),
                            text: S(),
                          }),
                        })
                      ).nullish(),
                    }),
                    O({
                      type: W("reasoning"),
                      id: S(),
                      encrypted_content: S().nullish(),
                      summary: ce(O({ type: W("summary_text"), text: S() })),
                    }),
                  ])
                ),
                incomplete_details: O({ reason: S() }).nullable(),
                usage: w0,
              })
            ),
            abortSignal: t.abortSignal,
            fetch: this.config.fetch,
          });
        if (P.error)
          throw new Xe({
            message: P.error.message,
            url: w,
            requestBodyValues: y,
            statusCode: 400,
            responseHeaders: E,
            responseBody: x,
            isRetryable: !1,
          });
        const A = [],
          M = [];
        for (const V of P.output)
          switch (V.type) {
            case "reasoning": {
              V.summary.length === 0 &&
                V.summary.push({ type: "summary_text", text: "" });
              for (const J of V.summary)
                A.push({
                  type: "reasoning",
                  text: J.text,
                  providerMetadata: {
                    openai: {
                      itemId: V.id,
                      reasoningEncryptedContent:
                        (e = V.encrypted_content) != null ? e : null,
                    },
                  },
                });
              break;
            }
            case "message": {
              for (const J of V.content) {
                (a = (r = t.providerOptions) == null ? void 0 : r.openai) !=
                  null &&
                  a.logprobs &&
                  J.logprobs &&
                  M.push(J.logprobs),
                  A.push({
                    type: "text",
                    text: J.text,
                    providerMetadata: { openai: { itemId: V.id } },
                  });
                for (const z of J.annotations)
                  z.type === "url_citation"
                    ? A.push({
                        type: "source",
                        sourceType: "url",
                        id:
                          (o =
                            (s = (n = this.config).generateId) == null
                              ? void 0
                              : s.call(n)) != null
                            ? o
                            : sr(),
                        url: z.url,
                        title: z.title,
                      })
                    : z.type === "file_citation" &&
                      A.push({
                        type: "source",
                        sourceType: "document",
                        id:
                          (c =
                            (l = (i = this.config).generateId) == null
                              ? void 0
                              : l.call(i)) != null
                            ? c
                            : sr(),
                        mediaType: "text/plain",
                        title: z.quote,
                        filename: z.file_id,
                      });
              }
              break;
            }
            case "function_call": {
              A.push({
                type: "tool-call",
                toolCallId: V.call_id,
                toolName: V.name,
                input: V.arguments,
                providerMetadata: { openai: { itemId: V.id } },
              });
              break;
            }
            case "web_search_call": {
              A.push({
                type: "tool-call",
                toolCallId: V.id,
                toolName: "web_search_preview",
                input:
                  (f = (u = V.action) == null ? void 0 : u.query) != null
                    ? f
                    : "",
                providerExecuted: !0,
              }),
                A.push({
                  type: "tool-result",
                  toolCallId: V.id,
                  toolName: "web_search_preview",
                  result: {
                    status: V.status || "completed",
                    ...(((v = V.action) == null ? void 0 : v.query) && {
                      query: V.action.query,
                    }),
                  },
                  providerExecuted: !0,
                });
              break;
            }
            case "computer_call": {
              A.push({
                type: "tool-call",
                toolCallId: V.id,
                toolName: "computer_use",
                input: "",
                providerExecuted: !0,
              }),
                A.push({
                  type: "tool-result",
                  toolCallId: V.id,
                  toolName: "computer_use",
                  result: {
                    type: "computer_use_tool_result",
                    status: V.status || "completed",
                  },
                  providerExecuted: !0,
                });
              break;
            }
            case "file_search_call": {
              A.push({
                type: "tool-call",
                toolCallId: V.id,
                toolName: "file_search",
                input: "",
                providerExecuted: !0,
              }),
                A.push({
                  type: "tool-result",
                  toolCallId: V.id,
                  toolName: "file_search",
                  result: {
                    type: "file_search_tool_result",
                    status: V.status || "completed",
                    ...(V.queries && { queries: V.queries }),
                    ...(V.results && { results: V.results }),
                  },
                  providerExecuted: !0,
                });
              break;
            }
          }
        const H = { openai: { responseId: P.id } };
        return (
          M.length > 0 && (H.openai.logprobs = M),
          {
            content: A,
            finishReason: g0({
              finishReason:
                (d = P.incomplete_details) == null ? void 0 : d.reason,
              hasToolCalls: A.some((V) => V.type === "tool-call"),
            }),
            usage: {
              inputTokens: P.usage.input_tokens,
              outputTokens: P.usage.output_tokens,
              totalTokens: P.usage.input_tokens + P.usage.output_tokens,
              reasoningTokens:
                (g =
                  (p = P.usage.output_tokens_details) == null
                    ? void 0
                    : p.reasoning_tokens) != null
                  ? g
                  : void 0,
              cachedInputTokens:
                (h =
                  (m = P.usage.input_tokens_details) == null
                    ? void 0
                    : m.cached_tokens) != null
                  ? h
                  : void 0,
            },
            request: { body: y },
            response: {
              id: P.id,
              timestamp: new Date(P.created_at * 1e3),
              modelId: P.model,
              headers: E,
              body: x,
            },
            providerMetadata: H,
            warnings: _,
          }
        );
      }
      async doStream(t) {
        const { args: e, warnings: r } = await this.getArgs(t),
          { responseHeaders: a, value: n } = await xr({
            url: this.config.url({ path: "/responses", modelId: this.modelId }),
            headers: pr(this.config.headers(), t.headers),
            body: { ...e, stream: !0 },
            failedResponseHandler: Jr,
            successfulResponseHandler: fl(Kj),
            abortSignal: t.abortSignal,
            fetch: this.config.fetch,
          }),
          s = this;
        let o = "unknown";
        const i = {
            inputTokens: void 0,
            outputTokens: void 0,
            totalTokens: void 0,
          },
          l = [];
        let c = null;
        const u = {};
        let f = !1;
        const v = {};
        return {
          stream: n.pipeThrough(
            new TransformStream({
              start(d) {
                d.enqueue({ type: "stream-start", warnings: r });
              },
              transform(d, p) {
                var g, m, h, y, _, w, E, P, x, A, M, H, V, J, z, Z, te, me, ge;
                if (
                  (t.includeRawChunks &&
                    p.enqueue({ type: "raw", rawValue: d.rawValue }),
                  !d.success)
                ) {
                  (o = "error"), p.enqueue({ type: "error", error: d.error });
                  return;
                }
                const N = d.value;
                if (E0(N))
                  N.item.type === "function_call"
                    ? ((u[N.output_index] = {
                        toolName: N.item.name,
                        toolCallId: N.item.call_id,
                      }),
                      p.enqueue({
                        type: "tool-input-start",
                        id: N.item.call_id,
                        toolName: N.item.name,
                      }))
                    : N.item.type === "web_search_call"
                    ? ((u[N.output_index] = {
                        toolName: "web_search_preview",
                        toolCallId: N.item.id,
                      }),
                      p.enqueue({
                        type: "tool-input-start",
                        id: N.item.id,
                        toolName: "web_search_preview",
                      }))
                    : N.item.type === "computer_call"
                    ? ((u[N.output_index] = {
                        toolName: "computer_use",
                        toolCallId: N.item.id,
                      }),
                      p.enqueue({
                        type: "tool-input-start",
                        id: N.item.id,
                        toolName: "computer_use",
                      }))
                    : N.item.type === "file_search_call"
                    ? ((u[N.output_index] = {
                        toolName: "file_search",
                        toolCallId: N.item.id,
                      }),
                      p.enqueue({
                        type: "tool-input-start",
                        id: N.item.id,
                        toolName: "file_search",
                      }))
                    : N.item.type === "message"
                    ? p.enqueue({
                        type: "text-start",
                        id: N.item.id,
                        providerMetadata: { openai: { itemId: N.item.id } },
                      })
                    : eD(N) &&
                      ((v[N.item.id] = {
                        encryptedContent: N.item.encrypted_content,
                        summaryParts: [0],
                      }),
                      p.enqueue({
                        type: "reasoning-start",
                        id: `${N.item.id}:0`,
                        providerMetadata: {
                          openai: {
                            itemId: N.item.id,
                            reasoningEncryptedContent:
                              (g = N.item.encrypted_content) != null ? g : null,
                          },
                        },
                      }));
                else if (b0(N)) {
                  if (N.item.type === "function_call")
                    (u[N.output_index] = void 0),
                      (f = !0),
                      p.enqueue({ type: "tool-input-end", id: N.item.call_id }),
                      p.enqueue({
                        type: "tool-call",
                        toolCallId: N.item.call_id,
                        toolName: N.item.name,
                        input: N.item.arguments,
                        providerMetadata: { openai: { itemId: N.item.id } },
                      });
                  else if (N.item.type === "web_search_call")
                    (u[N.output_index] = void 0),
                      (f = !0),
                      p.enqueue({ type: "tool-input-end", id: N.item.id }),
                      p.enqueue({
                        type: "tool-call",
                        toolCallId: N.item.id,
                        toolName: "web_search_preview",
                        input:
                          (h =
                            (m = N.item.action) == null ? void 0 : m.query) !=
                          null
                            ? h
                            : "",
                        providerExecuted: !0,
                      }),
                      p.enqueue({
                        type: "tool-result",
                        toolCallId: N.item.id,
                        toolName: "web_search_preview",
                        result: {
                          type: "web_search_tool_result",
                          status: N.item.status || "completed",
                          ...(((y = N.item.action) == null
                            ? void 0
                            : y.query) && { query: N.item.action.query }),
                        },
                        providerExecuted: !0,
                      });
                  else if (N.item.type === "computer_call")
                    (u[N.output_index] = void 0),
                      (f = !0),
                      p.enqueue({ type: "tool-input-end", id: N.item.id }),
                      p.enqueue({
                        type: "tool-call",
                        toolCallId: N.item.id,
                        toolName: "computer_use",
                        input: "",
                        providerExecuted: !0,
                      }),
                      p.enqueue({
                        type: "tool-result",
                        toolCallId: N.item.id,
                        toolName: "computer_use",
                        result: {
                          type: "computer_use_tool_result",
                          status: N.item.status || "completed",
                        },
                        providerExecuted: !0,
                      });
                  else if (N.item.type === "file_search_call")
                    (u[N.output_index] = void 0),
                      (f = !0),
                      p.enqueue({ type: "tool-input-end", id: N.item.id }),
                      p.enqueue({
                        type: "tool-call",
                        toolCallId: N.item.id,
                        toolName: "file_search",
                        input: "",
                        providerExecuted: !0,
                      }),
                      p.enqueue({
                        type: "tool-result",
                        toolCallId: N.item.id,
                        toolName: "file_search",
                        result: {
                          type: "file_search_tool_result",
                          status: N.item.status || "completed",
                          ...(N.item.queries && { queries: N.item.queries }),
                          ...(N.item.results && { results: N.item.results }),
                        },
                        providerExecuted: !0,
                      });
                  else if (N.item.type === "message")
                    p.enqueue({ type: "text-end", id: N.item.id });
                  else if (Wj(N)) {
                    const se = v[N.item.id];
                    for (const D of se.summaryParts)
                      p.enqueue({
                        type: "reasoning-end",
                        id: `${N.item.id}:${D}`,
                        providerMetadata: {
                          openai: {
                            itemId: N.item.id,
                            reasoningEncryptedContent:
                              (_ = N.item.encrypted_content) != null ? _ : null,
                          },
                        },
                      });
                    delete v[N.item.id];
                  }
                } else if (Xj(N)) {
                  const se = u[N.output_index];
                  se != null &&
                    p.enqueue({
                      type: "tool-input-delta",
                      id: se.toolCallId,
                      delta: N.delta,
                    });
                } else
                  Yj(N)
                    ? ((c = N.response.id),
                      p.enqueue({
                        type: "response-metadata",
                        id: N.response.id,
                        timestamp: new Date(N.response.created_at * 1e3),
                        modelId: N.response.model,
                      }))
                    : Gj(N)
                    ? (p.enqueue({
                        type: "text-delta",
                        id: N.item_id,
                        delta: N.delta,
                      }),
                      N.logprobs && l.push(N.logprobs))
                    : rD(N)
                    ? N.summary_index > 0 &&
                      ((w = v[N.item_id]) == null ||
                        w.summaryParts.push(N.summary_index),
                      p.enqueue({
                        type: "reasoning-start",
                        id: `${N.item_id}:${N.summary_index}`,
                        providerMetadata: {
                          openai: {
                            itemId: N.item_id,
                            reasoningEncryptedContent:
                              (P =
                                (E = v[N.item_id]) == null
                                  ? void 0
                                  : E.encryptedContent) != null
                                ? P
                                : null,
                          },
                        },
                      }))
                    : nD(N)
                    ? p.enqueue({
                        type: "reasoning-delta",
                        id: `${N.item_id}:${N.summary_index}`,
                        delta: N.delta,
                        providerMetadata: { openai: { itemId: N.item_id } },
                      })
                    : Qj(N)
                    ? ((o = g0({
                        finishReason:
                          (x = N.response.incomplete_details) == null
                            ? void 0
                            : x.reason,
                        hasToolCalls: f,
                      })),
                      (i.inputTokens = N.response.usage.input_tokens),
                      (i.outputTokens = N.response.usage.output_tokens),
                      (i.totalTokens =
                        N.response.usage.input_tokens +
                        N.response.usage.output_tokens),
                      (i.reasoningTokens =
                        (M =
                          (A = N.response.usage.output_tokens_details) == null
                            ? void 0
                            : A.reasoning_tokens) != null
                          ? M
                          : void 0),
                      (i.cachedInputTokens =
                        (V =
                          (H = N.response.usage.input_tokens_details) == null
                            ? void 0
                            : H.cached_tokens) != null
                          ? V
                          : void 0))
                    : tD(N)
                    ? N.annotation.type === "url_citation"
                      ? p.enqueue({
                          type: "source",
                          sourceType: "url",
                          id:
                            (Z =
                              (z = (J = s.config).generateId) == null
                                ? void 0
                                : z.call(J)) != null
                              ? Z
                              : sr(),
                          url: N.annotation.url,
                          title: N.annotation.title,
                        })
                      : N.annotation.type === "file_citation" &&
                        p.enqueue({
                          type: "source",
                          sourceType: "document",
                          id:
                            (ge =
                              (me = (te = s.config).generateId) == null
                                ? void 0
                                : me.call(te)) != null
                              ? ge
                              : sr(),
                          mediaType: "text/plain",
                          title: N.annotation.quote,
                          filename: N.annotation.file_id,
                        })
                    : aD(N) && p.enqueue({ type: "error", error: N });
              },
              flush(d) {
                const p = { openai: { responseId: c } };
                l.length > 0 && (p.openai.logprobs = l),
                  d.enqueue({
                    type: "finish",
                    finishReason: o,
                    usage: i,
                    providerMetadata: p,
                  });
              },
            })
          ),
          request: { body: e },
          response: { headers: a },
        };
      }
    },
    w0 = O({
      input_tokens: K(),
      input_tokens_details: O({ cached_tokens: K().nullish() }).nullish(),
      output_tokens: K(),
      output_tokens_details: O({ reasoning_tokens: K().nullish() }).nullish(),
    }),
    Lj = O({
      type: W("response.output_text.delta"),
      item_id: S(),
      delta: S(),
      logprobs: _0.nullish(),
    }),
    zj = O({
      type: W("error"),
      code: S(),
      message: S(),
      param: S().nullish(),
      sequence_number: K(),
    }),
    qj = O({
      type: Vt(["response.completed", "response.incomplete"]),
      response: O({
        incomplete_details: O({ reason: S() }).nullish(),
        usage: w0,
      }),
    }),
    Uj = O({
      type: W("response.created"),
      response: O({ id: S(), created_at: K(), model: S() }),
    }),
    Fj = O({
      type: W("response.output_item.added"),
      output_index: K(),
      item: qa("type", [
        O({ type: W("message"), id: S() }),
        O({ type: W("reasoning"), id: S(), encrypted_content: S().nullish() }),
        O({
          type: W("function_call"),
          id: S(),
          call_id: S(),
          name: S(),
          arguments: S(),
        }),
        O({
          type: W("web_search_call"),
          id: S(),
          status: S(),
          action: O({ type: W("search"), query: S().optional() }).nullish(),
        }),
        O({ type: W("computer_call"), id: S(), status: S() }),
        O({
          type: W("file_search_call"),
          id: S(),
          status: S(),
          queries: ce(S()).nullish(),
          results: ce(
            O({
              attributes: O({
                file_id: S(),
                filename: S(),
                score: K(),
                text: S(),
              }),
            })
          ).optional(),
        }),
      ]),
    }),
    Vj = O({
      type: W("response.output_item.done"),
      output_index: K(),
      item: qa("type", [
        O({ type: W("message"), id: S() }),
        O({ type: W("reasoning"), id: S(), encrypted_content: S().nullish() }),
        O({
          type: W("function_call"),
          id: S(),
          call_id: S(),
          name: S(),
          arguments: S(),
          status: W("completed"),
        }),
        O({
          type: W("web_search_call"),
          id: S(),
          status: W("completed"),
          action: O({ type: W("search"), query: S().optional() }).nullish(),
        }),
        O({ type: W("computer_call"), id: S(), status: W("completed") }),
        O({
          type: W("file_search_call"),
          id: S(),
          status: W("completed"),
          queries: ce(S()).nullish(),
          results: ce(
            O({
              attributes: O({
                file_id: S(),
                filename: S(),
                score: K(),
                text: S(),
              }),
            })
          ).nullish(),
        }),
      ]),
    }),
    Zj = O({
      type: W("response.function_call_arguments.delta"),
      item_id: S(),
      output_index: K(),
      delta: S(),
    }),
    Hj = O({
      type: W("response.output_text.annotation.added"),
      annotation: qa("type", [
        O({ type: W("url_citation"), url: S(), title: S() }),
        O({ type: W("file_citation"), file_id: S(), quote: S() }),
      ]),
    }),
    Bj = O({
      type: W("response.reasoning_summary_part.added"),
      item_id: S(),
      summary_index: K(),
    }),
    Jj = O({
      type: W("response.reasoning_summary_text.delta"),
      item_id: S(),
      summary_index: K(),
      delta: S(),
    }),
    Kj = Fe([Lj, qj, Uj, Fj, Vj, Zj, Hj, Bj, Jj, zj, O({ type: S() }).loose()]);
  function Gj(t) {
    return t.type === "response.output_text.delta";
  }
  function b0(t) {
    return t.type === "response.output_item.done";
  }
  function Wj(t) {
    return b0(t) && t.item.type === "reasoning";
  }
  function Qj(t) {
    return t.type === "response.completed" || t.type === "response.incomplete";
  }
  function Yj(t) {
    return t.type === "response.created";
  }
  function Xj(t) {
    return t.type === "response.function_call_arguments.delta";
  }
  function E0(t) {
    return t.type === "response.output_item.added";
  }
  function eD(t) {
    return E0(t) && t.item.type === "reasoning";
  }
  function tD(t) {
    return t.type === "response.output_text.annotation.added";
  }
  function rD(t) {
    return t.type === "response.reasoning_summary_part.added";
  }
  function nD(t) {
    return t.type === "response.reasoning_summary_text.delta";
  }
  function aD(t) {
    return t.type === "error";
  }
  function sD(t) {
    const e =
        t.startsWith("o3") ||
        t.startsWith("o4-mini") ||
        (t.startsWith("gpt-5") && !t.startsWith("gpt-5-chat")),
      r =
        t.startsWith("gpt-4") ||
        t.startsWith("gpt-5-mini") ||
        (t.startsWith("gpt-5") &&
          !t.startsWith("gpt-5-nano") &&
          !t.startsWith("gpt-5-chat")) ||
        t.startsWith("o3") ||
        t.startsWith("o4-mini"),
      a = {
        requiredAutoTruncation: !1,
        systemMessageMode: "system",
        supportsFlexProcessing: e,
        supportsPriorityProcessing: r,
      };
    return t.startsWith("gpt-5-chat")
      ? { ...a, isReasoningModel: !1 }
      : t.startsWith("o") ||
        t.startsWith("gpt-5") ||
        t.startsWith("codex-") ||
        t.startsWith("computer-use")
      ? t.startsWith("o1-mini") || t.startsWith("o1-preview")
        ? { ...a, isReasoningModel: !0, systemMessageMode: "remove" }
        : { ...a, isReasoningModel: !0, systemMessageMode: "developer" }
      : { ...a, isReasoningModel: !1 };
  }
  var oD = O({
      metadata: Tr().nullish(),
      parallelToolCalls: Ve().nullish(),
      previousResponseId: S().nullish(),
      store: Ve().nullish(),
      user: S().nullish(),
      reasoningEffort: S().nullish(),
      strictJsonSchema: Ve().nullish(),
      instructions: S().nullish(),
      reasoningSummary: S().nullish(),
      serviceTier: Vt(["auto", "flex", "priority"]).nullish(),
      include: ce(
        Vt([
          "reasoning.encrypted_content",
          "file_search_call.results",
          "message.output_text.logprobs",
        ])
      ).nullish(),
      textVerbosity: Vt(["low", "medium", "high"]).nullish(),
      promptCacheKey: S().nullish(),
      safetyIdentifier: S().nullish(),
      logprobs: Fe([Ve(), K().min(1).max(y0)]).optional(),
    }),
    iD = O({
      instructions: S().nullish(),
      speed: K().min(0.25).max(4).default(1).nullish(),
    }),
    lD = class {
      constructor(t, e) {
        (this.modelId = t),
          (this.config = e),
          (this.specificationVersion = "v2");
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        text: t,
        voice: e = "alloy",
        outputFormat: r = "mp3",
        speed: a,
        instructions: n,
        language: s,
        providerOptions: o,
      }) {
        const i = [],
          l = await Br({ provider: "openai", providerOptions: o, schema: iD }),
          c = {
            model: this.modelId,
            input: t,
            voice: e,
            response_format: "mp3",
            speed: a,
            instructions: n,
          };
        if (
          (r &&
            (["mp3", "opus", "aac", "flac", "wav", "pcm"].includes(r)
              ? (c.response_format = r)
              : i.push({
                  type: "unsupported-setting",
                  setting: "outputFormat",
                  details: `Unsupported output format: ${r}. Using mp3 instead.`,
                })),
          l)
        ) {
          const u = {};
          for (const f in u) {
            const v = u[f];
            v !== void 0 && (c[f] = v);
          }
        }
        return (
          s &&
            i.push({
              type: "unsupported-setting",
              setting: "language",
              details: `OpenAI speech models do not support language selection. Language parameter "${s}" was ignored.`,
            }),
          { requestBody: c, warnings: i }
        );
      }
      async doGenerate(t) {
        var e, r, a;
        const n =
            (a =
              (r =
                (e = this.config._internal) == null ? void 0 : e.currentDate) ==
              null
                ? void 0
                : r.call(e)) != null
              ? a
              : new Date(),
          { requestBody: s, warnings: o } = await this.getArgs(t),
          {
            value: i,
            responseHeaders: l,
            rawValue: c,
          } = await xr({
            url: this.config.url({
              path: "/audio/speech",
              modelId: this.modelId,
            }),
            headers: pr(this.config.headers(), t.headers),
            body: s,
            failedResponseHandler: Jr,
            successfulResponseHandler: rj(),
            abortSignal: t.abortSignal,
            fetch: this.config.fetch,
          });
        return {
          audio: i,
          warnings: o,
          request: { body: JSON.stringify(s) },
          response: {
            timestamp: n,
            modelId: this.modelId,
            headers: l,
            body: c,
          },
        };
      }
    },
    cD = O({
      include: ce(S()).optional(),
      language: S().optional(),
      prompt: S().optional(),
      temperature: K().min(0).max(1).default(0).optional(),
      timestampGranularities: ce(Vt(["word", "segment"]))
        .default(["segment"])
        .optional(),
    }),
    S0 = {
      afrikaans: "af",
      arabic: "ar",
      armenian: "hy",
      azerbaijani: "az",
      belarusian: "be",
      bosnian: "bs",
      bulgarian: "bg",
      catalan: "ca",
      chinese: "zh",
      croatian: "hr",
      czech: "cs",
      danish: "da",
      dutch: "nl",
      english: "en",
      estonian: "et",
      finnish: "fi",
      french: "fr",
      galician: "gl",
      german: "de",
      greek: "el",
      hebrew: "he",
      hindi: "hi",
      hungarian: "hu",
      icelandic: "is",
      indonesian: "id",
      italian: "it",
      japanese: "ja",
      kannada: "kn",
      kazakh: "kk",
      korean: "ko",
      latvian: "lv",
      lithuanian: "lt",
      macedonian: "mk",
      malay: "ms",
      marathi: "mr",
      maori: "mi",
      nepali: "ne",
      norwegian: "no",
      persian: "fa",
      polish: "pl",
      portuguese: "pt",
      romanian: "ro",
      russian: "ru",
      serbian: "sr",
      slovak: "sk",
      slovenian: "sl",
      spanish: "es",
      swahili: "sw",
      swedish: "sv",
      tagalog: "tl",
      tamil: "ta",
      thai: "th",
      turkish: "tr",
      ukrainian: "uk",
      urdu: "ur",
      vietnamese: "vi",
      welsh: "cy",
    },
    uD = class {
      constructor(t, e) {
        (this.modelId = t),
          (this.config = e),
          (this.specificationVersion = "v2");
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({ audio: t, mediaType: e, providerOptions: r }) {
        const a = [],
          n = await Br({ provider: "openai", providerOptions: r, schema: cD }),
          s = new FormData(),
          o = t instanceof Uint8Array ? new Blob([t]) : new Blob([sj(t)]);
        if (
          (s.append("model", this.modelId),
          s.append("file", new File([o], "audio", { type: e })),
          n)
        ) {
          const i = {
            include: n.include,
            language: n.language,
            prompt: n.prompt,
            response_format: "verbose_json",
            temperature: n.temperature,
            timestamp_granularities: n.timestampGranularities,
          };
          for (const [l, c] of Object.entries(i))
            c != null && s.append(l, String(c));
        }
        return { formData: s, warnings: a };
      }
      async doGenerate(t) {
        var e, r, a, n, s, o, i, l;
        const c =
            (a =
              (r =
                (e = this.config._internal) == null ? void 0 : e.currentDate) ==
              null
                ? void 0
                : r.call(e)) != null
              ? a
              : new Date(),
          { formData: u, warnings: f } = await this.getArgs(t),
          {
            value: v,
            responseHeaders: d,
            rawValue: p,
          } = await tj({
            url: this.config.url({
              path: "/audio/transcriptions",
              modelId: this.modelId,
            }),
            headers: pr(this.config.headers(), t.headers),
            formData: u,
            failedResponseHandler: Jr,
            successfulResponseHandler: Yn(dD),
            abortSignal: t.abortSignal,
            fetch: this.config.fetch,
          }),
          g = v.language != null && v.language in S0 ? S0[v.language] : void 0;
        return {
          text: v.text,
          segments:
            (i =
              (o =
                (n = v.segments) == null
                  ? void 0
                  : n.map((m) => ({
                      text: m.text,
                      startSecond: m.start,
                      endSecond: m.end,
                    }))) != null
                ? o
                : (s = v.words) == null
                ? void 0
                : s.map((m) => ({
                    text: m.word,
                    startSecond: m.start,
                    endSecond: m.end,
                  }))) != null
              ? i
              : [],
          language: g,
          durationInSeconds: (l = v.duration) != null ? l : void 0,
          warnings: f,
          response: {
            timestamp: c,
            modelId: this.modelId,
            headers: d,
            body: p,
          },
        };
      }
    },
    dD = O({
      text: S(),
      language: S().nullish(),
      duration: K().nullish(),
      words: ce(O({ word: S(), start: K(), end: K() })).nullish(),
      segments: ce(
        O({
          id: K(),
          seek: K(),
          start: K(),
          end: K(),
          text: S(),
          tokens: ce(K()),
          temperature: K(),
          avg_logprob: K(),
          compression_ratio: K(),
          no_speech_prob: K(),
        })
      ).nullish(),
    });
  function $0(t = {}) {
    var e, r;
    const a = (e = n0(t.baseURL)) != null ? e : "https://api.openai.com/v1",
      n = (r = t.name) != null ? r : "openai",
      s = () => ({
        Authorization: `Bearer ${X_({
          apiKey: t.apiKey,
          environmentVariableName: "OPENAI_API_KEY",
          description: "OpenAI",
        })}`,
        "OpenAI-Organization": t.organization,
        "OpenAI-Project": t.project,
        ...t.headers,
      }),
      o = (g) =>
        new pj(g, {
          provider: `${n}.chat`,
          url: ({ path: m }) => `${a}${m}`,
          headers: s,
          fetch: t.fetch,
        }),
      i = (g) =>
        new bj(g, {
          provider: `${n}.completion`,
          url: ({ path: m }) => `${a}${m}`,
          headers: s,
          fetch: t.fetch,
        }),
      l = (g) =>
        new Pj(g, {
          provider: `${n}.embedding`,
          url: ({ path: m }) => `${a}${m}`,
          headers: s,
          fetch: t.fetch,
        }),
      c = (g) =>
        new kj(g, {
          provider: `${n}.image`,
          url: ({ path: m }) => `${a}${m}`,
          headers: s,
          fetch: t.fetch,
        }),
      u = (g) =>
        new uD(g, {
          provider: `${n}.transcription`,
          url: ({ path: m }) => `${a}${m}`,
          headers: s,
          fetch: t.fetch,
        }),
      f = (g) =>
        new lD(g, {
          provider: `${n}.speech`,
          url: ({ path: m }) => `${a}${m}`,
          headers: s,
          fetch: t.fetch,
        }),
      v = (g) => {
        if (new.target)
          throw new Error(
            "The OpenAI model function cannot be called with the new keyword."
          );
        return d(g);
      },
      d = (g) =>
        new Dj(g, {
          provider: `${n}.responses`,
          url: ({ path: m }) => `${a}${m}`,
          headers: s,
          fetch: t.fetch,
          fileIdPrefixes: ["file-"],
        }),
      p = function (g) {
        return v(g);
      };
    return (
      (p.languageModel = v),
      (p.chat = o),
      (p.completion = i),
      (p.responses = d),
      (p.embedding = l),
      (p.textEmbedding = l),
      (p.textEmbeddingModel = l),
      (p.image = c),
      (p.imageModel = c),
      (p.transcription = u),
      (p.transcriptionModel = u),
      (p.speech = f),
      (p.speechModel = f),
      (p.tools = Aj),
      p
    );
  }
  $0();
  function oo(t) {
    var e, r;
    return (r =
      (e = t == null ? void 0 : t.providerOptions) == null
        ? void 0
        : e.openaiCompatible) != null
      ? r
      : {};
  }
  function fD(t) {
    const e = [];
    for (const { role: r, content: a, ...n } of t) {
      const s = oo({ ...n });
      switch (r) {
        case "system": {
          e.push({ role: "system", content: a, ...s });
          break;
        }
        case "user": {
          if (a.length === 1 && a[0].type === "text") {
            e.push({ role: "user", content: a[0].text, ...oo(a[0]) });
            break;
          }
          e.push({
            role: "user",
            content: a.map((o) => {
              const i = oo(o);
              switch (o.type) {
                case "text":
                  return { type: "text", text: o.text, ...i };
                case "file":
                  if (o.mediaType.startsWith("image/")) {
                    const l =
                      o.mediaType === "image/*" ? "image/jpeg" : o.mediaType;
                    return {
                      type: "image_url",
                      image_url: {
                        url:
                          o.data instanceof URL
                            ? o.data.toString()
                            : `data:${l};base64,${Xn(o.data)}`,
                      },
                      ...i,
                    };
                  } else
                    throw new dr({
                      functionality: `file part media type ${o.mediaType}`,
                    });
              }
            }),
            ...s,
          });
          break;
        }
        case "assistant": {
          let o = "";
          const i = [];
          for (const l of a) {
            const c = oo(l);
            switch (l.type) {
              case "text": {
                o += l.text;
                break;
              }
              case "tool-call": {
                i.push({
                  id: l.toolCallId,
                  type: "function",
                  function: {
                    name: l.toolName,
                    arguments: JSON.stringify(l.input),
                  },
                  ...c,
                });
                break;
              }
            }
          }
          e.push({
            role: "assistant",
            content: o,
            tool_calls: i.length > 0 ? i : void 0,
            ...s,
          });
          break;
        }
        case "tool": {
          for (const o of a) {
            const i = o.output;
            let l;
            switch (i.type) {
              case "text":
              case "error-text":
                l = i.value;
                break;
              case "content":
              case "json":
              case "error-json":
                l = JSON.stringify(i.value);
                break;
            }
            const c = oo(o);
            e.push({
              role: "tool",
              tool_call_id: o.toolCallId,
              content: l,
              ...c,
            });
          }
          break;
        }
        default: {
          const o = r;
          throw new Error(`Unsupported role: ${o}`);
        }
      }
    }
    return e;
  }
  function P0({ id: t, model: e, created: r }) {
    return {
      id: t ?? void 0,
      modelId: e ?? void 0,
      timestamp: r != null ? new Date(r * 1e3) : void 0,
    };
  }
  function T0(t) {
    switch (t) {
      case "stop":
        return "stop";
      case "length":
        return "length";
      case "content_filter":
        return "content-filter";
      case "function_call":
      case "tool_calls":
        return "tool-calls";
      default:
        return "unknown";
    }
  }
  var x0 = O({ user: S().optional(), reasoningEffort: S().optional() }),
    pD = O({
      error: O({
        message: S(),
        type: S().nullish(),
        param: Tr().nullish(),
        code: Fe([S(), K()]).nullish(),
      }),
    }),
    hD = { errorSchema: pD, errorToMessage: (t) => t.error.message };
  function mD({ tools: t, toolChoice: e }) {
    t = t != null && t.length ? t : void 0;
    const r = [];
    if (t == null)
      return { tools: void 0, toolChoice: void 0, toolWarnings: r };
    const a = [];
    for (const s of t)
      s.type === "provider-defined"
        ? r.push({ type: "unsupported-tool", tool: s })
        : a.push({
            type: "function",
            function: {
              name: s.name,
              description: s.description,
              parameters: s.inputSchema,
            },
          });
    if (e == null) return { tools: a, toolChoice: void 0, toolWarnings: r };
    const n = e.type;
    switch (n) {
      case "auto":
      case "none":
      case "required":
        return { tools: a, toolChoice: n, toolWarnings: r };
      case "tool":
        return {
          tools: a,
          toolChoice: { type: "function", function: { name: e.toolName } },
          toolWarnings: r,
        };
      default: {
        const s = n;
        throw new dr({ functionality: `tool choice type: ${s}` });
      }
    }
  }
  var vD = class {
      constructor(t, e) {
        this.specificationVersion = "v2";
        var r, a;
        (this.modelId = t), (this.config = e);
        const n = (r = e.errorStructure) != null ? r : hD;
        (this.chunkSchema = yD(n.errorSchema)),
          (this.failedResponseHandler = r0(n)),
          (this.supportsStructuredOutputs =
            (a = e.supportsStructuredOutputs) != null ? a : !1);
      }
      get provider() {
        return this.config.provider;
      }
      get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
      }
      get supportedUrls() {
        var t, e, r;
        return (r =
          (e = (t = this.config).supportedUrls) == null ? void 0 : e.call(t)) !=
          null
          ? r
          : {};
      }
      async getArgs({
        prompt: t,
        maxOutputTokens: e,
        temperature: r,
        topP: a,
        topK: n,
        frequencyPenalty: s,
        presencePenalty: o,
        providerOptions: i,
        stopSequences: l,
        responseFormat: c,
        seed: u,
        toolChoice: f,
        tools: v,
      }) {
        var d, p, g;
        const m = [],
          h = Object.assign(
            (d = await Br({
              provider: "openai-compatible",
              providerOptions: i,
              schema: x0,
            })) != null
              ? d
              : {},
            (p = await Br({
              provider: this.providerOptionsName,
              providerOptions: i,
              schema: x0,
            })) != null
              ? p
              : {}
          );
        n != null && m.push({ type: "unsupported-setting", setting: "topK" }),
          (c == null ? void 0 : c.type) === "json" &&
            c.schema != null &&
            !this.supportsStructuredOutputs &&
            m.push({
              type: "unsupported-setting",
              setting: "responseFormat",
              details:
                "JSON response format schema is only supported with structuredOutputs",
            });
        const {
          tools: y,
          toolChoice: _,
          toolWarnings: w,
        } = mD({ tools: v, toolChoice: f });
        return {
          args: {
            model: this.modelId,
            user: h.user,
            max_tokens: e,
            temperature: r,
            top_p: a,
            frequency_penalty: s,
            presence_penalty: o,
            response_format:
              (c == null ? void 0 : c.type) === "json"
                ? this.supportsStructuredOutputs === !0 && c.schema != null
                  ? {
                      type: "json_schema",
                      json_schema: {
                        schema: c.schema,
                        name: (g = c.name) != null ? g : "response",
                        description: c.description,
                      },
                    }
                  : { type: "json_object" }
                : void 0,
            stop: l,
            seed: u,
            ...(i == null ? void 0 : i[this.providerOptionsName]),
            reasoning_effort: h.reasoningEffort,
            messages: fD(t),
            tools: y,
            tool_choice: _,
          },
          warnings: [...m, ...w],
        };
      }
      async doGenerate(t) {
        var e, r, a, n, s, o, i, l, c, u, f, v, d, p, g, m, h;
        const { args: y, warnings: _ } = await this.getArgs({ ...t }),
          w = JSON.stringify(y),
          {
            responseHeaders: E,
            value: P,
            rawValue: x,
          } = await xr({
            url: this.config.url({
              path: "/chat/completions",
              modelId: this.modelId,
            }),
            headers: pr(this.config.headers(), t.headers),
            body: y,
            failedResponseHandler: this.failedResponseHandler,
            successfulResponseHandler: Yn(gD),
            abortSignal: t.abortSignal,
            fetch: this.config.fetch,
          }),
          A = P.choices[0],
          M = [],
          H = A.message.content;
        H != null && H.length > 0 && M.push({ type: "text", text: H });
        const V =
          (e = A.message.reasoning_content) != null ? e : A.message.reasoning;
        if (
          (V != null && V.length > 0 && M.push({ type: "reasoning", text: V }),
          A.message.tool_calls != null)
        )
          for (const Z of A.message.tool_calls)
            M.push({
              type: "tool-call",
              toolCallId: (r = Z.id) != null ? r : sr(),
              toolName: Z.function.name,
              input: Z.function.arguments,
            });
        const J = {
            [this.providerOptionsName]: {},
            ...(await ((n =
              (a = this.config.metadataExtractor) == null
                ? void 0
                : a.extractMetadata) == null
              ? void 0
              : n.call(a, { parsedBody: x }))),
          },
          z = (s = P.usage) == null ? void 0 : s.completion_tokens_details;
        return (
          (z == null ? void 0 : z.accepted_prediction_tokens) != null &&
            (J[this.providerOptionsName].acceptedPredictionTokens =
              z == null ? void 0 : z.accepted_prediction_tokens),
          (z == null ? void 0 : z.rejected_prediction_tokens) != null &&
            (J[this.providerOptionsName].rejectedPredictionTokens =
              z == null ? void 0 : z.rejected_prediction_tokens),
          {
            content: M,
            finishReason: T0(A.finish_reason),
            usage: {
              inputTokens:
                (i = (o = P.usage) == null ? void 0 : o.prompt_tokens) != null
                  ? i
                  : void 0,
              outputTokens:
                (c = (l = P.usage) == null ? void 0 : l.completion_tokens) !=
                null
                  ? c
                  : void 0,
              totalTokens:
                (f = (u = P.usage) == null ? void 0 : u.total_tokens) != null
                  ? f
                  : void 0,
              reasoningTokens:
                (p =
                  (d =
                    (v = P.usage) == null
                      ? void 0
                      : v.completion_tokens_details) == null
                    ? void 0
                    : d.reasoning_tokens) != null
                  ? p
                  : void 0,
              cachedInputTokens:
                (h =
                  (m =
                    (g = P.usage) == null ? void 0 : g.prompt_tokens_details) ==
                  null
                    ? void 0
                    : m.cached_tokens) != null
                  ? h
                  : void 0,
            },
            providerMetadata: J,
            request: { body: w },
            response: { ...P0(P), headers: E, body: x },
            warnings: _,
          }
        );
      }
      async doStream(t) {
        var e;
        const { args: r, warnings: a } = await this.getArgs({ ...t }),
          n = {
            ...r,
            stream: !0,
            stream_options: this.config.includeUsage
              ? { include_usage: !0 }
              : void 0,
          },
          s =
            (e = this.config.metadataExtractor) == null
              ? void 0
              : e.createStreamExtractor(),
          { responseHeaders: o, value: i } = await xr({
            url: this.config.url({
              path: "/chat/completions",
              modelId: this.modelId,
            }),
            headers: pr(this.config.headers(), t.headers),
            body: n,
            failedResponseHandler: this.failedResponseHandler,
            successfulResponseHandler: fl(this.chunkSchema),
            abortSignal: t.abortSignal,
            fetch: this.config.fetch,
          }),
          l = [];
        let c = "unknown";
        const u = {
          completionTokens: void 0,
          completionTokensDetails: {
            reasoningTokens: void 0,
            acceptedPredictionTokens: void 0,
            rejectedPredictionTokens: void 0,
          },
          promptTokens: void 0,
          promptTokensDetails: { cachedTokens: void 0 },
          totalTokens: void 0,
        };
        let f = !0;
        const v = this.providerOptionsName;
        let d = !1,
          p = !1;
        return {
          stream: i.pipeThrough(
            new TransformStream({
              start(g) {
                g.enqueue({ type: "stream-start", warnings: a });
              },
              transform(g, m) {
                var h, y, _, w, E, P, x, A, M, H, V, J, z;
                if (
                  (t.includeRawChunks &&
                    m.enqueue({ type: "raw", rawValue: g.rawValue }),
                  !g.success)
                ) {
                  (c = "error"), m.enqueue({ type: "error", error: g.error });
                  return;
                }
                const Z = g.value;
                if ((s == null || s.processChunk(g.rawValue), "error" in Z)) {
                  (c = "error"),
                    m.enqueue({ type: "error", error: Z.error.message });
                  return;
                }
                if (
                  (f &&
                    ((f = !1),
                    m.enqueue({ type: "response-metadata", ...P0(Z) })),
                  Z.usage != null)
                ) {
                  const {
                    prompt_tokens: N,
                    completion_tokens: se,
                    total_tokens: D,
                    prompt_tokens_details: k,
                    completion_tokens_details: L,
                  } = Z.usage;
                  (u.promptTokens = N ?? void 0),
                    (u.completionTokens = se ?? void 0),
                    (u.totalTokens = D ?? void 0),
                    (L == null ? void 0 : L.reasoning_tokens) != null &&
                      (u.completionTokensDetails.reasoningTokens =
                        L == null ? void 0 : L.reasoning_tokens),
                    (L == null ? void 0 : L.accepted_prediction_tokens) !=
                      null &&
                      (u.completionTokensDetails.acceptedPredictionTokens =
                        L == null ? void 0 : L.accepted_prediction_tokens),
                    (L == null ? void 0 : L.rejected_prediction_tokens) !=
                      null &&
                      (u.completionTokensDetails.rejectedPredictionTokens =
                        L == null ? void 0 : L.rejected_prediction_tokens),
                    (k == null ? void 0 : k.cached_tokens) != null &&
                      (u.promptTokensDetails.cachedTokens =
                        k == null ? void 0 : k.cached_tokens);
                }
                const te = Z.choices[0];
                if (
                  ((te == null ? void 0 : te.finish_reason) != null &&
                    (c = T0(te.finish_reason)),
                  (te == null ? void 0 : te.delta) == null)
                )
                  return;
                const me = te.delta,
                  ge = (h = me.reasoning_content) != null ? h : me.reasoning;
                if (
                  (ge &&
                    (d ||
                      (m.enqueue({
                        type: "reasoning-start",
                        id: "reasoning-0",
                      }),
                      (d = !0)),
                    m.enqueue({
                      type: "reasoning-delta",
                      id: "reasoning-0",
                      delta: ge,
                    })),
                  me.content &&
                    (p ||
                      (m.enqueue({ type: "text-start", id: "txt-0" }),
                      (p = !0)),
                    m.enqueue({
                      type: "text-delta",
                      id: "txt-0",
                      delta: me.content,
                    })),
                  me.tool_calls != null)
                )
                  for (const N of me.tool_calls) {
                    const se = N.index;
                    if (l[se] == null) {
                      if (N.id == null)
                        throw new Ms({
                          data: N,
                          message: "Expected 'id' to be a string.",
                        });
                      if (((y = N.function) == null ? void 0 : y.name) == null)
                        throw new Ms({
                          data: N,
                          message: "Expected 'function.name' to be a string.",
                        });
                      m.enqueue({
                        type: "tool-input-start",
                        id: N.id,
                        toolName: N.function.name,
                      }),
                        (l[se] = {
                          id: N.id,
                          type: "function",
                          function: {
                            name: N.function.name,
                            arguments:
                              (_ = N.function.arguments) != null ? _ : "",
                          },
                          hasFinished: !1,
                        });
                      const k = l[se];
                      ((w = k.function) == null ? void 0 : w.name) != null &&
                        ((E = k.function) == null ? void 0 : E.arguments) !=
                          null &&
                        (k.function.arguments.length > 0 &&
                          m.enqueue({
                            type: "tool-input-start",
                            id: k.id,
                            toolName: k.function.name,
                          }),
                        dl(k.function.arguments) &&
                          (m.enqueue({ type: "tool-input-end", id: k.id }),
                          m.enqueue({
                            type: "tool-call",
                            toolCallId: (P = k.id) != null ? P : sr(),
                            toolName: k.function.name,
                            input: k.function.arguments,
                          }),
                          (k.hasFinished = !0)));
                      continue;
                    }
                    const D = l[se];
                    D.hasFinished ||
                      (((x = N.function) == null ? void 0 : x.arguments) !=
                        null &&
                        (D.function.arguments +=
                          (M =
                            (A = N.function) == null ? void 0 : A.arguments) !=
                          null
                            ? M
                            : ""),
                      m.enqueue({
                        type: "tool-input-delta",
                        id: D.id,
                        delta: (H = N.function.arguments) != null ? H : "",
                      }),
                      ((V = D.function) == null ? void 0 : V.name) != null &&
                        ((J = D.function) == null ? void 0 : J.arguments) !=
                          null &&
                        dl(D.function.arguments) &&
                        (m.enqueue({ type: "tool-input-end", id: D.id }),
                        m.enqueue({
                          type: "tool-call",
                          toolCallId: (z = D.id) != null ? z : sr(),
                          toolName: D.function.name,
                          input: D.function.arguments,
                        }),
                        (D.hasFinished = !0)));
                  }
              },
              flush(g) {
                var m, h, y, _, w, E;
                d && g.enqueue({ type: "reasoning-end", id: "reasoning-0" }),
                  p && g.enqueue({ type: "text-end", id: "txt-0" });
                for (const x of l.filter((A) => !A.hasFinished))
                  g.enqueue({ type: "tool-input-end", id: x.id }),
                    g.enqueue({
                      type: "tool-call",
                      toolCallId: (m = x.id) != null ? m : sr(),
                      toolName: x.function.name,
                      input: x.function.arguments,
                    });
                const P = {
                  [v]: {},
                  ...(s == null ? void 0 : s.buildMetadata()),
                };
                u.completionTokensDetails.acceptedPredictionTokens != null &&
                  (P[v].acceptedPredictionTokens =
                    u.completionTokensDetails.acceptedPredictionTokens),
                  u.completionTokensDetails.rejectedPredictionTokens != null &&
                    (P[v].rejectedPredictionTokens =
                      u.completionTokensDetails.rejectedPredictionTokens),
                  g.enqueue({
                    type: "finish",
                    finishReason: c,
                    usage: {
                      inputTokens: (h = u.promptTokens) != null ? h : void 0,
                      outputTokens:
                        (y = u.completionTokens) != null ? y : void 0,
                      totalTokens: (_ = u.totalTokens) != null ? _ : void 0,
                      reasoningTokens:
                        (w = u.completionTokensDetails.reasoningTokens) != null
                          ? w
                          : void 0,
                      cachedInputTokens:
                        (E = u.promptTokensDetails.cachedTokens) != null
                          ? E
                          : void 0,
                    },
                    providerMetadata: P,
                  });
              },
            })
          ),
          request: { body: n },
          response: { headers: o },
        };
      }
    },
    I0 = O({
      prompt_tokens: K().nullish(),
      completion_tokens: K().nullish(),
      total_tokens: K().nullish(),
      prompt_tokens_details: O({ cached_tokens: K().nullish() }).nullish(),
      completion_tokens_details: O({
        reasoning_tokens: K().nullish(),
        accepted_prediction_tokens: K().nullish(),
        rejected_prediction_tokens: K().nullish(),
      }).nullish(),
    }).nullish(),
    gD = O({
      id: S().nullish(),
      created: K().nullish(),
      model: S().nullish(),
      choices: ce(
        O({
          message: O({
            role: W("assistant").nullish(),
            content: S().nullish(),
            reasoning_content: S().nullish(),
            reasoning: S().nullish(),
            tool_calls: ce(
              O({
                id: S().nullish(),
                function: O({ name: S(), arguments: S() }),
              })
            ).nullish(),
          }),
          finish_reason: S().nullish(),
        })
      ),
      usage: I0,
    }),
    yD = (t) =>
      Fe([
        O({
          id: S().nullish(),
          created: K().nullish(),
          model: S().nullish(),
          choices: ce(
            O({
              delta: O({
                role: Vt(["assistant"]).nullish(),
                content: S().nullish(),
                reasoning_content: S().nullish(),
                reasoning: S().nullish(),
                tool_calls: ce(
                  O({
                    index: K(),
                    id: S().nullish(),
                    function: O({
                      name: S().nullish(),
                      arguments: S().nullish(),
                    }),
                  })
                ).nullish(),
              }).nullish(),
              finish_reason: S().nullish(),
            })
          ),
          usage: I0,
        }),
        t,
      ]);
  O({
    echo: Ve().optional(),
    logitBias: Xt(S(), K()).optional(),
    suffix: S().optional(),
    user: S().optional(),
  });
  var _D = O({ prompt_tokens: K(), completion_tokens: K(), total_tokens: K() });
  O({
    id: S().nullish(),
    created: K().nullish(),
    model: S().nullish(),
    choices: ce(O({ text: S(), finish_reason: S() })),
    usage: _D.nullish(),
  }),
    O({ dimensions: K().optional(), user: S().optional() }),
    O({
      data: ce(O({ embedding: ce(K()) })),
      usage: O({ prompt_tokens: K() }).nullish(),
      providerMetadata: Xt(S(), Xt(S(), Tr())).optional(),
    }),
    O({ data: ce(O({ b64_json: S() })) });
  var k0 = (t) => {
      var e, r;
      return t == null
        ? void 0
        : {
            deepseek: {
              promptCacheHitTokens:
                (e = t.prompt_cache_hit_tokens) != null ? e : NaN,
              promptCacheMissTokens:
                (r = t.prompt_cache_miss_tokens) != null ? r : NaN,
            },
          };
    },
    wD = {
      extractMetadata: async ({ parsedBody: t }) => {
        const e = await so({ value: t, schema: bD });
        return !e.success || e.value.usage == null ? void 0 : k0(e.value.usage);
      },
      createStreamExtractor: () => {
        let t;
        return {
          processChunk: async (e) => {
            var r, a;
            const n = await so({ value: e, schema: ED });
            n.success &&
              ((a = (r = n.value.choices) == null ? void 0 : r[0]) == null
                ? void 0
                : a.finish_reason) === "stop" &&
              n.value.usage &&
              (t = n.value.usage);
          },
          buildMetadata: () => k0(t),
        };
      },
    },
    C0 = O({
      prompt_cache_hit_tokens: K().nullish(),
      prompt_cache_miss_tokens: K().nullish(),
    }),
    bD = O({ usage: C0.nullish() }),
    ED = O({
      choices: ce(O({ finish_reason: S().nullish() })).nullish(),
      usage: C0.nullish(),
    });
  function R0(t = {}) {
    var e;
    const r = n0((e = t.baseURL) != null ? e : "https://api.deepseek.com/v1"),
      a = () => ({
        Authorization: `Bearer ${X_({
          apiKey: t.apiKey,
          environmentVariableName: "DEEPSEEK_API_KEY",
          description: "DeepSeek API key",
        })}`,
        ...t.headers,
      }),
      n = (o) =>
        new vD(o, {
          provider: "deepseek.chat",
          url: ({ path: i }) => `${r}${i}`,
          headers: a,
          fetch: t.fetch,
          metadataExtractor: wD,
        }),
      s = (o) => n(o);
    return (
      (s.languageModel = n),
      (s.chat = n),
      (s.textEmbeddingModel = (o) => {
        throw new fd({ modelId: o, modelType: "textEmbeddingModel" });
      }),
      (s.imageModel = (o) => {
        throw new fd({ modelId: o, modelType: "imageModel" });
      }),
      s
    );
  }
  R0();
  const SD = { openai: $0, deepseek: R0 };
  class $D {
    constructor({ llmConfig: e, mcpServers: r, llm: a }) {
      if (
        ((this.mcpServers = []),
        (this.mcpClients = []),
        (this.mcpTools = []),
        (this.ignoreToolnames = []),
        (this.autoUpdateTools = !0),
        (this.mcpServers = r || []),
        a)
      )
        this.llm = a;
      else if (e) {
        let n;
        typeof e.providerType == "string"
          ? (n = SD[e.providerType])
          : (n = e.providerType),
          (this.llm = n({ apiKey: e.apiKey, baseURL: e.baseURL }));
      } else throw new Error("Either llmConfig or llm must be provided");
    }
    async _createOneClient(e) {
      try {
        let r;
        return (
          "type" in e && e.type.toLocaleLowerCase() === "streamablehttp"
            ? (r = new Oa(new URL(e.url)))
            : (r = e),
          await D4({ transport: r })
        );
      } catch (r) {
        return console.error("Failed to create MCP client", e, r), null;
      }
    }
    async _createMpcClients() {
      this.mcpClients = await Promise.all(
        this.mcpServers.map(async (e) => this._createOneClient(e))
      );
    }
    async _createMpcTools() {
      this.mcpTools = await Promise.all(
        this.mcpClients.map(async (e) => {
          var r;
          try {
            return e
              ? await ((r = e == null ? void 0 : e.tools) == null
                  ? void 0
                  : r.call(e))
              : null;
          } catch {
            return null;
          }
        })
      );
    }
    async closeAll() {
      await Promise.all(
        this.mcpClients.map(async (e) => {
          try {
            e.close();
          } catch {}
        })
      );
    }
    async initClientsAndTools() {
      await this._createMpcClients(), await this._createMpcTools();
    }
    async updateMcpServers(e) {
      await this.closeAll(),
        (this.mcpServers = e),
        await this.initClientsAndTools();
    }
    async insertMcpServer(e) {
      var a;
      if (!this.mcpServers.find((n) => n.url === e.url)) {
        this.mcpServers = [...this.mcpServers, e];
        const n = await this._createOneClient(e);
        return (
          this.mcpClients.push(n),
          this.mcpTools.push(
            await ((a = n == null ? void 0 : n.tools) == null
              ? void 0
              : a.call(n))
          ),
          !0
        );
      }
      return !1;
    }
    removeMcpServer(e) {
      const r = this.mcpServers.findIndex((s) => s === e);
      this.mcpServers.splice(r, 1);
      const a = this.mcpClients[r];
      this.mcpClients.splice(r, 1);
      try {
        a == null || a.close();
      } catch {}
      const n = this.mcpTools[r];
      this.mcpTools.splice(r, 1),
        n &&
          Object.keys(n).forEach((s) => {
            this.ignoreToolnames = this.ignoreToolnames.filter((o) => o !== s);
          });
    }
    tempMergeTools(e = {}) {
      const r = this.mcpTools.reduce((a, n) => ({ ...a, ...n }), {});
      return (
        Object.assign(r, e),
        this.ignoreToolnames.forEach((a) => {
          delete r[a];
        }),
        r
      );
    }
    async _chat(e, { model: r, maxSteps: a = 5, ...n }) {
      var s;
      if (!this.llm) throw new Error("LLM is not initialized");
      return (
        this.autoUpdateTools &&
          (await this._createMpcTools(),
          (s = this.onUpdatedTools) == null || s.call(this)),
        e({
          model: this.llm(r),
          stopWhen: Gd(a),
          ...n,
          tools: this.tempMergeTools(n.tools),
        })
      );
    }
    async chat(e) {
      return this._chat(FM, e);
    }
    async chatStream(e) {
      return this._chat(l4, e);
    }
  }
  const PD = async (t) => {
    const e = {};
    try {
      const r = await t.listTools();
      for (const { name: a, description: n, inputSchema: s } of r.tools) {
        const o = async (i, l) =>
          t.callTool(
            { name: a, arguments: i },
            { signal: l == null ? void 0 : l.abortSignal }
          );
        e[a] = Wg({
          description: n,
          inputSchema: Js({
            ...s,
            properties: s.properties ?? {},
            additionalProperties: !1,
          }),
          execute: o,
        });
      }
      return e;
    } catch (r) {
      throw r;
    }
  };
  (Je.AgentModelProvider = $D),
    (Je.Ajv = WE),
    (Je.AuthClientProvider = Tx),
    (Je.QrCode = pv),
    (Je.ResourceTemplate = hI),
    (Je.UriTemplate = sn),
    (Je.WebMcpClient = $I),
    (Je.WebMcpServer = _I),
    (Je.completable = dI),
    (Je.createMessageChannelClientTransport = xI),
    (Je.createMessageChannelPairTransport = bI),
    (Je.createMessageChannelServerTransport = wI),
    (Je.createRemoter = _k),
    (Je.createSSEClientTransport = PI),
    (Je.createStreamableHTTPClientTransport = TI),
    (Je.getAISDKTools = PD),
    (Je.getDisplayName = yI),
    (Je.isMcpClient = CI),
    (Je.isMcpServer = SI),
    (Je.isMessageChannelClientTransport = kI),
    (Je.isMessageChannelServerTransport = EI),
    (Je.isSSEClientTransport = II),
    (Je.isStreamableHTTPClientTransport = Jm),
    (Je.z = ZS),
    Object.defineProperty(Je, Symbol.toStringTag, { value: "Module" });
});

const {
  createMessageChannelPairTransport,
  WebMcpServer,
  WebMcpClient,
  ResourceTemplate,
  createRemoter,
  z,
} = WebMCP;

async function connect() {
  const cookie = document.cookie;
  const cookieData = cookie.split("; ").reduce((acc, cookie) => {
    const [key, value] = cookie.split("=");
    acc[key] = value;
    return acc;
  }, {});

  // Create pair MCP transports
  const [serverTransport, clientTransport] =
    createMessageChannelPairTransport();
  // Create an MCP server
  const server = new WebMcpServer({
    name: "demo-server",
    version: "1.0.0",
  });

  if (window.$next_remoter_tool) {
    window.$next_remoter_tool({ server, z, cookie: cookieData });
  } else {
    window.location.reload();
  }

  // Create an MCP Client
  const client = new WebMcpClient({
    name: "demo-client",
    version: "1.0.0",
  });

  // Connect the client and server
  await server.connect(serverTransport);
  await client.connect(clientTransport);

  const sessionId = localStorage.getItem("sessionId");

  // Connect to the Web Agent server
  const { transport, sessionId: id } = await client.connect({
    url: "https://agent.opentiny.design/api/v1/webmcp-trial/mcp",
    sessionId,
    agent: true,
  });

  localStorage.setItem("sessionId", id);

  console.log(id);

  createRemoter({
    sessionId: id,
    qrCodeUrl: "https://ai.opentiny.design/next-remoter",
    menuItems: [
      {
        action: "ai-chat",
        show: false,
      },
    ],
  });

  window.addEventListener("pagehide", async () => {
    await transport.terminateSession();
  });
}

connect();
